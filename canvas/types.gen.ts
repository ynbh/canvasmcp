// This file is auto-generated by @hey-api/openapi-ts

export type Account = {
    /**
     * The storage quota for a group in the account in megabytes, if not otherwise specified
     */
    default_group_storage_quota_mb?: number | null;
    /**
     * The storage quota for the account in megabytes, if not otherwise specified
     */
    default_storage_quota_mb?: number | null;
    /**
     * The default time zone of the account. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
     */
    default_time_zone?: string | null;
    /**
     * The storage quota for a user in the account in megabytes, if not otherwise specified
     */
    default_user_storage_quota_mb?: number | null;
    /**
     * the ID of the Account object
     */
    id?: number | null;
    /**
     * The account's identifier in the Student Information System. Only included if the user has permission to view SIS information.
     */
    integration_id?: string | null;
    /**
     * The account's identifier that is sent as context_id in LTI launches.
     */
    lti_guid?: string | null;
    /**
     * The display name of the account
     */
    name?: string | null;
    /**
     * The account's parent ID, or null if this is the root account
     */
    parent_account_id?: number | null;
    /**
     * The ID of the root account, or null if this is the root account
     */
    root_account_id?: number | null;
    /**
     * The account's identifier in the Student Information System. Only included if the user has permission to view SIS information.
     */
    sis_account_id?: string | null;
    /**
     * The id of the SIS import if created through SIS. Only included if the user has permission to manage SIS information.
     */
    sis_import_id?: number | null;
    /**
     * The UUID of the account
     */
    uuid?: string | null;
    /**
     * The state of the account. Can be 'active' or 'deleted'.
     */
    workflow_state?: string | null;
};

export type AccountNotification = {
    /**
     * When to expire the notification.
     */
    end_at?: string | null;
    /**
     * The icon to display with the message.  Defaults to warning.
     */
    icon?: string | null;
    /**
     * The message to be sent in the notification.
     */
    message?: string | null;
    /**
     * The roles to send the notification to.  If roles is not passed it defaults to all roles
     */
    role_ids?: Array<number> | null;
    /**
     * (Deprecated) The roles to send the notification to.  If roles is not passed it defaults to all roles
     */
    roles?: Array<string> | null;
    /**
     * When to send out the notification.
     */
    start_at?: string | null;
    /**
     * The subject of the notifications
     */
    subject?: string | null;
};

export type ActivityStream = {
    created_at?: string;
    updated_at?: string;
    id?: number;
    title?: string;
    /**
     * The body text of the activity stream item.
     */
    message?: string;
    type?: string;
    read_state?: boolean;
    context_type?: string;
    course_id?: number;
    group_id?: number;
    /**
     * the URL to the Canvas web UI for this stream item
     */
    html_url?: string;
};

export type Admin = {
    /**
     * The unique identifier for the account role/user assignment.
     */
    id: number;
    /**
     * The account role assigned. This can be 'AccountAdmin' or a user-defined role created by the Roles API.
     */
    role?: string | null;
    user?: User;
    /**
     * The status of the account role/user assignment.
     */
    workflow_state?: string | null;
};

export type Answer = {
    /**
     * Specific contextual comments for a particular answer.
     */
    answer_comments?: string | null;
    /**
     * Used in matching questions.  The static value of the answer that will be displayed on the left for students to match for.
     */
    answer_match_left?: string | null;
    /**
     * Used in matching questions. The correct match for the value given in answer_match_left.  Will be displayed in a dropdown with the other answer_match_right values..
     */
    answer_match_right?: string | null;
    /**
     * The text of the answer.
     */
    answer_text: string;
    /**
     * An integer to determine correctness of the answer. Incorrect answers should be 0, correct answers should be non-negative.
     */
    answer_weight: number;
    /**
     * Used in numerical questions of type 'precision_answer'.  The value the answer should equal.
     */
    approximate?: number | null;
    /**
     * Used in fill in multiple blank and multiple dropdowns questions.
     */
    blank_id?: number | null;
    /**
     * Used in numerical questions of type 'range_answer'. The end of the allowed range (inclusive).
     */
    end?: number | null;
    /**
     * Used in numerical questions of type 'exact_answer'.  The value the answer should equal.
     */
    exact?: number | null;
    /**
     * The unique identifier for the answer.  Do not supply if this answer is part of a new question
     */
    id?: number | null;
    /**
     * Used in numerical questions of type 'exact_answer'. The margin of error allowed for the student's answer.
     */
    margin?: number | null;
    /**
     * Used in matching questions. A list of distractors, delimited by new lines (
     * ) that will be seeded with all the answer_match_right values.
     */
    matching_answer_incorrect_matches?: string | null;
    /**
     * Used in numerical questions.  Values can be 'exact_answer', 'range_answer', or 'precision_answer'.
     */
    numerical_answer_type?: string | null;
    /**
     * Used in numerical questions of type 'precision_answer'. The numerical precision that will be used when comparing the student's answer.
     */
    precision?: number | null;
    /**
     * Used in numerical questions of type 'range_answer'. The start of the allowed range (inclusive).
     */
    start?: number | null;
    /**
     * Used in missing word questions.  The text to follow the missing word
     */
    text_after_answers?: string | null;
};

export type Assignment = {
    /**
     * (Optional) all dates associated with the assignment, if applicable
     */
    all_dates?: Array<AssignmentDate> | null;
    /**
     * Allowed file extensions, which take effect if submission_types includes 'online_upload'.
     */
    allowed_extensions?: Array<string> | null;
    /**
     * (Optional) whether anonymous submissions are accepted (applies only to quiz assignments)
     */
    anonymous_submissions?: boolean | null;
    /**
     * the ID of the assignment's group
     */
    assignment_group_id?: number | null;
    /**
     * (Optional) If 'assignment_visibility' is included in the 'include' parameter, includes an array of student IDs who can see this assignment.
     */
    assignment_visibility?: Array<number> | null;
    /**
     * Boolean indicating peer reviews are assigned automatically. If false, the teacher is expected to manually assign peer reviews.
     */
    automatic_peer_reviews?: boolean | null;
    /**
     * the ID of the course the assignment belongs to
     */
    course_id?: number | null;
    /**
     * The time at which this assignment was originally created
     */
    created_at?: string | null;
    /**
     * the assignment description, in an HTML fragment
     */
    description?: string | null;
    discussion_topic?: DiscussionTopicNullable;
    /**
     * the due date for the assignment. returns null if not present. NOTE: If this assignment has assignment overrides, this field will be the due date as it applies to the user requesting information from the API.
     */
    due_at?: string | null;
    /**
     * Boolean flag indicating whether the assignment requires a due date based on the account level setting
     */
    due_date_required?: boolean | null;
    external_tool_tag_attributes?: ExternalToolTagAttributes;
    /**
     * (Optional) Boolean indicating if assignment will be frozen when it is copied. NOTE: This field will only be present if the AssignmentFreezer plugin is available for your account.
     */
    freeze_on_copy?: boolean | null;
    /**
     * (Optional) Boolean indicating if assignment is frozen for the calling user. NOTE: This field will only be present if the AssignmentFreezer plugin is available for your account.
     */
    frozen?: boolean | null;
    /**
     * (Optional) Array of frozen attributes for the assignment. Only account administrators currently have permission to change an attribute in this list. Will be empty if no attributes are frozen for this assignment. Possible frozen attributes are: title, description, lock_at, points_possible, grading_type, submission_types, assignment_group_id, allowed_extensions, group_category_id, notify_of_update, peer_reviews NOTE: This field will only be present if the AssignmentFreezer plugin is available for your account.
     */
    frozen_attributes?: Array<string> | null;
    /**
     * If this is a group assignment, boolean flag indicating whether or not students will be graded individually.
     */
    grade_group_students_individually?: boolean | null;
    /**
     * The id of the grading standard being applied to this assignment. Valid if grading_type is 'letter_grade' or 'gpa_scale'.
     */
    grading_standard_id?: number | null;
    /**
     * The type of grading the assignment receives; one of 'pass_fail', 'percent', 'letter_grade', 'gpa_scale', 'points'
     */
    grading_type?: string | null;
    /**
     * The ID of the assignments group set, if this is a group assignment. For group discussions, set group_category_id on the discussion topic, not the linked assignment.
     */
    group_category_id?: number | null;
    /**
     * whether this assignment has overrides
     */
    has_overrides?: boolean | null;
    /**
     * If true, the assignment has been submitted to by at least one student
     */
    has_submitted_submissions?: boolean | null;
    /**
     * the URL to the assignment's web page
     */
    html_url?: string | null;
    /**
     * the ID of the assignment
     */
    id?: number | null;
    /**
     * (optional, Third Party integration data for assignment)
     */
    integration_data?: {
        [key: string]: string;
    } | null;
    /**
     * (optional, Third Party unique identifier for Assignment)
     */
    integration_id?: string | null;
    /**
     * Boolean representing whether or not members from within the same group on a group assignment can be assigned to peer review their own group's work
     */
    intra_group_peer_reviews?: boolean | null;
    /**
     * the lock date (assignment is locked after this date). returns null if not present. NOTE: If this assignment has assignment overrides, this field will be the lock date as it applies to the user requesting information from the API.
     */
    lock_at?: string | null;
    /**
     * (Optional) An explanation of why this is locked for the user. Present when locked_for_user is true.
     */
    lock_explanation?: string | null;
    lock_info?: LockInfo;
    /**
     * Whether or not this is locked for the user.
     */
    locked_for_user?: boolean | null;
    /**
     * An integer indicating the maximum length an assignment's name may be
     */
    max_name_length?: number | null;
    /**
     * Boolean indicating if the assignment is moderated.
     */
    moderated_grading?: boolean | null;
    /**
     * whether the assignment is muted
     */
    muted?: boolean | null;
    /**
     * the name of the assignment
     */
    name?: string | null;
    /**
     * if the requesting user has grading rights, the number of submissions that need grading.
     */
    needs_grading_count?: number | null;
    /**
     * if the requesting user has grading rights and the 'needs_grading_count_by_section' flag is specified, the number of submissions that need grading split out by section. NOTE: This key is NOT present unless you pass the 'needs_grading_count_by_section' argument as true.  ANOTHER NOTE: it's possible to be enrolled in multiple sections, and if a student is setup that way they will show an assignment that needs grading in multiple sections (effectively the count will be duplicated between sections)
     */
    needs_grading_count_by_section?: Array<NeedsGradingCount> | null;
    /**
     * (Optional) If true, the assignment will be omitted from the student's final grade
     */
    omit_from_final_grade?: boolean | null;
    /**
     * Whether the assignment is only visible to overrides.
     */
    only_visible_to_overrides?: boolean | null;
    /**
     * (Optional) If 'overrides' is included in the 'include' parameter, includes an array of assignment override objects.
     */
    overrides?: Array<AssignmentOverride> | null;
    /**
     * Integer representing the amount of reviews each user is assigned. NOTE: This key is NOT present unless you have automatic_peer_reviews set to true.
     */
    peer_review_count?: number | null;
    /**
     * Boolean indicating if peer reviews are required for this assignment
     */
    peer_reviews?: boolean | null;
    /**
     * String representing a date the reviews are due by. Must be a date that occurs after the default due date. If blank, or date is not after the assignment's due date, the assignment's due date will be used. NOTE: This key is NOT present unless you have automatic_peer_reviews set to true.
     */
    peer_reviews_assign_at?: string | null;
    /**
     * the maximum points possible for the assignment
     */
    points_possible?: number | null;
    /**
     * the sorting order of the assignment in the group
     */
    position?: number | null;
    /**
     * (optional, present if Sync Grades to SIS feature is enabled)
     */
    post_to_sis?: boolean | null;
    /**
     * Whether the assignment is published
     */
    published?: boolean | null;
    /**
     * (Optional) id of the associated quiz (applies only when submission_types is ['online_quiz'])
     */
    quiz_id?: number | null;
    /**
     * (Optional) A list of scoring criteria and ratings for each rubric criterion. Included if there is an associated rubric.
     */
    rubric?: Array<RubricCriteria> | null;
    rubric_settings?: RubricSettings;
    submission?: SubmissionNullable;
    /**
     * the types of submissions allowed for this assignment list containing one or more of the following: 'discussion_topic', 'online_quiz', 'on_paper', 'none', 'external_tool', 'online_text_entry', 'online_url', 'online_upload' 'media_recording'
     */
    submission_types?: Array<string> | null;
    /**
     * the URL to download all submissions as a zip
     */
    submissions_download_url?: string | null;
    /**
     * Boolean flag indicating whether or not Turnitin has been enabled for the assignment. NOTE: This flag will not appear unless your account has the Turnitin plugin available
     */
    turnitin_enabled?: boolean | null;
    turnitin_settings?: TurnitinSettings;
    /**
     * the unlock date (assignment is unlocked after this date) returns null if not present NOTE: If this assignment has assignment overrides, this field will be the unlock date as it applies to the user requesting information from the API.
     */
    unlock_at?: string | null;
    /**
     * Whether the assignment's 'published' state can be changed to false. Will be false if there are student submissions for the assignment.
     */
    unpublishable?: boolean | null;
    /**
     * The time at which this assignment was last modified in any way
     */
    updated_at?: string | null;
    /**
     * (Optional) If true, the rubric is directly tied to grading the assignment. Otherwise, it is only advisory. Included if there is an associated rubric.
     */
    use_rubric_for_grading?: boolean | null;
    /**
     * Boolean flag indicating whether or not VeriCite has been enabled for the assignment. NOTE: This flag will not appear unless your account has the VeriCite plugin available
     */
    vericite_enabled?: boolean | null;
};

/**
 * The submission's assignment (see the assignments API) (optional)
 */
export type AssignmentNullable = {
    /**
     * (Optional) all dates associated with the assignment, if applicable
     */
    all_dates?: Array<AssignmentDate> | null;
    /**
     * Allowed file extensions, which take effect if submission_types includes 'online_upload'.
     */
    allowed_extensions?: Array<string> | null;
    /**
     * (Optional) whether anonymous submissions are accepted (applies only to quiz assignments)
     */
    anonymous_submissions?: boolean | null;
    /**
     * the ID of the assignment's group
     */
    assignment_group_id?: number | null;
    /**
     * (Optional) If 'assignment_visibility' is included in the 'include' parameter, includes an array of student IDs who can see this assignment.
     */
    assignment_visibility?: Array<number> | null;
    /**
     * Boolean indicating peer reviews are assigned automatically. If false, the teacher is expected to manually assign peer reviews.
     */
    automatic_peer_reviews?: boolean | null;
    /**
     * the ID of the course the assignment belongs to
     */
    course_id?: number | null;
    /**
     * The time at which this assignment was originally created
     */
    created_at?: string | null;
    /**
     * the assignment description, in an HTML fragment
     */
    description?: string | null;
    discussion_topic?: DiscussionTopicNullable;
    /**
     * the due date for the assignment. returns null if not present. NOTE: If this assignment has assignment overrides, this field will be the due date as it applies to the user requesting information from the API.
     */
    due_at?: string | null;
    /**
     * Boolean flag indicating whether the assignment requires a due date based on the account level setting
     */
    due_date_required?: boolean | null;
    external_tool_tag_attributes?: ExternalToolTagAttributes;
    /**
     * (Optional) Boolean indicating if assignment will be frozen when it is copied. NOTE: This field will only be present if the AssignmentFreezer plugin is available for your account.
     */
    freeze_on_copy?: boolean | null;
    /**
     * (Optional) Boolean indicating if assignment is frozen for the calling user. NOTE: This field will only be present if the AssignmentFreezer plugin is available for your account.
     */
    frozen?: boolean | null;
    /**
     * (Optional) Array of frozen attributes for the assignment. Only account administrators currently have permission to change an attribute in this list. Will be empty if no attributes are frozen for this assignment. Possible frozen attributes are: title, description, lock_at, points_possible, grading_type, submission_types, assignment_group_id, allowed_extensions, group_category_id, notify_of_update, peer_reviews NOTE: This field will only be present if the AssignmentFreezer plugin is available for your account.
     */
    frozen_attributes?: Array<string> | null;
    /**
     * If this is a group assignment, boolean flag indicating whether or not students will be graded individually.
     */
    grade_group_students_individually?: boolean | null;
    /**
     * The id of the grading standard being applied to this assignment. Valid if grading_type is 'letter_grade' or 'gpa_scale'.
     */
    grading_standard_id?: number | null;
    /**
     * The type of grading the assignment receives; one of 'pass_fail', 'percent', 'letter_grade', 'gpa_scale', 'points'
     */
    grading_type?: string | null;
    /**
     * The ID of the assignments group set, if this is a group assignment. For group discussions, set group_category_id on the discussion topic, not the linked assignment.
     */
    group_category_id?: number | null;
    /**
     * whether this assignment has overrides
     */
    has_overrides?: boolean | null;
    /**
     * If true, the assignment has been submitted to by at least one student
     */
    has_submitted_submissions?: boolean | null;
    /**
     * the URL to the assignment's web page
     */
    html_url?: string | null;
    /**
     * the ID of the assignment
     */
    id?: number | null;
    /**
     * (optional, Third Party integration data for assignment)
     */
    integration_data?: {
        [key: string]: string;
    } | null;
    /**
     * (optional, Third Party unique identifier for Assignment)
     */
    integration_id?: string | null;
    /**
     * Boolean representing whether or not members from within the same group on a group assignment can be assigned to peer review their own group's work
     */
    intra_group_peer_reviews?: boolean | null;
    /**
     * the lock date (assignment is locked after this date). returns null if not present. NOTE: If this assignment has assignment overrides, this field will be the lock date as it applies to the user requesting information from the API.
     */
    lock_at?: string | null;
    /**
     * (Optional) An explanation of why this is locked for the user. Present when locked_for_user is true.
     */
    lock_explanation?: string | null;
    lock_info?: LockInfo;
    /**
     * Whether or not this is locked for the user.
     */
    locked_for_user?: boolean | null;
    /**
     * An integer indicating the maximum length an assignment's name may be
     */
    max_name_length?: number | null;
    /**
     * Boolean indicating if the assignment is moderated.
     */
    moderated_grading?: boolean | null;
    /**
     * whether the assignment is muted
     */
    muted?: boolean | null;
    /**
     * the name of the assignment
     */
    name?: string | null;
    /**
     * if the requesting user has grading rights, the number of submissions that need grading.
     */
    needs_grading_count?: number | null;
    /**
     * if the requesting user has grading rights and the 'needs_grading_count_by_section' flag is specified, the number of submissions that need grading split out by section. NOTE: This key is NOT present unless you pass the 'needs_grading_count_by_section' argument as true.  ANOTHER NOTE: it's possible to be enrolled in multiple sections, and if a student is setup that way they will show an assignment that needs grading in multiple sections (effectively the count will be duplicated between sections)
     */
    needs_grading_count_by_section?: Array<NeedsGradingCount> | null;
    /**
     * (Optional) If true, the assignment will be omitted from the student's final grade
     */
    omit_from_final_grade?: boolean | null;
    /**
     * Whether the assignment is only visible to overrides.
     */
    only_visible_to_overrides?: boolean | null;
    /**
     * (Optional) If 'overrides' is included in the 'include' parameter, includes an array of assignment override objects.
     */
    overrides?: Array<AssignmentOverride> | null;
    /**
     * Integer representing the amount of reviews each user is assigned. NOTE: This key is NOT present unless you have automatic_peer_reviews set to true.
     */
    peer_review_count?: number | null;
    /**
     * Boolean indicating if peer reviews are required for this assignment
     */
    peer_reviews?: boolean | null;
    /**
     * String representing a date the reviews are due by. Must be a date that occurs after the default due date. If blank, or date is not after the assignment's due date, the assignment's due date will be used. NOTE: This key is NOT present unless you have automatic_peer_reviews set to true.
     */
    peer_reviews_assign_at?: string | null;
    /**
     * the maximum points possible for the assignment
     */
    points_possible?: number | null;
    /**
     * the sorting order of the assignment in the group
     */
    position?: number | null;
    /**
     * (optional, present if Sync Grades to SIS feature is enabled)
     */
    post_to_sis?: boolean | null;
    /**
     * Whether the assignment is published
     */
    published?: boolean | null;
    /**
     * (Optional) id of the associated quiz (applies only when submission_types is ['online_quiz'])
     */
    quiz_id?: number | null;
    /**
     * (Optional) A list of scoring criteria and ratings for each rubric criterion. Included if there is an associated rubric.
     */
    rubric?: Array<RubricCriteria> | null;
    rubric_settings?: RubricSettings;
    submission?: SubmissionNullable;
    /**
     * the types of submissions allowed for this assignment list containing one or more of the following: 'discussion_topic', 'online_quiz', 'on_paper', 'none', 'external_tool', 'online_text_entry', 'online_url', 'online_upload' 'media_recording'
     */
    submission_types?: Array<string> | null;
    /**
     * the URL to download all submissions as a zip
     */
    submissions_download_url?: string | null;
    /**
     * Boolean flag indicating whether or not Turnitin has been enabled for the assignment. NOTE: This flag will not appear unless your account has the Turnitin plugin available
     */
    turnitin_enabled?: boolean | null;
    turnitin_settings?: TurnitinSettings;
    /**
     * the unlock date (assignment is unlocked after this date) returns null if not present NOTE: If this assignment has assignment overrides, this field will be the unlock date as it applies to the user requesting information from the API.
     */
    unlock_at?: string | null;
    /**
     * Whether the assignment's 'published' state can be changed to false. Will be false if there are student submissions for the assignment.
     */
    unpublishable?: boolean | null;
    /**
     * The time at which this assignment was last modified in any way
     */
    updated_at?: string | null;
    /**
     * (Optional) If true, the rubric is directly tied to grading the assignment. Otherwise, it is only advisory. Included if there is an associated rubric.
     */
    use_rubric_for_grading?: boolean | null;
    /**
     * Boolean flag indicating whether or not VeriCite has been enabled for the assignment. NOTE: This flag will not appear unless your account has the VeriCite plugin available
     */
    vericite_enabled?: boolean | null;
} | null;

/**
 * Object representing a due date for an assignment or quiz. If the due date came from an assignment override, it will have an 'id' field.
 */
export type AssignmentDate = {
    /**
     * (Optional, present if 'id' is missing) whether this date represents the assignment's or quiz's default due date
     */
    base?: boolean | null;
    /**
     * The due date for the assignment. Must be between the unlock date and the lock date if there are lock dates
     */
    due_at?: string | null;
    /**
     * (Optional, missing if 'base' is present) id of the assignment override this date represents
     */
    id?: number | null;
    /**
     * The lock date for the assignment. Must be after the due date if there is a due date.
     */
    lock_at?: string | null;
    title?: string | null;
    /**
     * The unlock date for the assignment. Must be before the due date if there is a due date.
     */
    unlock_at?: string | null;
};

export type AssignmentGroup = {
    /**
     * the assignments in this Assignment Group (see the Assignment API for a detailed list of fields)
     */
    assignments?: Array<number> | null;
    /**
     * the weight of the Assignment Group
     */
    group_weight?: number | null;
    /**
     * the id of the Assignment Group
     */
    id?: number | null;
    /**
     * the integration data of the Assignment Group
     */
    integration_data?: {
        [key: string]: unknown;
    } | null;
    /**
     * the name of the Assignment Group
     */
    name?: string | null;
    /**
     * the position of the Assignment Group
     */
    position?: number | null;
    rules?: GradingRules;
    /**
     * the sis source id of the Assignment Group
     */
    sis_source_id?: string | null;
};

export type AssignmentOverride = {
    /**
     * the overridden all day flag (present if due_at is overridden)
     */
    all_day?: number | null;
    /**
     * the overridden all day date (present if due_at is overridden)
     */
    all_day_date?: string | null;
    /**
     * the ID of the assignment the override applies to
     */
    assignment_id?: number | null;
    /**
     * the ID of the overrides's target section (present if the override targets a section)
     */
    course_section_id?: number | null;
    /**
     * the overridden due at (present if due_at is overridden)
     */
    due_at?: string | null;
    /**
     * the ID of the override's target group (present if the override targets a group and the assignment is a group assignment)
     */
    group_id?: number | null;
    /**
     * the ID of the assignment override
     */
    id?: number | null;
    /**
     * the overridden lock at, if any (present if lock_at is overridden)
     */
    lock_at?: string | null;
    /**
     * the IDs of the override's target students (present if the override targets an ad-hoc set of students)
     */
    student_ids?: Array<number> | null;
    /**
     * the title of the override
     */
    title?: string | null;
    /**
     * the overridden unlock at (present if unlock_at is overridden)
     */
    unlock_at?: string | null;
};

export type AuthenticationProvider = {
    /**
     * Valid for LDAP and CAS providers.
     */
    auth_base?: string | null;
    /**
     * Valid for LDAP providers.
     */
    auth_filter?: string | null;
    /**
     * Valid for LDAP providers.
     */
    auth_host?: string | null;
    /**
     * Valid for LDAP providers.
     */
    auth_over_tls?: number | null;
    /**
     * Valid for LDAP providers.
     */
    auth_port?: number | null;
    /**
     * Valid for all providers.
     */
    auth_type?: string | null;
    /**
     * Valid for LDAP providers.
     */
    auth_username?: string | null;
    /**
     * Valid for SAML providers.
     */
    certificate_fingerprint?: string | null;
    federated_attributes?: FederatedAttributesConfig;
    /**
     * Valid for all providers.
     */
    id?: number | null;
    /**
     * Valid for SAML providers.
     */
    identifier_format?: string | null;
    /**
     * Valid for SAML providers.
     */
    idp_entity_id?: string | null;
    /**
     * Just In Time provisioning. Valid for all providers except Canvas (which has the similar in concept self_registration setting).
     */
    jit_provisioning?: boolean | null;
    /**
     * Valid for SAML and CAS providers.
     */
    log_in_url?: string | null;
    /**
     * Valid for SAML providers.
     */
    log_out_url?: string | null;
    /**
     * Valid for SAML providers.
     */
    login_attribute?: string | null;
    /**
     * Valid for all providers.
     */
    position?: number | null;
    /**
     * Valid for SAML providers.
     */
    requested_authn_context?: string | null;
    /**
     * Valid for SAML providers.
     */
    sig_alg?: string | null;
};

/**
 * Possible avatar for a user.
 */
export type Avatar = {
    /**
     * ['attachment' type only] the content-type of the attachment.
     */
    'content-type'?: string | null;
    /**
     * A textual description of the avatar record.
     */
    display_name: string;
    /**
     * ['attachment' type only] the filename of the attachment
     */
    filename?: string | null;
    /**
     * ['attachment' type only] the internal id of the attachment
     */
    id?: number | null;
    /**
     * ['attachment' type only] the size of the attachment
     */
    size?: number | null;
    /**
     * A unique representation of the avatar record which can be used to set the avatar with the user update endpoint. Note: this is an internal representation and is subject to change without notice. It should be consumed with this api endpoint and used in the user update endpoint, and should not be constructed by the client.
     */
    token: string;
    /**
     * ['gravatar'|'attachment'|'no_pic'] The type of avatar record, for categorization purposes.
     */
    type: string;
    /**
     * The url of the avatar
     */
    url: string;
};

export type BlueprintMigration = {
    /**
     * User-specified comment describing changes made in this operation
     */
    comment?: string | null;
    /**
     * Time when the migration was queued
     */
    created_at?: string | null;
    /**
     * Time when the exports begun
     */
    exports_started_at?: string | null;
    /**
     * The ID of the migration.
     */
    id?: number | null;
    /**
     * Time when the imports were completed
     */
    imports_completed_at?: string | null;
    /**
     * Time when the exports were completed and imports were queued
     */
    imports_queued_at?: string | null;
    /**
     * The ID of the associated course's blueprint subscription. Only present when querying a course associated with a blueprint.
     */
    subscription_id?: number | null;
    /**
     * The ID of the template the migration belongs to. Only present when querying a blueprint course.
     */
    template_id?: number | null;
    /**
     * The ID of the user who queued the migration.
     */
    user_id?: number | null;
    /**
     * Current state of the content migration: queued, exporting, imports_queued, completed, exports_failed, imports_failed
     */
    workflow_state?: string | null;
};

export type BlueprintMigrationNullable = {
    /**
     * User-specified comment describing changes made in this operation
     */
    comment?: string | null;
    /**
     * Time when the migration was queued
     */
    created_at?: string | null;
    /**
     * Time when the exports begun
     */
    exports_started_at?: string | null;
    /**
     * The ID of the migration.
     */
    id?: number | null;
    /**
     * Time when the imports were completed
     */
    imports_completed_at?: string | null;
    /**
     * Time when the exports were completed and imports were queued
     */
    imports_queued_at?: string | null;
    /**
     * The ID of the associated course's blueprint subscription. Only present when querying a course associated with a blueprint.
     */
    subscription_id?: number | null;
    /**
     * The ID of the template the migration belongs to. Only present when querying a blueprint course.
     */
    template_id?: number | null;
    /**
     * The ID of the user who queued the migration.
     */
    user_id?: number | null;
    /**
     * Current state of the content migration: queued, exporting, imports_queued, completed, exports_failed, imports_failed
     */
    workflow_state?: string | null;
} | null;

/**
 * Associates a course with a blueprint
 */
export type BlueprintSubscription = {
    /**
     * The blueprint course subscribed to
     */
    blueprint_course?: {
        [key: string]: unknown;
    } | null;
    /**
     * The ID of the blueprint course subscription
     */
    id?: number | null;
    /**
     * The ID of the blueprint template the associated course is subscribed to
     */
    template_id?: number | null;
};

export type BlueprintTemplate = {
    /**
     * Number of associated courses for the template
     */
    associated_course_count?: number | null;
    /**
     * The ID of the Course the template belongs to.
     */
    course_id?: number | null;
    /**
     * The ID of the template.
     */
    id?: number | null;
    /**
     * Time when the last export was completed
     */
    last_export_completed_at?: string | null;
    latest_migration?: BlueprintMigrationNullable;
};

export type Bookmark = {
    data?: {
        [key: string]: unknown;
    } | null;
    id?: number | null;
    name?: string | null;
    position?: number | null;
    url?: string;
};

export type CalendarEvent = {
    /**
     * a comma-separated list of all calendar contexts this event is part of
     */
    all_context_codes?: string | null;
    /**
     * Boolean indicating whether this is an all-day event (midnight to midnight)
     */
    all_day?: boolean | null;
    /**
     * The date of this event
     */
    all_day_date?: string | null;
    /**
     * Various Appointment-Group-related fields.These fields are only pertinent to time slots (appointments) and reservations of those time slots. See the Appointment Groups API. The id of the appointment group
     */
    appointment_group_id?: number | null;
    /**
     * The API URL of the appointment group
     */
    appointment_group_url?: string | null;
    /**
     * If the event is a time slot and it has a participant limit, an integer indicating how many slots are available
     */
    available_slots?: number | null;
    /**
     * Included by default, but may be excluded (see include[] option). If this is a time slot (see the Appointment Groups API) this will be a list of any reservations. If this is a course-level event, this will be a list of section-level events (if any)
     */
    child_events?: Array<number> | null;
    /**
     * The number of child_events. See child_events (and parent_event_id)
     */
    child_events_count?: number | null;
    /**
     * the context code of the calendar this event belongs to (course, user or group)
     */
    context_code?: string | null;
    /**
     * When the calendar event was created
     */
    created_at?: string | null;
    /**
     * The HTML description of the event
     */
    description?: string | null;
    /**
     * if specified, it indicates which calendar this event should be displayed on. for example, a section-level event would have the course's context code here, while the section's context code would be returned above)
     */
    effective_context_code?: string | null;
    /**
     * The end timestamp of the event
     */
    end_at?: string | null;
    /**
     * If the event is a group-level reservation, this will contain the group participant JSON (refer to the Groups API).
     */
    group?: string | null;
    /**
     * Whether this event should be displayed on the calendar. Only true for course-level events with section-level child events.
     */
    hidden?: boolean | null;
    /**
     * URL for a user to view this event
     */
    html_url?: string | null;
    /**
     * The ID of the calendar event
     */
    id?: number | null;
    /**
     * The address where the event is taking place
     */
    location_address?: string | null;
    /**
     * The location name of the event
     */
    location_name?: string | null;
    /**
     * If the event is a reservation, this a boolean indicating whether it is the current user's reservation, or someone else's
     */
    own_reservation?: boolean | null;
    /**
     * Normally null. If this is a reservation (see the Appointment Groups API), the id will indicate the time slot it is for. If this is a section-level event, this will be the course-level parent event.
     */
    parent_event_id?: number | null;
    /**
     * The type of participant to sign up for a slot: 'User' or 'Group'
     */
    participant_type?: string | null;
    /**
     * If the event is a time slot, this is the participant limit
     */
    participants_per_appointment?: number | null;
    /**
     * If the event is a time slot, the API URL for reserving it
     */
    reserve_url?: string | null;
    /**
     * If the event is a time slot, a boolean indicating whether the user has already made a reservation for it
     */
    reserved?: boolean | null;
    /**
     * The start timestamp of the event
     */
    start_at?: string | null;
    /**
     * The title of the calendar event
     */
    title?: string | null;
    /**
     * When the calendar event was last updated
     */
    updated_at?: string | null;
    /**
     * URL for this calendar event (to update, delete, etc.)
     */
    url?: string;
    /**
     * If the event is a user-level reservation, this will contain the user participant JSON (refer to the Users API).
     */
    user?: string | null;
    /**
     * Current state of the event ('active', 'locked' or 'deleted') 'locked' indicates that start_at/end_at cannot be changed (though the event could be deleted). Normally only reservations or time slots with reservations are locked (see the Appointment Groups API)
     */
    workflow_state?: string | null;
};

export type CalendarLink = {
    /**
     * The URL of the calendar in ICS format
     */
    ics?: string | null;
} | null;

/**
 * Describes a learning object change propagated to associated courses from a blueprint course
 */
export type ChangeRecord = {
    /**
     * The ID of the learning object that was changed in the blueprint course.
     */
    asset_id?: number | null;
    /**
     * The name of the learning object that was changed in the blueprint course.
     */
    asset_name?: string | null;
    /**
     * The type of the learning object that was changed in the blueprint course.  One of 'assignment', 'attachment', 'discussion_topic', 'external_tool', 'quiz', or 'wiki_page'.
     */
    asset_type?: string | null;
    /**
     * The type of change; one of 'created', 'updated', 'deleted'
     */
    change_type?: string | null;
    /**
     * A list of ExceptionRecords for linked courses that did not receive this update.
     */
    exceptions?: Array<{
        [key: string]: unknown;
    }> | null;
    /**
     * The URL of the changed object
     */
    html_url?: string | null;
    /**
     * Whether the object is locked in the blueprint
     */
    locked?: boolean | null;
};

export type Collaboration = {
    /**
     * A name for the type of collaboration
     */
    collaboration_type?: string | null;
    /**
     * The canvas id of the course or group to which the collaboration belongs
     */
    context_id?: number | null;
    /**
     * The canvas type of the course or group to which the collaboration belongs
     */
    context_type?: string | null;
    /**
     * The timestamp when the collaboration was created
     */
    created_at?: string | null;
    description?: string | null;
    /**
     * The collaboration document identifier for the collaboration provider
     */
    document_id?: string | null;
    /**
     * The unique identifier for the collaboration
     */
    id?: number | null;
    title?: string | null;
    /**
     * Another representation of the collaboration type
     */
    type?: string;
    /**
     * The LTI launch url to edit the collaboration
     */
    update_url?: string | null;
    /**
     * The timestamp when the collaboration was last modified
     */
    updated_at?: string | null;
    /**
     * The LTI launch url to view collaboration.
     */
    url?: string;
    /**
     * The canvas id of the user who created the collaboration
     */
    user_id?: number | null;
    /**
     * The name of the user who owns the collaboration
     */
    user_name?: string | null;
};

export type Collaborator = {
    /**
     * The unique user or group identifier for the collaborator.
     */
    id: number;
    /**
     * The name of the collaborator.
     */
    name?: string | null;
    /**
     * The type of collaborator (e.g. 'user' or 'group').
     */
    type?: string | null;
};

/**
 * ColumnDatum objects contain the entry for a column for each user.
 */
export type ColumnDatum = {
    content?: string | null;
    user_id?: number | null;
};

export type CommMessage = {
    /**
     * The plain text body of the message
     */
    body?: string | null;
    /**
     * The date and time this message was created
     */
    created_at?: string | null;
    /**
     * The address that was put in the 'from' field of the message
     */
    from?: string | null;
    /**
     * The display name for the from address
     */
    from_name?: string | null;
    /**
     * The HTML body of the message.
     */
    html_body?: string | null;
    /**
     * The ID of the CommMessage.
     */
    id?: number;
    /**
     * The reply_to header of the message
     */
    reply_to?: string | null;
    /**
     * The date and time this message was sent
     */
    sent_at?: string | null;
    /**
     * The message subject
     */
    subject?: string | null;
    /**
     * The address the message was sent to:
     */
    to?: string | null;
    /**
     * The workflow state of the message. One of 'created', 'staged', 'sending', 'sent', 'bounced', 'dashboard', 'cancelled', or 'closed'
     */
    workflow_state?: string | null;
};

export type CommunicationChannel = {
    /**
     * The address, or path, of the communication channel.
     */
    address?: string | null;
    /**
     * The ID of the communication channel.
     */
    id?: number;
    /**
     * The position of this communication channel relative to the user's other channels when they are ordered.
     */
    position?: number | null;
    /**
     * The type of communcation channel being described. Possible values are: 'email', 'push', 'sms', or 'twitter'. This field determines the type of value seen in 'address'.
     */
    type?: string | null;
    /**
     * The ID of the user that owns this communication channel.
     */
    user_id?: number | null;
    /**
     * The current state of the communication channel. Possible values are: 'unconfirmed' or 'active'.
     */
    workflow_state?: string | null;
};

export type CompletionRequirement = {
    /**
     * whether the calling user has met this requirement (Optional; present only if the caller is a student or if the optional parameter 'student_id' is included)
     */
    completed?: boolean | null;
    /**
     * minimum score required to complete (only present when type == 'min_score')
     */
    min_score?: number | null;
    /**
     * one of 'must_view', 'must_submit', 'must_contribute', 'min_score'
     */
    type?: string | null;
} | null;

export type Conference = {
    /**
     * The 3rd party's ID for the conference
     */
    conference_key?: string | null;
    /**
     * The type of conference
     */
    conference_type?: string | null;
    /**
     * The description for the conference
     */
    description?: string | null;
    /**
     * The expected duration the conference is supposed to last
     */
    duration?: number | null;
    /**
     * The date that the conference ended at, null if it hasn't ended
     */
    ended_at?: string | null;
    /**
     * True if the conference type has advanced settings.
     */
    has_advanced_settings?: boolean | null;
    /**
     * The id of the conference
     */
    id?: number;
    /**
     * URL to join the conference, may be null if the conference type doesn't set it
     */
    join_url?: string | null;
    /**
     * If true the conference is long running and has no expected end time
     */
    long_running?: boolean | null;
    /**
     * A List of recordings for the conference
     */
    recordings?: Array<ConferenceRecording> | null;
    /**
     * The date the conference started at, null if it hasn't started
     */
    started_at?: string | null;
    /**
     * The title of the conference
     */
    title?: string | null;
    /**
     * URL for the conference, may be null if the conference type doesn't set it
     */
    url?: string | null;
    /**
     * A collection of settings specific to the conference type
     */
    user_settings?: {
        [key: string]: unknown;
    } | null;
    /**
     * Array of user ids that are participants in the conference
     */
    users?: Array<number> | null;
};

export type ConferenceRecording = {
    created_at?: string | null;
    duration_minutes?: number | null;
    playback_url?: string | null;
    title?: string | null;
    updated_at?: string | null;
};

export type ContentDetails = {
    due_at?: string | null;
    lock_at?: string | null;
    lock_explanation?: string | null;
    lock_info?: LockInfo;
    locked_for_user?: boolean | null;
    points_possible?: number | null;
    unlock_at?: string | null;
} | null;

export type ContentExport = {
    attachment?: FileNullable;
    /**
     * the date and time this export was requested
     */
    created_at?: string | null;
    /**
     * the type of content migration: 'common_cartridge' or 'qti'
     */
    export_type?: string | null;
    /**
     * the unique identifier for the export
     */
    id?: number;
    /**
     * The api endpoint for polling the current progress
     */
    progress_url?: string | null;
    /**
     * The ID of the user who started the export
     */
    user_id?: number | null;
    /**
     * Current state of the content migration: created exporting exported failed
     */
    workflow_state?: string | null;
};

export type ContentMigration = {
    /**
     * attachment api object for the uploaded file may not be present for all migrations
     */
    attachment?: string | null;
    /**
     * timestamp
     */
    finished_at?: string | null;
    /**
     * the unique identifier for the migration
     */
    id?: number;
    /**
     * API url to the content migration's issues
     */
    migration_issues_url?: string | null;
    /**
     * the type of content migration
     */
    migration_type?: string | null;
    /**
     * the name of the content migration type
     */
    migration_type_title?: string | null;
    /**
     * file uploading data, see {file:file_uploads.html File Upload Documentation} for file upload workflow This works a little differently in that all the file data is in the pre_attachment hash if there is no upload_url then there was an attachment pre-processing error, the error message will be in the message key This data will only be here after a create or update call
     */
    pre_attachment?: string | null;
    /**
     * The api endpoint for polling the current progress
     */
    progress_url?: string | null;
    /**
     * timestamp
     */
    started_at?: string | null;
    /**
     * The user who started the migration
     */
    user_id?: number | null;
    /**
     * Current state of the content migration: pre_processing, pre_processed, running, waiting_for_select, completed, failed
     */
    workflow_state?: string | null;
};

export type ContextExternalTool = {
    /**
     * The consumer key used by the tool (The associated shared secret is not returned)
     */
    consumer_key?: string | null;
    /**
     * The domain to match links against
     */
    domain?: string | null;
    /**
     * The unique identifier for the tool
     */
    id?: number;
    /**
     * The name of the tool
     */
    name?: string | null;
    /**
     * The url to match links against
     */
    url?: string | null;
};

export type Conversation = {
    /**
     * Array of user ids who are involved in the conversation, ordered by participation level, then alphabetical. Excludes current user, unless this is a monologue.
     */
    audience?: Array<number> | null;
    /**
     * Most relevant shared contexts (courses and groups) between current user and other participants. If there is only one participant, it will also include that user's enrollment(s)/ membership type(s) in each course/group.
     */
    audience_contexts?: Array<string> | null;
    /**
     * URL to appropriate icon for this conversation (custom, individual or group avatar, depending on audience).
     */
    avatar_url?: string | null;
    /**
     * Name of the course or group in which the conversation is occurring.
     */
    context_name?: string | null;
    /**
     * the unique identifier for the conversation.
     */
    id?: number;
    /**
     * A <=100 character preview from the most recent message.
     */
    last_message?: string | null;
    /**
     * the number of messages in the conversation.
     */
    message_count?: number | null;
    /**
     * Array of users participating in the conversation. Includes current user.
     */
    participants?: Array<ConversationParticipant> | null;
    /**
     * whether the conversation is private.
     */
    private?: boolean | null;
    /**
     * Additional conversation flags (last_author, attachments, media_objects). Each listed property means the flag is set to true (i.e. the current user is the most recent author, there are attachments, or there are media objects)
     */
    properties?: Array<string> | null;
    /**
     * whether the conversation is starred.
     */
    starred?: boolean | null;
    /**
     * the date and time at which the last message was sent.
     */
    start_at?: string | null;
    /**
     * the subject of the conversation.
     */
    subject?: string | null;
    /**
     * whether the current user is subscribed to the conversation.
     */
    subscribed?: boolean | null;
    /**
     * indicates whether the conversation is visible under the current scope and filter. This attribute is always true in the index API response, and is primarily useful in create/update responses so that you can know if the record should be displayed in the UI. The default scope is assumed, unless a scope or filter is passed to the create/update API call.
     */
    visible?: boolean | null;
    /**
     * The current state of the conversation (read, unread or archived).
     */
    workflow_state?: string | null;
};

export type ConversationParticipant = {
    /**
     * If requested, this field will be included and contain a url to retrieve the user's avatar.
     */
    avatar_url?: string | null;
    /**
     * The full name of the user.
     */
    full_name?: string | null;
    /**
     * The user ID for the participant.
     */
    id?: number;
    /**
     * A short name the user has selected, for use in conversations or other less formal places through the site.
     */
    name?: string | null;
};

export type Course = {
    /**
     * optional: this will be true if this user is currently prevented from viewing the course because of date restriction settings
     */
    access_restricted_by_date?: boolean | null;
    /**
     * the account associated with the course
     */
    account_id?: number | null;
    allow_student_assignment_edits?: boolean | null;
    allow_student_forum_attachments?: boolean | null;
    allow_wiki_comments?: boolean | null;
    /**
     * weight final grade based on assignment group percentages
     */
    apply_assignment_group_weights?: boolean | null;
    /**
     * optional: whether the course is set as a Blueprint Course (blueprint fields require the Blueprint Courses feature)
     */
    blueprint?: boolean | null;
    /**
     * optional: Set of restrictions applied to all locked course objects
     */
    blueprint_restrictions?: {
        [key: string]: unknown;
    } | null;
    /**
     * optional: Sets of restrictions differentiated by object type applied to locked course objects
     */
    blueprint_restrictions_by_object_type?: {
        [key: string]: unknown;
    } | null;
    calendar?: CalendarLink;
    /**
     * the course code
     */
    course_code?: string | null;
    /**
     * Not specified in Canvas API spec, I'm just guessing the type here
     */
    course_color?: string | null;
    course_format?: string | null;
    course_progress?: CourseProgress;
    /**
     * the date the course was created.
     */
    created_at?: string | null;
    /**
     * the type of page that users will see when they first visit the course - 'feed': Recent Activity Dashboard - 'wiki': Wiki Front Page - 'modules': Course Modules/Sections Page - 'assignments': Course Assignments List - 'syllabus': Course Syllabus Page other types may be added in the future
     */
    default_view?: string | null;
    /**
     * the end date for the course, if applicable
     */
    end_at?: string | null;
    /**
     * the enrollment term associated with the course
     */
    enrollment_term_id?: number | null;
    /**
     * A list of enrollments linking the current user to the course. for student enrollments, grading information may be included if include[]=total_scores
     */
    enrollments?: Array<Enrollment> | null;
    /**
     * Not specified in Canvas API spec, I'm just guessing the type here
     */
    friendly_name?: string | null;
    /**
     * The grade_passback_setting on this course
     */
    grade_passback_setting?: string | null;
    /**
     * A list of grading periods associated with the course
     */
    grading_periods?: Array<GradingPeriod> | null;
    /**
     * the grading standard associated with the course
     */
    grading_standard_id?: number | null;
    hide_final_grades?: boolean | null;
    homeroom_course?: boolean | null;
    /**
     * the unique identifier for the course
     */
    id?: number;
    /**
     * the integration identifier for the course, if defined. This field is only included if the user has permission to view SIS information.
     */
    integration_id?: string | null;
    is_public?: boolean | null;
    is_public_to_auth_users?: boolean | null;
    license?: string | null;
    /**
     * the course-set locale, if applicable
     */
    locale?: string | null;
    /**
     * the full name of the course
     */
    name?: string | null;
    /**
     * optional: the number of submissions needing grading returned only if the current user has grading rights and include[]=needs_grading_count
     */
    needs_grading_count?: number | null;
    open_enrollment?: boolean | null;
    original_name?: string | null;
    /**
     * optional: the permissions the user has for the course. returned only for a single course and include[]=permissions
     */
    permissions?: {
        [key: string]: unknown;
    } | null;
    /**
     * optional: the public description of the course
     */
    public_description?: string | null;
    public_syllabus?: boolean | null;
    public_syllabus_to_auth?: boolean | null;
    restrict_enrollments_to_course_dates?: boolean | null;
    /**
     * the root account associated with the course
     */
    root_account_id?: number | null;
    self_enrollment?: boolean | null;
    /**
     * the SIS identifier for the course, if defined. This field is only included if the user has permission to view SIS information.
     */
    sis_course_id?: string | null;
    /**
     * the unique identifier for the SIS import. This field is only included if the user has permission to manage SIS information.
     */
    sis_import_id?: number | null;
    /**
     * the start date for the course, if applicable
     */
    start_at?: string | null;
    storage_quota_mb?: number | null;
    storage_quota_used_mb?: number | null;
    /**
     * optional: user-generated HTML for the course syllabus
     */
    syllabus_body?: string | null;
    /**
     * optional: whether the course is set as a template (requires the course templates feature)
     */
    template?: boolean | null;
    term?: Term;
    /**
     * The course's IANA time zone name.
     */
    time_zone?: string | null;
    /**
     * optional: the total number of active and invited students in the course
     */
    total_students?: number | null;
    /**
     * the UUID of the course
     */
    uuid?: string | null;
    /**
     * the current state of the course one of 'unpublished', 'available', 'completed', or 'deleted'
     */
    workflow_state?: string | null;
};

export type CourseWithIncludes = {
    /**
     * optional: this will be true if this user is currently prevented from viewing the course because of date restriction settings
     */
    access_restricted_by_date?: boolean | null;
    /**
     * the account associated with the course
     */
    account_id?: number | null;
    allow_student_assignment_edits?: boolean | null;
    allow_student_forum_attachments?: boolean | null;
    allow_wiki_comments?: boolean | null;
    /**
     * weight final grade based on assignment group percentages
     */
    apply_assignment_group_weights?: boolean | null;
    /**
     * optional: whether the course is set as a Blueprint Course (blueprint fields require the Blueprint Courses feature)
     */
    blueprint?: boolean | null;
    /**
     * optional: Set of restrictions applied to all locked course objects
     */
    blueprint_restrictions?: {
        [key: string]: unknown;
    } | null;
    /**
     * optional: Sets of restrictions differentiated by object type applied to locked course objects
     */
    blueprint_restrictions_by_object_type?: {
        [key: string]: unknown;
    } | null;
    calendar?: CalendarLink;
    /**
     * the course code
     */
    course_code?: string | null;
    /**
     * Not specified in Canvas API spec, I'm just guessing the type here
     */
    course_color?: string | null;
    course_format?: string | null;
    course_progress?: CourseProgress;
    /**
     * the date the course was created.
     */
    created_at?: string | null;
    /**
     * the type of page that users will see when they first visit the course - 'feed': Recent Activity Dashboard - 'wiki': Wiki Front Page - 'modules': Course Modules/Sections Page - 'assignments': Course Assignments List - 'syllabus': Course Syllabus Page other types may be added in the future
     */
    default_view?: string | null;
    /**
     * the end date for the course, if applicable
     */
    end_at?: string | null;
    /**
     * the enrollment term associated with the course
     */
    enrollment_term_id?: number | null;
    /**
     * A list of enrollments linking the current user to the course. for student enrollments, grading information may be included if include[]=total_scores
     */
    enrollments?: Array<Enrollment> | null;
    /**
     * Not specified in Canvas API spec, I'm just guessing the type here
     */
    friendly_name?: string | null;
    /**
     * The grade_passback_setting on this course
     */
    grade_passback_setting?: string | null;
    /**
     * A list of grading periods associated with the course
     */
    grading_periods?: Array<GradingPeriod> | null;
    /**
     * the grading standard associated with the course
     */
    grading_standard_id?: number | null;
    hide_final_grades?: boolean | null;
    homeroom_course?: boolean | null;
    /**
     * the unique identifier for the course
     */
    id?: number;
    /**
     * the integration identifier for the course, if defined. This field is only included if the user has permission to view SIS information.
     */
    integration_id?: string | null;
    is_public?: boolean | null;
    is_public_to_auth_users?: boolean | null;
    license?: string | null;
    /**
     * the course-set locale, if applicable
     */
    locale?: string | null;
    /**
     * the full name of the course
     */
    name?: string | null;
    /**
     * optional: the number of submissions needing grading returned only if the current user has grading rights and include[]=needs_grading_count
     */
    needs_grading_count?: number | null;
    open_enrollment?: boolean | null;
    original_name?: string | null;
    /**
     * optional: the permissions the user has for the course. returned only for a single course and include[]=permissions
     */
    permissions?: {
        [key: string]: unknown;
    } | null;
    /**
     * optional: the public description of the course
     */
    public_description?: string | null;
    public_syllabus?: boolean | null;
    public_syllabus_to_auth?: boolean | null;
    restrict_enrollments_to_course_dates?: boolean | null;
    /**
     * the root account associated with the course
     */
    root_account_id?: number | null;
    /**
     * A list of sections for this course.
     */
    sections?: Array<Section> | null;
    self_enrollment?: boolean | null;
    /**
     * the SIS identifier for the course, if defined. This field is only included if the user has permission to view SIS information.
     */
    sis_course_id?: string | null;
    /**
     * the unique identifier for the SIS import. This field is only included if the user has permission to manage SIS information.
     */
    sis_import_id?: number | null;
    /**
     * the start date for the course, if applicable
     */
    start_at?: string | null;
    storage_quota_mb?: number | null;
    storage_quota_used_mb?: number | null;
    /**
     * optional: user-generated HTML for the course syllabus
     */
    syllabus_body?: string | null;
    /**
     * optional: whether the course is set as a template (requires the course templates feature)
     */
    template?: boolean | null;
    term?: Term;
    /**
     * The course's IANA time zone name.
     */
    time_zone?: string | null;
    /**
     * optional: the total number of active and invited students in the course
     */
    total_students?: number | null;
    /**
     * the UUID of the course
     */
    uuid?: string | null;
    /**
     * the current state of the course one of 'unpublished', 'available', 'completed', or 'deleted'
     */
    workflow_state?: string | null;
};

/**
 * Combination of a Course & EpubExport.
 */
export type CourseEpubExport = {
    epub_export?: EpubExportNullable;
    /**
     * the unique identifier for the course
     */
    id?: number;
    /**
     * the name for the course
     */
    name?: string | null;
};

export type CourseEvent = {
    /**
     * timestamp of the event
     */
    created_at?: string | null;
    /**
     * Course event data depending on the event type.  This will return an object containing the relevant event data.  An updated event type will return an UpdatedEventData object.
     */
    event_data?: string | null;
    /**
     * Course event source depending on the event type.  This will return a string containing the source of the event.
     */
    event_source?: string | null;
    /**
     * Course event type The event type defines the type and schema of the event_data object.
     */
    event_type?: string | null;
    /**
     * ID of the event.
     */
    id?: string;
    links?: CourseEventLink;
};

export type CourseEventLink = {
    /**
     * ID of the course that this course was copied from. This is only included if the event_type is copied_from.
     */
    copied_from?: number | null;
    /**
     * ID of the course that this course was copied to. This is only included if the event_type is copied_to.
     */
    copied_to?: number | null;
    /**
     * ID of the course for the event.
     */
    course?: number | null;
    /**
     * ID of the page view during the event if it exists.
     */
    page_view?: string | null;
    /**
     * ID of the SIS batch that triggered the event.
     */
    sis_batch?: number | null;
    /**
     * ID of the user for the event (who made the change).
     */
    user?: number | null;
} | null;

export type CourseNickname = {
    /**
     * the ID of the course
     */
    course_id?: number | null;
    /**
     * the actual name of the course
     */
    name?: string | null;
    /**
     * the calling user's nickname for the course
     */
    nickname?: string | null;
};

export type CourseProgress = {
    /**
     * date the course was completed. null if the course has not been completed by this user
     */
    completed_at?: string | null;
    /**
     * url to next module item that has an unmet requirement. null if the user has completed the course or the current module does not require sequential progress
     */
    next_requirement_url?: string | null;
    /**
     * total number of requirements the user has completed from all modules
     */
    requirement_completed_count?: number | null;
    /**
     * total number of requirements from all modules
     */
    requirement_count?: number | null;
} | null;

export type CustomColors = {
    custom_colors?: {
        [key: string]: string;
    } | null;
};

export type CustomColumn = {
    /**
     * won't be displayed if hidden is true
     */
    hidden?: boolean | null;
    /**
     * The ID of the custom gradebook column
     */
    id?: number;
    /**
     * column order
     */
    position?: number | null;
    /**
     * won't be editable in the gradebook UI
     */
    read_only?: boolean | null;
    /**
     * When true, this column's visibility will be toggled in the Gradebook when a user selects to show or hide notes
     */
    teacher_notes?: boolean | null;
    /**
     * header text
     */
    title?: string | null;
};

export type Day = {
    /**
     * the date represented by this entry
     */
    date?: string | null;
    /**
     * an array of the graders who were responsible for the submissions in this response. the submissions are grouped according to the person who graded them and the assignment they were submitted for.
     */
    graders?: number | null;
};

/**
 * A discussion topic
 */
export type DiscussionTopic = {
    /**
     * Whether or not users can rate entries in this topic.
     */
    allow_rating?: boolean | null;
    /**
     * The unique identifier of the assignment if the topic is for grading, otherwise null.
     */
    assignment_id?: number | null;
    /**
     * Array of file attachments.
     */
    attachments?: Array<FileAttachment> | null;
    /**
     * The datetime to publish the topic (if not right away).
     */
    delayed_post_at?: string | null;
    /**
     * The count of entries in the topic.
     */
    discussion_subentry_count?: number | null;
    /**
     * The type of discussion. Values are 'side_comment', for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
     */
    discussion_type?: string | null;
    /**
     * The unique identifier of the group category if the topic is a group discussion, otherwise null.
     */
    group_category_id?: number | null;
    /**
     * An array of group discussions the user is a part of. Fields include: id, group_id
     */
    group_topic_children?: Array<{
        [key: string]: unknown;
    }> | null;
    /**
     * The URL to the discussion topic in canvas.
     */
    html_url?: string | null;
    /**
     * The ID of this topic.
     */
    id?: number;
    /**
     * The datetime for when the last reply was in the topic.
     */
    last_reply_at?: string | null;
    /**
     * The datetime to lock the topic (if ever).
     */
    lock_at?: string | null;
    /**
     * (Optional) An explanation of why this is locked for the user. Present when locked_for_user is true.
     */
    lock_explanation?: string | null;
    lock_info?: LockInfo;
    /**
     * Whether or not the discussion is 'closed for comments'.
     */
    locked?: boolean | null;
    /**
     * Whether or not this is locked for the user.
     */
    locked_for_user?: boolean | null;
    /**
     * The HTML content of the message body.
     */
    message?: string | null;
    /**
     * Whether or not grade permissions are required to rate entries.
     */
    only_graders_can_rate?: boolean | null;
    /**
     * The current user's permissions on this topic.
     */
    permissions?: {
        [key: string]: unknown;
    } | null;
    /**
     * Whether or not the discussion has been 'pinned' by an instructor
     */
    pinned?: boolean | null;
    /**
     * If the topic is a podcast topic this is the feed url for the current user.
     */
    podcast_url?: string | null;
    /**
     * The datetime the topic was posted. If it is null it hasn't been posted yet. (see delayed_post_at)
     */
    posted_at?: string | null;
    /**
     * Whether this discussion topic is published (true) or draft state (false)
     */
    published?: boolean | null;
    /**
     * The read_state of the topic for the current user, 'read' or 'unread'.
     */
    read_state?: string | null;
    /**
     * If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
     */
    require_initial_post?: boolean | null;
    /**
     * If the topic is for grading and a group assignment this will point to the original topic in the course.
     */
    root_topic_id?: number | null;
    /**
     * Whether or not entries should be sorted by rating.
     */
    sort_by_rating?: boolean | null;
    /**
     * Whether or not the current user is subscribed to this topic.
     */
    subscribed?: boolean | null;
    /**
     * (Optional) Why the user cannot subscribe to this topic. Only one reason will be returned even if multiple apply. Can be one of: 'initial_post_required': The user must post a reply first; 'not_in_group_set': The user is not in the group set for this graded group discussion; 'not_in_group': The user is not in this topic's group; 'topic_is_announcement': This topic is an announcement
     */
    subscription_hold?: string | null;
    /**
     * The topic title.
     */
    title?: string | null;
    /**
     * DEPRECATED An array of topic_ids for the group discussions the user is a part of.
     */
    topic_children?: Array<number> | null;
    /**
     * The count of unread entries of this topic for the current user.
     */
    unread_count?: number | null;
    /**
     * Whether or not posts in this topic are visible to the user.
     */
    user_can_see_posts?: boolean | null;
    /**
     * The username of the topic creator.
     */
    user_name?: string | null;
};

/**
 * A discussion topic
 */
export type DiscussionTopicNullable = {
    /**
     * Whether or not users can rate entries in this topic.
     */
    allow_rating?: boolean | null;
    /**
     * The unique identifier of the assignment if the topic is for grading, otherwise null.
     */
    assignment_id?: number | null;
    /**
     * Array of file attachments.
     */
    attachments?: Array<FileAttachment> | null;
    /**
     * The datetime to publish the topic (if not right away).
     */
    delayed_post_at?: string | null;
    /**
     * The count of entries in the topic.
     */
    discussion_subentry_count?: number | null;
    /**
     * The type of discussion. Values are 'side_comment', for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
     */
    discussion_type?: string | null;
    /**
     * The unique identifier of the group category if the topic is a group discussion, otherwise null.
     */
    group_category_id?: number | null;
    /**
     * An array of group discussions the user is a part of. Fields include: id, group_id
     */
    group_topic_children?: Array<{
        [key: string]: unknown;
    }> | null;
    /**
     * The URL to the discussion topic in canvas.
     */
    html_url?: string | null;
    /**
     * The ID of this topic.
     */
    id?: number;
    /**
     * The datetime for when the last reply was in the topic.
     */
    last_reply_at?: string | null;
    /**
     * The datetime to lock the topic (if ever).
     */
    lock_at?: string | null;
    /**
     * (Optional) An explanation of why this is locked for the user. Present when locked_for_user is true.
     */
    lock_explanation?: string | null;
    lock_info?: LockInfo;
    /**
     * Whether or not the discussion is 'closed for comments'.
     */
    locked?: boolean | null;
    /**
     * Whether or not this is locked for the user.
     */
    locked_for_user?: boolean | null;
    /**
     * The HTML content of the message body.
     */
    message?: string | null;
    /**
     * Whether or not grade permissions are required to rate entries.
     */
    only_graders_can_rate?: boolean | null;
    /**
     * The current user's permissions on this topic.
     */
    permissions?: {
        [key: string]: unknown;
    } | null;
    /**
     * Whether or not the discussion has been 'pinned' by an instructor
     */
    pinned?: boolean | null;
    /**
     * If the topic is a podcast topic this is the feed url for the current user.
     */
    podcast_url?: string | null;
    /**
     * The datetime the topic was posted. If it is null it hasn't been posted yet. (see delayed_post_at)
     */
    posted_at?: string | null;
    /**
     * Whether this discussion topic is published (true) or draft state (false)
     */
    published?: boolean | null;
    /**
     * The read_state of the topic for the current user, 'read' or 'unread'.
     */
    read_state?: string | null;
    /**
     * If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
     */
    require_initial_post?: boolean | null;
    /**
     * If the topic is for grading and a group assignment this will point to the original topic in the course.
     */
    root_topic_id?: number | null;
    /**
     * Whether or not entries should be sorted by rating.
     */
    sort_by_rating?: boolean | null;
    /**
     * Whether or not the current user is subscribed to this topic.
     */
    subscribed?: boolean | null;
    /**
     * (Optional) Why the user cannot subscribe to this topic. Only one reason will be returned even if multiple apply. Can be one of: 'initial_post_required': The user must post a reply first; 'not_in_group_set': The user is not in the group set for this graded group discussion; 'not_in_group': The user is not in this topic's group; 'topic_is_announcement': This topic is an announcement
     */
    subscription_hold?: string | null;
    /**
     * The topic title.
     */
    title?: string | null;
    /**
     * DEPRECATED An array of topic_ids for the group discussions the user is a part of.
     */
    topic_children?: Array<number> | null;
    /**
     * The count of unread entries of this topic for the current user.
     */
    unread_count?: number | null;
    /**
     * Whether or not posts in this topic are visible to the user.
     */
    user_can_see_posts?: boolean | null;
    /**
     * The username of the topic creator.
     */
    user_name?: string | null;
} | null;

export type Enrollment = {
    /**
     * The unique id of the associated user. Will be null unless type is ObserverEnrollment.
     */
    associated_user_id?: number | null;
    /**
     * optional: The letter grade equivalent of computed_current_score, if available. (applies only to student enrollments, and only available in course endpoints)
     */
    computed_current_grade?: string | null;
    /**
     * optional: The student's score in the course, ignoring ungraded assignments. (applies only to student enrollments, and only available in course endpoints)
     */
    computed_current_score?: number | null;
    /**
     * optional: The letter grade equivalent of computed_final_score, if available. (applies only to student enrollments, and only available in course endpoints)
     */
    computed_final_grade?: string | null;
    /**
     * optional: The student's score in the course including ungraded assignments with a score of 0. (applies only to student enrollments, and only available in course endpoints)
     */
    computed_final_score?: number | null;
    /**
     * The unique id of the course.
     */
    course_id?: number | null;
    /**
     * The Course Integration ID in which the enrollment is associated. This field is only included if the user has permission to view SIS information.
     */
    course_integration_id?: string | null;
    /**
     * The unique id of the user's section.
     */
    course_section_id?: number | null;
    /**
     * The created time of the enrollment, in ISO8601 format.
     */
    created_at?: string | null;
    /**
     * optional: The id of the currently active grading period, if one exists. If the course the enrollment belongs to does not have grading periods, or if no currently active grading period exists, the value will be null. (applies only to student enrollments, and only available in course endpoints)
     */
    current_grading_period_id?: number | null;
    /**
     * optional: The name of the currently active grading period, if one exists. If the course the enrollment belongs to does not have grading periods, or if no currently active grading period exists, the value will be null. (applies only to student enrollments, and only available in course endpoints)
     */
    current_grading_period_title?: string | null;
    /**
     * optional: The letter grade equivalent of current_period_computed_current_score, if available. If the course the enrollment belongs to does not have grading periods, or if no currently active grading period exists, the value will be null. (applies only to student enrollments, and only available in course endpoints)
     */
    current_period_computed_current_grade?: string | null;
    /**
     * optional: The student's score in the course for the current grading period, ignoring ungraded assignments. If the course the enrollment belongs to does not have grading periods, or if no currently active grading period exists, the value will be null. (applies only to student enrollments, and only available in course endpoints)
     */
    current_period_computed_current_score?: number | null;
    /**
     * optional: The letter grade equivalent of current_period_computed_final_score, if available. If the course the enrollment belongs to does not have grading periods, or if no currently active grading period exists, the value will be null. (applies only to student enrollments, and only available in course endpoints)
     */
    current_period_computed_final_grade?: string | null;
    /**
     * optional: The student's score in the course for the current grading period, including ungraded assignments with a score of 0. If the course the enrollment belongs to does not have grading periods, or if no currently active grading period exists, the value will be null. (applies only to student enrollments, and only available in course endpoints)
     */
    current_period_computed_final_score?: number | null;
    /**
     * The user's override grade for the current grading period.
     */
    current_period_override_grade?: string | null;
    /**
     * The user's override score for the current grading period.
     */
    current_period_override_score?: number | null;
    /**
     * optional: The letter grade equivalent of current_period_unposted_current_score, if available. Only included if user has permission to view this grade, typically teachers, TAs, and admins. If the course the enrollment belongs to does not have grading periods, or if no currently active grading period exists, the value will be null. (applies only to student enrollments, and only available in course endpoints)
     */
    current_period_unposted_current_grade?: string | null;
    /**
     * optional: The student's score in the course for the current grading period, including muted/unposted assignments. Only included if user has permission to view this score, typically teachers, TAs, and admins. If the course the enrollment belongs to does not have grading periods, or if no currently active grading period exists, the value will be null. (applies only to student enrollments, and only available in course endpoints)
     */
    current_period_unposted_current_score?: number | null;
    /**
     * optional: The letter grade equivalent of current_period_unposted_final_score, if available. Only included if user has permission to view this grade, typically teachers, TAs, and admins. If the course the enrollment belongs to does not have grading periods, or if no currently active grading period exists, the value will be null. (applies only to student enrollments, and only available in course endpoints)
     */
    current_period_unposted_final_grade?: string | null;
    /**
     * optional: The student's score in the course for the current grading period, including muted/unposted assignments and including ungraded assignments with a score of 0. Only included if user has permission to view this score, typically teachers, TAs, and admins. If the course the enrollment belongs to does not have grading periods, or if no currently active grading period exists, the value will be null. (applies only to student enrollments, and only available in course endpoints)
     */
    current_period_unposted_final_score?: number | null;
    /**
     * The end time of the enrollment, in ISO8601 format.
     */
    end_at?: string | null;
    /**
     * The state of the user's enrollment in the course.
     */
    enrollment_state?: string | null;
    grades?: Grade;
    /**
     * optional: Indicates whether the course the enrollment belongs to has grading periods set up. (applies only to student enrollments, and only available in course endpoints)
     */
    has_grading_periods?: boolean | null;
    /**
     * The URL to the Canvas web UI page for this course enrollment.
     */
    html_url?: string | null;
    /**
     * The ID of the enrollment.
     */
    id?: number;
    /**
     * The last activity time of the user for the enrollment, in ISO8601 format.
     */
    last_activity_at?: string | null;
    /**
     * The last attended date of the user for the enrollment in a course, in ISO8601 format.
     */
    last_attended_at?: string | null;
    /**
     * User can only access his or her own course section.
     */
    limit_privileges_to_course_section?: boolean | null;
    /**
     * The user's override grade for the course.
     */
    override_grade?: string | null;
    /**
     * The user's override score for the course.
     */
    override_score?: number | null;
    /**
     * The enrollment role, for course-level permissions. This field will match `type` if the enrollment role has not been customized.
     */
    role?: string | null;
    /**
     * The id of the enrollment role.
     */
    role_id?: number | null;
    /**
     * The unique id of the user's account.
     */
    root_account_id?: number | null;
    /**
     * The Section Integration ID in which the enrollment is associated. This field is only included if the user has permission to view SIS information.
     */
    section_integration_id?: string | null;
    /**
     * The SIS Account ID in which the enrollment is associated. Only displayed if present. This field is only included if the user has permission to view SIS information.
     */
    sis_account_id?: string | null;
    /**
     * The SIS Course ID in which the enrollment is associated. Only displayed if present. This field is only included if the user has permission to view SIS information.
     */
    sis_course_id?: string | null;
    /**
     * The unique identifier for the SIS import. This field is only included if the user has permission to manage SIS information.
     */
    sis_import_id?: number | null;
    /**
     * The SIS Section ID in which the enrollment is associated. Only displayed if present. This field is only included if the user has permission to view SIS information.
     */
    sis_section_id?: string | null;
    /**
     * The SIS User ID in which the enrollment is associated. Only displayed if present. This field is only included if the user has permission to view SIS information.
     */
    sis_user_id?: string | null;
    /**
     * The start time of the enrollment, in ISO8601 format.
     */
    start_at?: string | null;
    /**
     * The total activity time of the user for the enrollment, in seconds.
     */
    total_activity_time?: number | null;
    /**
     * optional: Indicates whether the course the enrollment belongs to has the Display Totals for 'All Grading Periods' feature enabled. (applies only to student enrollments, and only available in course endpoints)
     */
    totals_for_all_grading_periods_option?: boolean | null;
    /**
     * The enrollment type. One of 'StudentEnrollment', 'TeacherEnrollment', 'TaEnrollment', 'DesignerEnrollment', 'ObserverEnrollment'.
     */
    type?: string | null;
    /**
     * The user's current grade in the class including muted/unposted assignments. Only included if user has permissions to view this grade, typically teachers, TAs, and admins.
     */
    unposted_current_grade?: string | null;
    /**
     * The user's current score in the class including muted/unposted assignments. Only included if user has permissions to view this score, typically teachers, TAs, and admins..
     */
    unposted_current_score?: string | null;
    /**
     * The user's final grade for the class including muted/unposted assignments. Only included if user has permissions to view this grade, typically teachers, TAs, and admins..
     */
    unposted_final_grade?: string | null;
    /**
     * The user's final score for the class including muted/unposted assignments. Only included if user has permissions to view this score, typically teachers, TAs, and admins..
     */
    unposted_final_score?: number | null;
    /**
     * The updated time of the enrollment, in ISO8601 format.
     */
    updated_at?: string | null;
    user?: UserNullable;
    /**
     * The unique id of the user.
     */
    user_id?: number | null;
};

export type EnrollmentTerm = {
    /**
     * The datetime of the end of the term.
     */
    end_at?: string | null;
    /**
     * The unique identifier for the enrollment term.
     */
    id?: number;
    /**
     * The name of the term.
     */
    name?: string | null;
    /**
     * Term date overrides for specific enrollment types
     */
    overrides?: {
        [key: string]: unknown;
    } | null;
    /**
     * the unique identifier for the SIS import. This field is only included if the user has permission to manage SIS information.
     */
    sis_import_id?: number | null;
    /**
     * The SIS id of the term. Only included if the user has permission to view SIS information.
     */
    sis_term_id?: string | null;
    /**
     * The datetime of the start of the term.
     */
    start_at?: string | null;
    /**
     * The state of the term. Can be 'active' or 'deleted'.
     */
    workflow_state?: string | null;
};

export type EpubExport = {
    attachment?: FileNullable;
    /**
     * the date and time this export was requested
     */
    created_at?: string | null;
    /**
     * the unique identifier for the export
     */
    id?: number;
    /**
     * The api endpoint for polling the current progress
     */
    progress_url?: string | null;
    /**
     * The ID of the user who started the export
     */
    user_id?: number | null;
    /**
     * Current state of the ePub export: created exporting exported generating generated failed
     */
    workflow_state?: string | null;
};

export type EpubExportNullable = {
    attachment?: FileNullable;
    /**
     * the date and time this export was requested
     */
    created_at?: string | null;
    /**
     * the unique identifier for the export
     */
    id?: number;
    /**
     * The api endpoint for polling the current progress
     */
    progress_url?: string | null;
    /**
     * The ID of the user who started the export
     */
    user_id?: number | null;
    /**
     * Current state of the ePub export: created exporting exported generating generated failed
     */
    workflow_state?: string | null;
} | null;

export type ExternalFeed = {
    /**
     * When this external feed was added to Canvas
     */
    created_at?: string | null;
    /**
     * The title of the feed, pulled from the feed itself. If the feed hasn't yet been pulled, a temporary name will be synthesized based on the URL
     */
    display_name?: string | null;
    /**
     * If not null, only feed entries whose title contains this string will trigger new posts in Canvas
     */
    header_match?: string | null;
    /**
     * The ID of the feed
     */
    id?: number;
    /**
     * The HTTP/HTTPS URL to the feed
     */
    url?: string | null;
    /**
     * The verbosity setting determines how much of the feed's content is imported into Canvas as part of the posting. 'link_only' means that only the title and a link to the item. 'truncate' means that a summary of the first portion of the item body will be used. 'full' means that the full item body will be used.
     */
    verbosity?: string | null;
};

export type ExternalToolTagAttributes = {
    /**
     * Whether or not there is a new tab for the external tool
     */
    new_tab?: boolean | null;
    /**
     * the identifier for this tool_tag
     */
    resource_link_id?: string | null;
    /**
     * URL to the external tool
     */
    url?: string | null;
} | null;

export type Favorite = {
    /**
     * The ID of the object the Favorite refers to
     */
    context_id?: number | null;
    /**
     * The type of the object the Favorite refers to (currently, only 'Course' is supported)
     */
    context_type?: string | null;
};

export type Feature = {
    /**
     * The type of object the feature applies to (RootAccount, Account, Course, or User):
     * * RootAccount features may only be controlled by flags on root accounts.
     * * Account features may be controlled by flags on accounts and their parent accounts.
     * * Course features may be controlled by flags on courses and their parent accounts.
     * * User features may be controlled by flags on users and site admin only.
     */
    applies_to?: string | null;
    /**
     * Whether the details of the feature are autoexpanded on page load vs. the user clicking to expand.
     */
    autoexpand?: boolean | null;
    /**
     * Whether the feature is a beta feature. If true, the feature may not be fully polished and may be subject to change in the future.
     */
    beta?: boolean | null;
    /**
     * Whether the feature is in active development. Features in this state are only visible in test and beta instances and are not yet available for production use.
     */
    development?: boolean | null;
    /**
     * The user-visible name of the feature
     */
    display_name?: string | null;
    /**
     * The date this feature will be globally enabled, or null if this is not planned. (This information is subject to change.)
     */
    enable_at?: string | null;
    feature_flag?: FeatureFlagNullable;
    /**
     * The symbolic name of the feature, used in FeatureFlags
     */
    name?: string | null;
    /**
     * A URL to the release notes describing the feature
     */
    release_notes_url?: string | null;
    /**
     * If true, a feature that is 'allowed' globally will be 'off' by default in root accounts. Otherwise, root accounts inherit the global 'allowed' setting, which allows sub-accounts and courses to turn features on with no root account action.
     */
    root_opt_in?: boolean | null;
};

export type FeatureFlag = {
    /**
     * The id of the object to which this flag applies (This field is not present if this FeatureFlag represents the global Canvas default)
     */
    context_id?: number | null;
    /**
     * The type of object to which this flag applies (Account, Course, or User). (This field is not present if this FeatureFlag represents the global Canvas default)
     */
    context_type?: string | null;
    /**
     * The feature this flag controls
     */
    feature?: string | null;
    /**
     * If set, this feature flag cannot be changed in the caller's context because the flag is set 'off' or 'on' in a higher context
     */
    locked?: boolean | null;
    /**
     * The policy for the feature at this context.  can be 'off', 'allowed', or 'on'.
     */
    state?: string | null;
};

export type FeatureFlagNullable = {
    /**
     * The id of the object to which this flag applies (This field is not present if this FeatureFlag represents the global Canvas default)
     */
    context_id?: number | null;
    /**
     * The type of object to which this flag applies (Account, Course, or User). (This field is not present if this FeatureFlag represents the global Canvas default)
     */
    context_type?: string | null;
    /**
     * The feature this flag controls
     */
    feature?: string | null;
    /**
     * If set, this feature flag cannot be changed in the caller's context because the flag is set 'off' or 'on' in a higher context
     */
    locked?: boolean | null;
    /**
     * The policy for the feature at this context.  can be 'off', 'allowed', or 'on'.
     */
    state?: string | null;
} | null;

/**
 * A mapping of Canvas attribute names to attribute names that a provider may send, in order to update the value of these attributes when a user logs in. The values can be a FederatedAttributeConfig, or a raw string corresponding to the "attribute" property of a FederatedAttributeConfig. In responses, full FederatedAttributeConfig objects are returned if JIT provisioning is enabled, otherwise just the attribute names are returned.
 */
export type FederatedAttributesConfig = {
    /**
     * A comma separated list of role names to grant to the user. Note that these only apply at the root account level, and not sub-accounts. If the attribute is not marked for provisioning only, the user will also be removed from any other roles they currently hold that are not still specified by the IdP.
     */
    admin_roles?: string | null;
    /**
     * The full display name of the user
     */
    display_name?: string | null;
    /**
     * The user's e-mail address
     */
    email?: string | null;
    /**
     * The first, or given, name of the user
     */
    given_name?: string | null;
    /**
     * The secondary unique identifier for SIS purposes
     */
    integration_id?: string | null;
    /**
     * The user's preferred locale/language
     */
    locale?: string | null;
    /**
     * The full name of the user
     */
    name?: string | null;
    /**
     * The unique SIS identifier
     */
    sis_user_id?: string | null;
    /**
     * The full name of the user for sorting purposes
     */
    sortable_name?: string | null;
    /**
     * The surname, or last name, of the user
     */
    surname?: string | null;
    /**
     * The user's preferred time zone
     */
    timezone?: string | null;
} | null;

export type File = {
    'content-type'?: string | null;
    created_at?: string | null;
    display_name?: string | null;
    id?: number;
    size?: number | null;
    updated_at?: string | null;
    url?: string | null;
};

export type FileNullable = {
    'content-type'?: string | null;
    created_at?: string | null;
    display_name?: string | null;
    id?: number;
    size?: number | null;
    updated_at?: string | null;
    url?: string | null;
} | null;

/**
 * A file attachment
 */
export type FileAttachment = {
    'content-type'?: string | null;
    display_name?: string | null;
    filename?: string | null;
    url?: string | null;
};

export type Folder = {
    context_id?: number | null;
    context_type?: string | null;
    created_at?: string | null;
    files_count?: number | null;
    files_url?: string | null;
    folders_count?: number | null;
    folders_url?: string | null;
    /**
     * If true, indicates this is a read-only folder containing files submitted to assignments
     */
    for_submissions?: boolean | null;
    full_name?: string | null;
    hidden?: boolean | null;
    hidden_for_user?: boolean | null;
    id?: number;
    lock_at?: string | null;
    locked?: boolean | null;
    locked_for_user?: boolean | null;
    name?: string | null;
    parent_folder_id?: number | null;
    position?: number | null;
    unlock_at?: string | null;
    updated_at?: string | null;
};

export type Grade = {
    /**
     * The user's current grade in the class. Only included if user has permissions to view this grade.
     */
    current_grade?: string | null;
    /**
     * The user's current score in the class. Only included if user has permissions to view this score.
     */
    current_score?: number | null;
    /**
     * The user's final grade for the class. Only included if user has permissions to view this grade.
     */
    final_grade?: string | null;
    /**
     * The user's final score for the class. Only included if user has permissions to view this score.
     */
    final_score?: number | null;
    /**
     * The URL to the Canvas web UI page for the user's grades, if this is a student enrollment.
     */
    html_url?: string | null;
    /**
     * The user's current grade in the class including muted/unposted assignments. Only included if user has permissions to view this grade, typically teachers, TAs, and admins.
     */
    unposted_current_grade?: string | null;
    /**
     * The user's current score in the class including muted/unposted assignments. Only included if user has permissions to view this score, typically teachers, TAs, and admins..
     */
    unposted_current_score?: number | null;
    /**
     * The user's final grade for the class including muted/unposted assignments. Only included if user has permissions to view this grade, typically teachers, TAs, and admins..
     */
    unposted_final_grade?: string | null;
    /**
     * The user's final score for the class including muted/unposted assignments. Only included if user has permissions to view this score, typically teachers, TAs, and admins..
     */
    unposted_final_score?: number | null;
} | null;

export type GradeChangeEvent = {
    /**
     * timestamp of the event
     */
    created_at?: string | null;
    /**
     * GradeChange event type
     */
    event_type?: string | null;
    /**
     * Boolean indicating whether the submission was excused after the change.
     */
    excused_after?: boolean | null;
    /**
     * Boolean indicating whether the submission was excused before the change.
     */
    excused_before?: boolean | null;
    /**
     * The grade after the change.
     */
    grade_after?: string | null;
    /**
     * The grade before the change.
     */
    grade_before?: string | null;
    /**
     * Boolean indicating whether the student name was visible when the grade was given. Could be null if the grade change record was created before this feature existed.
     */
    graded_anonymously?: boolean | null;
    /**
     * ID of the event.
     */
    id?: string;
    links?: GradeChangeEventLinks;
    /**
     * The unique request id of the request during the grade change.
     */
    request_id?: string | null;
    /**
     * Version Number of the grade change submission.
     */
    version_number?: string | null;
};

export type GradeChangeEventLinks = {
    /**
     * ID of the assignment associated with the event
     */
    assignment?: number | null;
    /**
     * ID of the course associated with the event. will match the context_id in the associated assignment if the context type for the assignment is a course
     */
    course?: number | null;
    /**
     * ID of the grader associated with the event. will match the grader_id in the associated submission.
     */
    grader?: number | null;
    /**
     * ID of the page view during the event if it exists.
     */
    page_view?: string | null;
    /**
     * ID of the student associated with the event. will match the user_id in the associated submission.
     */
    student?: number | null;
} | null;

export type Grader = {
    /**
     * the assignment groups for all submissions in this response that were graded by this user.  The details are not nested inside here, but the fact that an assignment is present here means that the grader did grade submissions for this assignment on the contextual date. You can use the id of a grader and of an assignment to make another API call to find all submissions for a grader/assignment combination on a given date.
     */
    assignments?: Array<number> | null;
    /**
     * the user_id of the user who graded the contained submissions
     */
    id?: number;
    /**
     * the name of the user who graded the contained submissions
     */
    name?: string | null;
};

export type GradingPeriod = {
    /**
     * Grades can only be changed before the close date of the grading period.
     */
    close_date?: string | null;
    /**
     * The end date of the grading period.
     */
    end_date?: string | null;
    /**
     * The unique identifier for the grading period.
     */
    id?: number;
    /**
     * If true, the grading period's close_date has passed.
     */
    is_closed?: boolean | null;
    /**
     * The start date of the grading period.
     */
    start_date?: string | null;
    /**
     * The title for the grading period.
     */
    title?: string | null;
    /**
     * A weight value that contributes to the overall weight of a grading period set which is used to calculate how much assignments in this period contribute to the total grade.
     */
    weight?: number | null;
};

export type GradingRules = {
    /**
     * Number of highest scores to be dropped for each user.
     */
    drop_highest?: number | null;
    /**
     * Number of lowest scores to be dropped for each user.
     */
    drop_lowest?: number | null;
    /**
     * Assignment IDs that should never be dropped.
     */
    never_drop?: Array<number> | null;
} | null;

export type GradingSchemeEntry = {
    /**
     * The name for an entry value within a GradingStandard that describes the range of the value
     */
    name?: string | null;
    /**
     * The value for the name of the entry within a GradingStandard.  The entry represents the lower bound of the range for the entry. This range includes the value up to the next entry in the GradingStandard, or 100 if there is no upper bound. The lowest value will have a lower bound range of 0.
     */
    value?: number | null;
};

export type GradingStandard = {
    /**
     * the id for the context either the Account or Course id
     */
    context_id?: number | null;
    /**
     * the context this standard is associated with, either 'Account' or 'Course'
     */
    context_type?: string | null;
    /**
     * A list of GradingSchemeEntry that make up the Grading Standard as an array of values with the scheme name and value
     */
    grading_scheme?: Array<GradingSchemeEntry> | null;
    /**
     * the id of the grading standard
     */
    id?: number;
    /**
     * the title of the grading standard
     */
    title?: string | null;
};

export type Group = {
    /**
     * The url of the group's avatar
     */
    avatar_url?: string | null;
    /**
     * The course or account that the group belongs to. The pattern here is that whatever the context_type is, there will be an _id field named after that type. So if instead context_type was 'account', the course_id field would be replaced by an account_id field.
     */
    context_type?: string | null;
    course_id?: number | null;
    /**
     * A description of the group. This is plain text.
     */
    description?: string | null;
    /**
     * Whether or not the current user is following this group.
     */
    followed_by_user?: boolean | null;
    /**
     * The ID of the group's category.
     */
    group_category_id?: number | null;
    /**
     * The ID of the group.
     */
    id?: number;
    /**
     * Whether or not the group is public.  Currently only community groups can be made public.  Also, once a group has been set to public, it cannot be changed back to private.
     */
    is_public?: boolean | null;
    /**
     * How people are allowed to join the group.  For all groups except for community groups, the user must share the group's parent course or account.  For student organized or community groups, where a user can be a member of as many or few as they want, the applicable levels are 'parent_context_auto_join', 'parent_context_request', and 'invitation_only'.  For class groups, where students are divided up and should only be part of one group of the category, this value will always be 'invitation_only', and is not relevant. * If 'parent_context_auto_join', anyone can join and will be automatically accepted. * If 'parent_context_request', anyone  can request to join, which must be approved by a group moderator. * If 'invitation_only', only those how have received an invitation my join the group, by accepting that invitation.
     */
    join_level?: string | null;
    /**
     * The number of members currently in the group
     */
    members_count?: number | null;
    /**
     * The display name of the group.
     */
    name?: string | null;
    /**
     * optional: the permissions the user has for the group. returned only for a single group and include[]=permissions
     */
    permissions?: {
        [key: string]: unknown;
    } | null;
    /**
     * Certain types of groups have special role designations. Currently, these include: 'communities', 'student_organized', and 'imported'. Regular course/account groups have a role of null.
     */
    role?: string | null;
    /**
     * The SIS ID of the group. Only included if the user has permission to view SIS information.
     */
    sis_group_id?: string | null;
    /**
     * The id of the SIS import if created through SIS. Only included if the user has permission to manage SIS information.
     */
    sis_import_id?: number | null;
    /**
     * the storage quota for the group, in megabytes
     */
    storage_quota_mb?: number | null;
};

export type GroupCategory = {
    account_id?: number | null;
    /**
     * Gives instructors the ability to automatically have group leaders assigned.  Values include 'random', 'first', and null; 'random' picks a student from the group at random as the leader, 'first' sets the first student to be assigned to the group as the leader
     */
    auto_leader?: string | null;
    /**
     * The course or account that the category group belongs to. The pattern here is that whatever the context_type is, there will be an _id field named after that type. So if instead context_type was 'Course', the course_id field would be replaced by an course_id field.
     */
    context_type?: string | null;
    /**
     * If self-signup is enabled, group_limit can be set to cap the number of users in each group. If null, there is no limit.
     */
    group_limit?: number | null;
    /**
     * The ID of the group category.
     */
    id?: number;
    /**
     * The display name of the group category.
     */
    name?: string | null;
    progress?: ProgressNullable;
    /**
     * Certain types of group categories have special role designations. Currently, these include: 'communities', 'student_organized', and 'imported'. Regular course/account group categories have a role of null.
     */
    role?: string | null;
    /**
     * If the group category allows users to join a group themselves, thought they may only be a member of one group per group category at a time. Values include 'restricted', 'enabled', and null 'enabled' allows students to assign themselves to a group 'restricted' restricts them to only joining a group in their section null disallows students from joining groups
     */
    self_signup?: string | null;
    /**
     * The SIS identifier for the group category. This field is only included if the user has permission to manage or view SIS information.
     */
    sis_group_category_id?: string | null;
    /**
     * The unique identifier for the SIS import. This field is only included if the user has permission to manage SIS information.
     */
    sis_import_id?: number | null;
};

export type GroupMembership = {
    /**
     * The id of the group object to which the membership belongs
     */
    group_id?: number | null;
    /**
     * The id of the membership object
     */
    id?: number;
    /**
     * optional: whether or not the record was just created on a create call (POST), i.e. was the user just added to the group, or was the user already a member
     */
    just_created?: boolean | null;
    /**
     * Whether or not the user is a moderator of the group (the must also be an active member of the group to moderate)
     */
    moderator?: boolean | null;
    /**
     * The id of the SIS import if created through SIS. Only included if the user has permission to manage SIS information.
     */
    sis_import_id?: number | null;
    /**
     * The id of the user object to which the membership belongs
     */
    user_id?: number | null;
    /**
     * The current state of the membership. Current possible values are 'accepted', 'invited', and 'requested'
     */
    workflow_state?: string | null;
};

export type HelpLink = {
    /**
     * The roles that have access to this help link
     */
    available_to?: Array<string> | null;
    /**
     * The ID of the help link
     */
    id?: string;
    /**
     * The description of the help link
     */
    subtext?: string | null;
    /**
     * The name of the help link
     */
    text?: string | null;
    /**
     * The type of the help link
     */
    type?: 'default' | 'custom';
    /**
     * The URL of the help link
     */
    url?: string | null;
};

export type HelpLinks = {
    /**
     * Help links defined by the account. Could include default help links.
     */
    custom_help_links?: Array<HelpLink> | null;
    /**
     * Default help links provided when account has not set help links of their own.
     */
    default_help_links?: Array<HelpLink> | null;
    /**
     * Help link button icon
     */
    help_link_icon?: string | null;
    /**
     * Help link button title
     */
    help_link_name?: string | null;
};

export type Jwt = {
    /**
     * The signed, encrypted, base64 encoded JWT
     */
    token?: string | null;
};

export type License = {
    /**
     * a short string identifying the license
     */
    id?: string;
    /**
     * the name of the license
     */
    name?: string | null;
    /**
     * a link to the license text
     */
    url?: string | null;
};

export type LockInfo = {
    /**
     * Asset string for the object causing the lock
     */
    asset_string?: string | null;
    /**
     * (Optional) Context module causing the lock.
     */
    context_module?: string | null;
    /**
     * (Optional) Time at which this was/will be locked. Must be after the due date.
     */
    lock_at?: string | null;
    manually_locked?: boolean | null;
    /**
     * (Optional) Time at which this was/will be unlocked. Must be before the due date.
     */
    unlock_at?: string | null;
} | null;

/**
 * A Canvas assignment
 */
export type LtiAssignment = {
    course_id?: number | null;
    description?: string | null;
    /**
     * The due date for the assignment. If a user id is supplied and an assignment override is in place this field will reflect the due date as it applies to the user.
     */
    due_at?: string | null;
    id?: number;
    lti_course_id?: string | null;
    lti_id?: string | null;
    name?: string | null;
    points_possible?: number | null;
};

export type MediaComment = {
    'content-type'?: string | null;
    display_name?: string | null;
    media_id?: string | null;
    media_type?: string | null;
    url?: string | null;
} | null;

export type MigrationIssue = {
    /**
     * API url to the content migration
     */
    content_migration_url?: string | null;
    /**
     * timestamp
     */
    created_at?: string | null;
    /**
     * Description of the issue for the end-user
     */
    description?: string | null;
    /**
     * Site administrator error message (If the requesting user has permissions)
     */
    error_message?: string | null;
    /**
     * Link to a Canvas error report if present (If the requesting user has permissions)
     */
    error_report_html_url?: string | null;
    /**
     * HTML Url to the Canvas page to investigate the issue
     */
    fix_issue_html_url?: string | null;
    /**
     * the unique identifier for the issue
     */
    id?: number;
    /**
     * Severity of the issue: todo, warning, error
     */
    issue_type?: string | null;
    /**
     * timestamp
     */
    updated_at?: string | null;
    /**
     * Current state of the issue: active, resolved
     */
    workflow_state?: string | null;
};

export type Migrator = {
    /**
     * Description of the package type expected
     */
    name?: string | null;
    /**
     * A list of fields this system requires
     */
    required_settings?: Array<string> | null;
    /**
     * Whether this endpoint requires a file upload
     */
    requires_file_upload?: boolean | null;
    /**
     * The value to pass to the create endpoint
     */
    type?: string | null;
};

export type Module = {
    /**
     * the date the calling user completed the module (Optional; present only if the caller is a student or if the optional parameter 'student_id' is included)
     */
    completed_at?: string | null;
    /**
     * the unique identifier for the module
     */
    id?: number;
    /**
     * The contents of this module, as an array of Module Items. (Present only if requested via include[]=items AND the module is not deemed too large by Canvas.)
     */
    items?: Array<ModuleItem> | null;
    /**
     * The number of items in the module
     */
    items_count?: number | null;
    /**
     * The API URL to retrive this module's items
     */
    items_url?: string | null;
    /**
     * the name of this module
     */
    name?: string | null;
    /**
     * the position of this module in the course (1-based)
     */
    position?: number | null;
    /**
     * IDs of Modules that must be completed before this one is unlocked
     */
    prerequisite_module_ids?: Array<number> | null;
    /**
     * if the student's final grade for the course should be published to the SIS upon completion of this module
     */
    publish_final_grade?: boolean | null;
    /**
     * (Optional) Whether this module is published. This field is present only if the caller has permission to view unpublished modules.
     */
    published?: boolean | null;
    /**
     * Whether module items must be unlocked in order
     */
    require_sequential_progress?: boolean | null;
    /**
     * The state of this Module for the calling user one of 'locked', 'unlocked', 'started', 'completed' (Optional; present only if the caller is a student or if the optional parameter 'student_id' is included)
     */
    state?: string | null;
    /**
     * (Optional) the date this module will unlock
     */
    unlock_at?: string | null;
    /**
     * the state of the module: 'active', 'deleted'
     */
    workflow_state?: string | null;
};

export type ModuleItem = {
    completion_requirement?: CompletionRequirement;
    content_details?: ContentDetails;
    /**
     * the id of the object referred to applies to 'File', 'Discussion', 'Assignment', 'Quiz', 'ExternalTool' types
     */
    content_id?: number | null;
    /**
     * (only for 'ExternalUrl' and 'ExternalTool' types) external url that the item points to
     */
    external_url?: string | null;
    /**
     * link to the item in Canvas
     */
    html_url?: string | null;
    /**
     * the unique identifier for the module item
     */
    id?: number;
    /**
     * 0-based indent level; module items may be indented to show a hierarchy
     */
    indent?: number | null;
    /**
     * the id of the Module this item appears in
     */
    module_id?: number | null;
    /**
     * (only for 'ExternalTool' type) whether the external tool opens in a new tab
     */
    new_tab?: boolean | null;
    /**
     * (only for 'Page' type) unique locator for the linked wiki page
     */
    page_url?: string | null;
    /**
     * the position of this item in the module (1-based)
     */
    position?: number | null;
    /**
     * (Optional) Whether this module item is published. This field is present only if the caller has permission to view unpublished items.
     */
    published?: boolean | null;
    /**
     * the title of this item
     */
    title?: string | null;
    /**
     * the type of object referred to one of 'File', 'Page', 'Discussion', 'Assignment', 'Quiz', 'SubHeader', 'ExternalUrl', 'ExternalTool'
     */
    type?: string | null;
    /**
     * (Optional) link to the Canvas API object, if applicable
     */
    url?: string | null;
};

export type ModuleItemNullable = {
    completion_requirement?: CompletionRequirement;
    content_details?: ContentDetails;
    /**
     * the id of the object referred to applies to 'File', 'Discussion', 'Assignment', 'Quiz', 'ExternalTool' types
     */
    content_id?: number | null;
    /**
     * (only for 'ExternalUrl' and 'ExternalTool' types) external url that the item points to
     */
    external_url?: string | null;
    /**
     * link to the item in Canvas
     */
    html_url?: string | null;
    /**
     * the unique identifier for the module item
     */
    id?: number;
    /**
     * 0-based indent level; module items may be indented to show a hierarchy
     */
    indent?: number | null;
    /**
     * the id of the Module this item appears in
     */
    module_id?: number | null;
    /**
     * (only for 'ExternalTool' type) whether the external tool opens in a new tab
     */
    new_tab?: boolean | null;
    /**
     * (only for 'Page' type) unique locator for the linked wiki page
     */
    page_url?: string | null;
    /**
     * the position of this item in the module (1-based)
     */
    position?: number | null;
    /**
     * (Optional) Whether this module item is published. This field is present only if the caller has permission to view unpublished items.
     */
    published?: boolean | null;
    /**
     * the title of this item
     */
    title?: string | null;
    /**
     * the type of object referred to one of 'File', 'Page', 'Discussion', 'Assignment', 'Quiz', 'SubHeader', 'ExternalUrl', 'ExternalTool'
     */
    type?: string | null;
    /**
     * (Optional) link to the Canvas API object, if applicable
     */
    url?: string | null;
} | null;

export type ModuleItemSequence = {
    /**
     * an array containing one ModuleItemSequenceNode for each appearence of the asset in the module sequence (up to 10 total)
     */
    items?: Array<ModuleItemSequenceNode> | null;
    /**
     * an array containing each Module referenced above
     */
    modules?: Array<Module> | null;
};

export type ModuleItemSequenceNode = {
    current?: ModuleItemNullable;
    /**
     * The conditional release rule for the module item, if applicable
     */
    mastery_path?: {
        [key: string]: unknown;
    } | null;
    next?: ModuleItemNullable;
    prev?: ModuleItemNullable;
};

/**
 * Used by Assignment model
 */
export type NeedsGradingCount = {
    /**
     * Number of submissions that need grading
     */
    needs_grading_count?: number | null;
    /**
     * The section ID
     */
    section_id?: string | null;
};

export type NotificationPreference = {
    /**
     * The category of that notification
     */
    category?: string | null;
    /**
     * How often to send notifications to this communication channel for the given notification. Possible values are 'immediately', 'daily', 'weekly', and 'never'
     */
    frequency?: string | null;
    href?: string | null;
    /**
     * The notification this preference belongs to
     */
    notification?: string | null;
};

export type OriginalityReport = {
    /**
     * The id of the file receiving the originality score
     */
    file_id?: number | null;
    /**
     * The id of the OriginalityReport
     */
    id?: number;
    /**
     * The ID of the file within Canvas containing the originality report document (if provided)
     */
    originality_report_file_id?: number | null;
    /**
     * A non-LTI launch URL where the originality score of the file may be found.
     */
    originality_report_url?: string | null;
    /**
     * A number between 0 and 100 representing the originality score
     */
    originality_score?: number | null;
    tool_setting?: ToolSetting;
};

export type Outcome = {
    /**
     * whether this outcome has been used to assess a student
     */
    assessed?: boolean | null;
    /**
     * this defines the variable value used by the calculation_method. included only if calculation_method uses it
     */
    calculation_int?: number | null;
    /**
     * the method used to calculate a students score
     */
    calculation_method?: string | null;
    /**
     * whether the current user can update the outcome
     */
    can_edit?: boolean | null;
    /**
     * whether the outcome can be unlinked
     */
    can_unlink?: boolean | null;
    /**
     * the context owning the outcome. may be null for global outcomes
     */
    context_id?: number | null;
    context_type?: string | null;
    /**
     * description of the outcome. omitted in the abbreviated form.
     */
    description?: string | null;
    /**
     * Optional friendly name for reporting
     */
    display_name?: string | null;
    /**
     * whether updates to this outcome will propagate to unassessed rubrics that have imported it
     */
    has_updateable_rubrics?: boolean | null;
    /**
     * the ID of the outcome
     */
    id?: number;
    /**
     * points necessary to demonstrate mastery outcomes. included only if the outcome embeds a rubric criterion. omitted in the abbreviated form.
     */
    mastery_points?: number | null;
    /**
     * maximum points possible. included only if the outcome embeds a rubric criterion. omitted in the abbreviated form.
     */
    points_possible?: number | null;
    /**
     * possible ratings for this outcome. included only if the outcome embeds a rubric criterion. omitted in the abbreviated form.
     */
    ratings?: Array<RubricRating> | null;
    /**
     * title of the outcome
     */
    title?: string | null;
    /**
     * the URL for fetching/updating the outcome. should be treated as opaque
     */
    url?: string | null;
    /**
     * A custom GUID for the learning standard.
     */
    vendor_guid?: string | null;
};

export type OutcomeNullable = {
    /**
     * whether this outcome has been used to assess a student
     */
    assessed?: boolean | null;
    /**
     * this defines the variable value used by the calculation_method. included only if calculation_method uses it
     */
    calculation_int?: number | null;
    /**
     * the method used to calculate a students score
     */
    calculation_method?: string | null;
    /**
     * whether the current user can update the outcome
     */
    can_edit?: boolean | null;
    /**
     * whether the outcome can be unlinked
     */
    can_unlink?: boolean | null;
    /**
     * the context owning the outcome. may be null for global outcomes
     */
    context_id?: number | null;
    context_type?: string | null;
    /**
     * description of the outcome. omitted in the abbreviated form.
     */
    description?: string | null;
    /**
     * Optional friendly name for reporting
     */
    display_name?: string | null;
    /**
     * whether updates to this outcome will propagate to unassessed rubrics that have imported it
     */
    has_updateable_rubrics?: boolean | null;
    /**
     * the ID of the outcome
     */
    id?: number;
    /**
     * points necessary to demonstrate mastery outcomes. included only if the outcome embeds a rubric criterion. omitted in the abbreviated form.
     */
    mastery_points?: number | null;
    /**
     * maximum points possible. included only if the outcome embeds a rubric criterion. omitted in the abbreviated form.
     */
    points_possible?: number | null;
    /**
     * possible ratings for this outcome. included only if the outcome embeds a rubric criterion. omitted in the abbreviated form.
     */
    ratings?: Array<RubricRating> | null;
    /**
     * title of the outcome
     */
    title?: string | null;
    /**
     * the URL for fetching/updating the outcome. should be treated as opaque
     */
    url?: string | null;
    /**
     * A custom GUID for the learning standard.
     */
    vendor_guid?: string | null;
} | null;

export type OutcomeAlignment = {
    /**
     * the id of the aligned assignment.
     */
    assignment_id?: number | null;
    /**
     * the id of the aligned learning outcome.
     */
    id?: number;
    /**
     * a string representing the different submission types of an aligned assignment.
     */
    submission_types?: string | null;
    /**
     * the title of the aligned assignment.
     */
    title?: string | null;
    /**
     * the URL for the aligned assignment.
     */
    url?: string | null;
};

export type OutcomeGroup = {
    /**
     * whether the current user can update the outcome group
     */
    can_edit?: boolean | null;
    /**
     * the context owning the outcome group. may be null for global outcome groups. omitted in the abbreviated form.
     */
    context_id?: number | null;
    context_type?: string | null;
    /**
     * description of the outcome group. omitted in the abbreviated form.
     */
    description?: string | null;
    /**
     * the ID of the outcome group
     */
    id?: number;
    /**
     * the URL for importing another group into this outcome group. should be treated as opaque. omitted in the abbreviated form.
     */
    import_url?: string | null;
    /**
     * the URL for listing/creating outcome links under the outcome group. should be treated as opaque
     */
    outcomes_url?: string | null;
    parent_outcome_group?: OutcomeGroupNullable;
    /**
     * the URL for listing/creating subgroups under the outcome group. should be treated as opaque
     */
    subgroups_url?: string | null;
    /**
     * title of the outcome group
     */
    title?: string | null;
    /**
     * the URL for fetching/updating the outcome group. should be treated as opaque
     */
    url?: string | null;
    /**
     * A custom GUID for the learning standard.
     */
    vendor_guid?: string | null;
};

export type OutcomeGroupNullable = {
    /**
     * whether the current user can update the outcome group
     */
    can_edit?: boolean | null;
    /**
     * the context owning the outcome group. may be null for global outcome groups. omitted in the abbreviated form.
     */
    context_id?: number | null;
    context_type?: string | null;
    /**
     * description of the outcome group. omitted in the abbreviated form.
     */
    description?: string | null;
    /**
     * the ID of the outcome group
     */
    id?: number;
    /**
     * the URL for importing another group into this outcome group. should be treated as opaque. omitted in the abbreviated form.
     */
    import_url?: string | null;
    /**
     * the URL for listing/creating outcome links under the outcome group. should be treated as opaque
     */
    outcomes_url?: string | null;
    parent_outcome_group?: OutcomeGroupNullable;
    /**
     * the URL for listing/creating subgroups under the outcome group. should be treated as opaque
     */
    subgroups_url?: string | null;
    /**
     * title of the outcome group
     */
    title?: string | null;
    /**
     * the URL for fetching/updating the outcome group. should be treated as opaque
     */
    url?: string | null;
    /**
     * A custom GUID for the learning standard.
     */
    vendor_guid?: string | null;
} | null;

export type OutcomeImport = {
    /**
     * The date the outcome import was created.
     */
    created_at?: string | null;
    data?: OutcomeImportData;
    /**
     * The date the outcome import finished. Returns null if not finished.
     */
    ended_at?: string | null;
    /**
     * The unique identifier for the outcome import.
     */
    id?: number;
    /**
     * An array of row number / error message pairs. Returns the first 25 errors.
     */
    processing_errors?: Array<Array<{
        [key: string]: unknown;
    }>> | null;
    /**
     * The progress of the outcome import.
     */
    progress?: string | null;
    /**
     * The date the outcome import was last updated.
     */
    updated_at?: string | null;
    user?: UserNullable;
    /**
     * The current state of the outcome import.
     * - 'created': The outcome import has been created.
     * - 'importing': The outcome import is currently processing.
     * - 'succeeded': The outcome import has completed successfully.
     * - 'failed': The outcome import failed.
     */
    workflow_state?: string | null;
};

export type OutcomeImportData = {
    /**
     * The type of outcome import
     */
    import_type?: string | null;
} | null;

export type OutcomeLink = {
    /**
     * whether this outcome has been used to assess a student in the context of this outcome link.  In other words, this will be set to true if the context is a course, and a student has been assessed with this outcome in that course.
     */
    assessed?: boolean | null;
    /**
     * whether this outcome link is manageable and is not the last link to an aligned outcome
     */
    can_unlink?: boolean | null;
    /**
     * the context owning the outcome link. will match the context owning the outcome group containing the outcome link; included for convenience. may be null for links in global outcome groups.
     */
    context_id?: number | null;
    context_type?: string | null;
    outcome?: OutcomeNullable;
    outcome_group?: OutcomeGroupNullable;
    /**
     * the URL for fetching/updating the outcome link. should be treated as opaque
     */
    url?: string | null;
};

/**
 * A student's result for an outcome
 */
export type OutcomeResult = {
    /**
     * A unique identifier for this result
     */
    id?: number;
    /**
     * True if the outcome been mastered
     */
    mastery?: boolean;
    /**
     * The student's score
     */
    score?: number;
    /**
     * total possible points for the score
     */
    possible?: number;
    /**
     * The datetime the resulting OutcomeResult was submitted at, or absent that, when it was assessed.
     */
    submitted_or_assessed_at?: string;
    /**
     * Unique identifiers of objects associated with this result
     */
    links?: {
        [key: string]: unknown;
    };
    /**
     * score's percent of maximum points possible for outcome, scaled to reflect any custom mastery levels that differ from the learning outcome
     */
    percent?: number;
    hidden?: boolean;
    hide_points?: boolean;
};

/**
 * Assessment Outcome Results and optional info (enabled via the "include" parameter on the request)
 */
export type OutcomeResultResponse = {
    /**
     * Specific outcome results for each assessment
     */
    outcome_results?: Array<OutcomeResult>;
    linked?: {
        /**
         * Alignments related to the outcome results (optionally included)
         */
        alignments?: Array<OutcomeAlignment> | null;
        /**
         * Outcomes related to the outcome results (optionally included)
         */
        outcomes?: Array<Outcome> | null;
        /**
         * Outcome Groups related to the outcome results (optionally included)
         */
        outcome_groups?: Array<OutcomeGroup> | null;
        /**
         * Outcome Links related to the outcome results (optionally included)
         */
        outcome_links?: Array<OutcomeLink> | null;
        /**
         * Outcome Paths related to the outcome results (optionally included)
         */
        outcome_paths?: Array<OutcomePath>;
        /**
         * Users related to the outcome results (optionally included)
         */
        users?: Array<User>;
    } | null;
};

export type OutcomeRollupScoreLinks = {
    /**
     * The id of the related outcome
     */
    outcome?: number;
};

export type OutcomeRollupScore = {
    /**
     * The rollup score for the outcome, based on the student alignment scores related to the outcome. This could be null if the student has no related scores.
     */
    score?: number;
    /**
     * The number of alignment scores included in this rollup.
     */
    count?: number;
    links?: OutcomeRollupScoreLinks;
};

export type OutcomeRollupLinks = {
    /**
     * If an aggregate result was requested, the course field will be present. Otherwise, the user and section field will be present (Optional) The id of the course that this rollup applies to
     */
    course?: number;
    /**
     * (Optional) The id of the user that this rollup applies to
     */
    user?: number;
    /**
     * (Optional) The id of the section the user is in
     */
    section?: number;
};

export type OutcomeRollup = {
    scores?: Array<OutcomeRollupScore>;
    links?: OutcomeRollupLinks;
};

/**
 * Assessment Outcome Rollup Results and optional info (enabled via the "include" parameter on the request)
 */
export type OutcomeRollupResponse = {
    /**
     * Outcome rollups
     */
    rollups?: Array<OutcomeRollup>;
    linked?: {
        /**
         * Courses related to the rollup (optionally included)
         */
        courses?: Array<Course> | null;
        /**
         * Outcomes related to the rollup (optionally included)
         */
        outcomes?: Array<Outcome> | null;
        /**
         * Outcome Groups related to the rollup (optionally included)
         */
        outcome_groups?: Array<OutcomeGroup> | null;
        /**
         * Outcome Links related to the rollup (optionally included)
         */
        outcome_links?: Array<OutcomeLink> | null;
        /**
         * Outcome Paths related to the rollup (optionally included)
         */
        outcome_paths?: Array<OutcomePath>;
        /**
         * Users related to the rollup (optionally included)
         */
        users?: Array<User>;
    } | null;
};

/**
 * The full path to an outcome
 */
export type OutcomePath = {
    /**
     * A unique identifier for this outcome
     */
    id?: number;
    parts?: OutcomePathPart;
};

/**
 * An outcome or outcome group
 */
export type OutcomePathPart = {
    /**
     * The title of the outcome or outcome group
     */
    name?: string;
};

export type Page = {
    /**
     * the page content, in HTML (present when requesting a single page; omitted when listing pages)
     */
    body?: string | null;
    /**
     * the creation date for the page
     */
    created_at?: string | null;
    /**
     * roles allowed to edit the page; comma-separated list comprising a combination of 'teachers', 'students', 'members', and/or 'public' if not supplied, course defaults are used
     */
    editing_roles?: string | null;
    /**
     * whether this page is the front page for the wiki
     */
    front_page?: boolean | null;
    /**
     * (DEPRECATED) whether this page is hidden from students (note: this is always reflected as the inverse of the published value)
     */
    hide_from_students?: boolean | null;
    last_edited_by?: UserNullable;
    /**
     * (Optional) An explanation of why this is locked for the user. Present when locked_for_user is true.
     */
    lock_explanation?: string | null;
    lock_info?: LockInfo;
    /**
     * Whether or not this is locked for the user.
     */
    locked_for_user?: boolean | null;
    /**
     * whether the page is published (true) or draft state (false).
     */
    published?: boolean | null;
    /**
     * the title of the page
     */
    title?: string | null;
    /**
     * the date the page was last updated
     */
    updated_at?: string | null;
    /**
     * the unique locator for the page
     */
    url?: string | null;
};

export type PageRevision = {
    /**
     * the historic page contents
     */
    body?: string | null;
    edited_by?: UserNullable;
    /**
     * whether this is the latest revision or not
     */
    latest?: boolean | null;
    /**
     * an identifier for this revision of the page
     */
    revision_id?: number | null;
    /**
     * the historic page title
     */
    title?: string | null;
    /**
     * the time when this revision was saved
     */
    updated_at?: string | null;
    /**
     * the following fields are not included in the index action and may be omitted from the show action via summary=1 the historic url of the page
     */
    url?: string | null;
};

/**
 * The record of a user page view access in Canvas
 */
export type PageView = {
    /**
     * The rails action that handled the request
     */
    action?: string | null;
    /**
     * If the request is from an API request, the app that generated the access token
     */
    app_name?: string | null;
    /**
     * The type of asset in the context for the request, if any
     */
    asset_type?: string | null;
    /**
     * The type of context for the request
     */
    context_type?: string | null;
    /**
     * This field is deprecated, and will always be false
     */
    contributed?: boolean | null;
    /**
     * The rails controller that handled the request
     */
    controller?: string | null;
    /**
     * When the request was made
     */
    created_at?: string | null;
    /**
     * The HTTP method such as GET or POST
     */
    http_method?: string | null;
    /**
     * A UUID representing the page view.  This is also the unique request id
     */
    id: string;
    /**
     * An approximation of how long the user spent on the page, in seconds
     */
    interaction_seconds?: number | null;
    links?: PageViewLinks;
    /**
     * True if the request counted as participating, such as submitting homework
     */
    participated?: boolean | null;
    /**
     * The origin IP address of the request
     */
    remote_ip?: string | null;
    /**
     * How long the response took to render, in seconds
     */
    render_time?: number | null;
    /**
     * The URL requested
     */
    url?: string | null;
    /**
     * The user-agent of the browser or program that made the request
     */
    user_agent?: string | null;
    /**
     * A flag indicating whether the request was user-initiated, or automatic (such as an AJAX call)
     */
    user_request?: boolean | null;
};

/**
 * The links of a page view access in Canvas
 */
export type PageViewLinks = {
    /**
     * The ID of the account context for this page view
     */
    account?: number | null;
    /**
     * The ID of the asset for the request, if any
     */
    asset?: number | null;
    /**
     * The ID of the context for the request (course id if context_type is Course, etc)
     */
    context?: number | null;
    /**
     * The ID of the actual user who made this request, if the request was made by a user who was masquerading
     */
    real_user?: number | null;
    /**
     * The ID of the user for this page view
     */
    user?: number | null;
} | null;

export type PeerReview = {
    /**
     * The User object for the assessor if the user include parameter is provided (see user API) (optional)
     */
    assessor?: string | null;
    /**
     * The assessors user id
     */
    assessor_id?: number | null;
    /**
     * The id for the asset associated with this Peer Review
     */
    asset_id?: number | null;
    /**
     * The type of the asset
     */
    asset_type?: string | null;
    /**
     * The id of the Peer Review
     */
    id?: number;
    /**
     * The submission comments associated with this Peer Review if the submission_comment include parameter is provided (see submissions API) (optional)
     */
    submission_comments?: string | null;
    /**
     * the User object for the owner of the asset if the user include parameter is provided (see user API) (optional)
     */
    user?: string | null;
    /**
     * The user id for the owner of the asset
     */
    user_id?: number | null;
    /**
     * The state of the Peer Review, either 'assigned' or 'completed'
     */
    workflow_state?: string | null;
};

export type Permission = {
    add_course_template?: boolean | null;
    add_designer_to_course?: boolean | null;
    add_observer_to_course?: boolean | null;
    add_student_to_course?: boolean | null;
    add_ta_to_course?: boolean | null;
    add_teacher_to_course?: boolean | null;
    allow_course_admin_actions?: boolean | null;
    become_user?: boolean | null;
    change_course_state?: boolean | null;
    create_accounts?: boolean | null;
    create_collaborations?: boolean | null;
    create_conferences?: boolean | null;
    create_forum?: boolean | null;
    create_tool_manually?: boolean | null;
    delete?: boolean | null;
    delete_course_template?: boolean | null;
    direct_share?: boolean | null;
    edit_course_template?: boolean | null;
    generate_observer_pairing_code?: boolean | null;
    import_outcomes?: boolean | null;
    import_sis?: boolean | null;
    lti_add_edit?: boolean | null;
    manage?: boolean | null;
    manage_account_banks?: boolean | null;
    manage_account_calendar_events?: boolean | null;
    manage_account_calendar_visibility?: boolean | null;
    manage_account_memberships?: boolean | null;
    manage_account_settings?: boolean | null;
    manage_admin_users?: boolean | null;
    manage_alerts?: boolean | null;
    manage_assignments?: boolean | null;
    manage_assignments_add?: boolean | null;
    manage_assignments_delete?: boolean | null;
    manage_assignments_edit?: boolean | null;
    manage_calendar?: boolean | null;
    manage_canvasnet_courses?: boolean | null;
    manage_catalog?: boolean | null;
    manage_content?: boolean | null;
    manage_course_content_add?: boolean | null;
    manage_course_content_delete?: boolean | null;
    manage_course_content_edit?: boolean | null;
    manage_course_visibility?: boolean | null;
    manage_courses?: boolean | null;
    manage_courses_add?: boolean | null;
    manage_courses_admin?: boolean | null;
    manage_courses_conclude?: boolean | null;
    manage_courses_delete?: boolean | null;
    manage_courses_publish?: boolean | null;
    manage_courses_reset?: boolean | null;
    manage_data_services?: boolean | null;
    manage_demos?: boolean | null;
    manage_developer_keys?: boolean | null;
    manage_feature_flags?: boolean | null;
    manage_files_add?: boolean | null;
    manage_files_delete?: boolean | null;
    manage_files_edit?: boolean | null;
    manage_frozen_assignments?: boolean | null;
    manage_global_outcomes?: boolean | null;
    manage_grades?: boolean | null;
    manage_groups?: boolean | null;
    manage_groups_add?: boolean | null;
    manage_groups_delete?: boolean | null;
    manage_groups_manage?: boolean | null;
    manage_interaction_alerts?: boolean | null;
    manage_internal_analytics?: boolean | null;
    manage_internal_settings?: boolean | null;
    manage_jobs?: boolean | null;
    manage_links?: boolean | null;
    manage_lti_add?: boolean | null;
    manage_lti_delete?: boolean | null;
    manage_lti_edit?: boolean | null;
    manage_master_courses?: boolean | null;
    manage_outcomes?: boolean | null;
    manage_proficiency_calculations?: boolean | null;
    manage_proficiency_scales?: boolean | null;
    manage_release_notes?: boolean | null;
    manage_role_overrides?: boolean | null;
    manage_rubrics?: boolean | null;
    manage_sections_add?: boolean | null;
    manage_sections_delete?: boolean | null;
    manage_sections_edit?: boolean | null;
    manage_sftp_user_settings?: boolean | null;
    manage_sis?: boolean | null;
    manage_site_settings?: boolean | null;
    manage_storage_quotas?: boolean | null;
    manage_students?: boolean | null;
    manage_user_logins?: boolean | null;
    manage_user_notes?: boolean | null;
    manage_user_observers?: boolean | null;
    manage_wiki_create?: boolean | null;
    manage_wiki_delete?: boolean | null;
    manage_wiki_update?: boolean | null;
    moderate_forum?: boolean | null;
    moderate_user_content?: boolean | null;
    participate_as_student?: boolean | null;
    post_to_forum?: boolean | null;
    provision_catalog?: boolean | null;
    proxy_assignment_submission?: boolean | null;
    read?: boolean | null;
    read_announcements?: boolean | null;
    read_as_admin?: boolean | null;
    read_as_member?: boolean | null;
    read_course_content?: boolean | null;
    read_course_list?: boolean | null;
    read_email_addresses?: boolean | null;
    read_files?: boolean | null;
    read_forum?: boolean | null;
    read_grades?: boolean | null;
    read_messages?: boolean | null;
    read_outcomes?: boolean | null;
    read_prior_roster?: boolean | null;
    read_question_banks?: boolean | null;
    read_reports?: boolean | null;
    read_roster?: boolean | null;
    read_rubrics?: boolean | null;
    read_sis?: boolean | null;
    read_syllabus?: boolean | null;
    remove_designer_from_course?: boolean | null;
    remove_observer_from_course?: boolean | null;
    remove_student_from_course?: boolean | null;
    remove_ta_from_course?: boolean | null;
    remove_teacher_from_course?: boolean | null;
    reset_any_mfa?: boolean | null;
    reset_content?: boolean | null;
    ruby_profile?: boolean | null;
    select_final_grade?: boolean | null;
    send_messages?: boolean | null;
    send_messages_all?: boolean | null;
    suspend_accounts?: boolean | null;
    undelete_courses?: boolean | null;
    update?: boolean | null;
    use_student_view?: boolean | null;
    view_all_grades?: boolean | null;
    view_analytics?: boolean | null;
    view_audit_trail?: boolean | null;
    view_course_changes?: boolean | null;
    view_error_reports?: boolean | null;
    view_feature_flags?: boolean | null;
    view_grade_changes?: boolean | null;
    view_group_pages?: boolean | null;
    view_jobs?: boolean | null;
    view_notifications?: boolean | null;
    view_quiz_answer_audits?: boolean | null;
    view_statistics?: boolean | null;
    view_unpublished_items?: boolean | null;
    view_user_logins?: boolean | null;
};

/**
 * A planner note
 */
export type PlannerNote = {
    /**
     * The course that the note is in relation too, if applicable
     */
    course_id?: number | null;
    /**
     * The description of the planner note
     */
    description?: string | null;
    /**
     * The ID of the planner note
     */
    id?: number;
    /**
     * the Canvas web URL of the linked learning object
     */
    linked_object_html_url?: string | null;
    /**
     * the id of the linked learning object
     */
    linked_object_id?: number | null;
    /**
     * the type of the linked learning object
     */
    linked_object_type?: string | null;
    /**
     * the API URL of the linked learning object
     */
    linked_object_url?: string | null;
    /**
     * The title for a planner note
     */
    title?: string | null;
    /**
     * The datetime of when the planner note should show up on their planner
     */
    todo_date?: string | null;
    /**
     * The id of the associated user creating the planner note
     */
    user_id?: number | null;
    /**
     * The current published state of the planner note
     */
    workflow_state?: string | null;
};

/**
 * User-controlled setting for whether an item should be displayed on the planner or not
 */
export type PlannerOverride = {
    /**
     * The id of the plannable's associated assignment, if it has one
     */
    assignment_id?: number | null;
    /**
     * The datetime of when the planner override was created
     */
    created_at?: string | null;
    /**
     * The datetime of when the planner override was deleted, if applicable
     */
    deleted_at?: string | null;
    /**
     * Controls whether or not the associated plannable item shows up in the opportunities list
     */
    dismissed?: boolean | null;
    /**
     * The ID of the planner override
     */
    id?: number;
    /**
     * Controls whether or not the associated plannable item is marked complete on the planner
     */
    marked_complete?: boolean | null;
    /**
     * The id of the associated object for the planner override
     */
    plannable_id?: number | null;
    /**
     * The type of the associated object for the planner override
     */
    plannable_type?: string | null;
    /**
     * The datetime of when the planner override was updated
     */
    updated_at?: string | null;
    /**
     * The id of the associated user for the planner override
     */
    user_id?: number | null;
    /**
     * The current published state of the item, synced with the associated object
     */
    workflow_state?: string | null;
};

export type Poll = {
    /**
     * The unique identifier for the poll
     */
    id?: number;
    /**
     * The question/title of the poll
     */
    question?: string;
    /**
     * The description of the poll
     */
    description?: string;
    /**
     * The time at which the poll was created
     */
    created_at?: string;
    /**
     * The unique identifier for the user that created the poll
     */
    user_id?: number;
    /**
     * An aggregate of the results of all associated poll sessions, with the poll choice id as the key, and the aggregated submission count as the value.
     */
    total_results?: {
        [key: string]: unknown;
    };
};

export type Proficiency = {
    /**
     * An array of proficiency ratings. See the ProficiencyRating specification above.
     */
    ratings?: Array<{
        [key: string]: unknown;
    }> | null;
};

/**
 * Profile details for a Canvas user.
 */
export type Profile = {
    /**
     * The avatar_url can change over time, so we recommend not caching it for more than a few hours
     */
    avatar_url?: string | null;
    bio?: string | null;
    calendar?: CalendarLink;
    /**
     * This field is not in the Canvas API specification
     */
    effective_locale?: string | null;
    /**
     * The ID of the user.
     */
    id?: number;
    /**
     * The integration_id associated with the user.
     */
    integration_id?: string | null;
    /**
     * The users locale.
     */
    locale?: string | null;
    /**
     * sample_user@example.com
     */
    login_id?: string | null;
    lti_user_id?: string | null;
    /**
     * Sample User
     */
    name?: string | null;
    /**
     * sample_user@example.com
     */
    primary_email?: string | null;
    /**
     * The pronouns set on the profile (as of 12/02/2023 this is not in the API specification, but is returned with a profile call)
     */
    pronouns?: string | null;
    /**
     * Sample User
     */
    short_name?: string | null;
    /**
     * sis1
     */
    sis_user_id?: string | null;
    /**
     * user, sample
     */
    sortable_name?: string | null;
    /**
     * Optional: This field is only returned in certain API calls, and will return the IANA time zone name of the user's preferred timezone.
     */
    time_zone?: string | null;
    title?: string | null;
};

export type Progress = {
    /**
     * percent completed
     */
    completion?: number | null;
    /**
     * the context owning the job.
     */
    context_id?: number | null;
    context_type?: string | null;
    /**
     * the time the job was created
     */
    created_at?: string | null;
    /**
     * the ID of the Progress object
     */
    id?: number;
    /**
     * optional details about the job
     */
    message?: string | null;
    /**
     * optional results of the job. omitted when job is still pending
     */
    results?: {
        [key: string]: unknown;
    } | null;
    /**
     * the type of operation
     */
    tag?: string | null;
    /**
     * the time the job was last updated
     */
    updated_at?: string | null;
    /**
     * url where a progress update can be retrieved
     */
    url?: string | null;
    /**
     * the id of the user who started the job
     */
    user_id?: number | null;
    /**
     * the state of the job one of 'queued', 'running', 'completed', 'failed'
     */
    workflow_state?: string | null;
};

export type ProgressNullable = {
    /**
     * percent completed
     */
    completion?: number | null;
    /**
     * the context owning the job.
     */
    context_id?: number | null;
    context_type?: string | null;
    /**
     * the time the job was created
     */
    created_at?: string | null;
    /**
     * the ID of the Progress object
     */
    id?: number;
    /**
     * optional details about the job
     */
    message?: string | null;
    /**
     * optional results of the job. omitted when job is still pending
     */
    results?: {
        [key: string]: unknown;
    } | null;
    /**
     * the type of operation
     */
    tag?: string | null;
    /**
     * the time the job was last updated
     */
    updated_at?: string | null;
    /**
     * url where a progress update can be retrieved
     */
    url?: string | null;
    /**
     * the id of the user who started the job
     */
    user_id?: number | null;
    /**
     * the state of the job one of 'queued', 'running', 'completed', 'failed'
     */
    workflow_state?: string | null;
} | null;

export type ProvisionalGrade = {
    /**
     * Whether this is the 'final' provisional grade created by the moderator
     */
    final?: boolean | null;
    /**
     * The grade
     */
    grade?: string | null;
    /**
     * Whether the grade was applied to the most current submission (false if the student resubmitted after grading)
     */
    grade_matches_current_submission?: boolean | null;
    /**
     * When the grade was given
     */
    graded_at?: string | null;
    /**
     * The identifier for the provisional grade
     */
    provisional_grade_id?: number | null;
    /**
     * The numeric score
     */
    score?: number | null;
    /**
     * A link to view this provisional grade in SpeedGrader
     */
    speedgrader_url?: string | null;
};

export type Quiz = {
    /**
     * access code to restrict quiz access
     */
    access_code?: string | null;
    /**
     * list of due dates for the quiz
     */
    all_dates?: Array<AssignmentDate> | null;
    /**
     * how many times a student can take the quiz -1 = unlimited attempts
     */
    allowed_attempts?: number | null;
    /**
     * Whether survey submissions will be kept anonymous (only applicable to 'graded_survey', 'survey' quiz types)
     */
    anonymous_submissions?: boolean | null;
    /**
     * the ID of the quiz's assignment group:
     */
    assignment_group_id?: number | null;
    /**
     * lock questions after answering? only valid if one_question_at_a_time=true
     */
    cant_go_back?: boolean | null;
    /**
     * the description of the quiz
     */
    description?: string | null;
    /**
     * when the quiz is due
     */
    due_at?: string | null;
    /**
     * prevent the students from seeing correct answers after the specified date has passed. only valid if show_correct_answers=true
     */
    hide_correct_answers_at?: string | null;
    /**
     * let students see their quiz responses? possible values: null, 'always', 'until_after_last_attempt'
     */
    hide_results?: string | null;
    /**
     * the HTTP/HTTPS URL to the quiz
     */
    html_url?: string | null;
    /**
     * the ID of the quiz
     */
    id?: number;
    /**
     * IP address or range that quiz access is limited to
     */
    ip_filter?: string | null;
    /**
     * when to lock the quiz
     */
    lock_at?: string | null;
    /**
     * (Optional) An explanation of why this is locked for the user. Present when locked_for_user is true.
     */
    lock_explanation?: string | null;
    lock_info?: LockInfo;
    /**
     * Whether or not this is locked for the user.
     */
    locked_for_user?: boolean | null;
    /**
     * a url suitable for loading the quiz in a mobile webview.  it will persiste the headless session and, for quizzes in public courses, will force the user to login
     */
    mobile_url?: string | null;
    /**
     * show one question at a time?
     */
    one_question_at_a_time?: boolean | null;
    /**
     * prevent the students from seeing their results more than once (right after they submit the quiz)
     */
    one_time_results?: boolean | null;
    permissions?: QuizPermissions;
    /**
     * The total point value given to the quiz
     */
    points_possible?: number | null;
    /**
     * A url that can be visited in the browser with a POST request to preview a quiz as the teacher. Only present when the user may grade
     */
    preview_url?: string | null;
    /**
     * whether the quiz has a published or unpublished draft state.
     */
    published?: boolean | null;
    /**
     * the number of questions in the quiz
     */
    question_count?: number | null;
    /**
     * List of question types in the quiz
     */
    question_types?: Array<string> | null;
    /**
     * Link to endpoint to send extensions for this quiz.
     */
    quiz_extensions_url?: string | null;
    /**
     * type of quiz possible values: 'practice_quiz', 'assignment', 'graded_survey', 'survey'
     */
    quiz_type?: string | null;
    /**
     * which quiz score to keep (only if allowed_attempts != 1) possible values: 'keep_highest', 'keep_latest'
     */
    scoring_policy?: string | null;
    /**
     * show which answers were correct when results are shown? only valid if hide_results=null
     */
    show_correct_answers?: boolean | null;
    /**
     * when should the correct answers be visible by students? only valid if show_correct_answers=true
     */
    show_correct_answers_at?: string | null;
    /**
     * restrict the show_correct_answers option above to apply only to the last submitted attempt of a quiz that allows multiple attempts. only valid if show_correct_answers=true and allowed_attempts > 1
     */
    show_correct_answers_last_attempt?: boolean | null;
    /**
     * shuffle answers for students?
     */
    shuffle_answers?: boolean | null;
    /**
     * Link to Speed Grader for this quiz. Will not be present if quiz is unpublished
     */
    speedgrader_url?: string | null;
    /**
     * quiz time limit in minutes
     */
    time_limit?: number | null;
    /**
     * the title of the quiz
     */
    title?: string | null;
    /**
     * when to unlock the quiz
     */
    unlock_at?: string | null;
    /**
     * Whether the assignment's 'published' state can be changed to false. Will be false if there are student submissions for the quiz.
     */
    unpublishable?: boolean | null;
    /**
     * Current version number of the quiz
     */
    version_number?: number | null;
};

/**
 * Set of assignment-overridden dates for a quiz.
 */
export type QuizAssignmentOverride = {
    /**
     * If this property is present, it means that dates in this structure are not based on an assignment override, but are instead for all students.
     */
    base?: boolean | null;
    /**
     * The date after which any quiz submission is considered late.
     */
    due_at?: string | null;
    /**
     * ID of the assignment override, unless this is the base construct, in which case the 'id' field is omitted.
     */
    id?: number;
    /**
     * When the quiz will stop being available for taking. A value of null means it can always be taken.
     */
    lock_at?: string | null;
    /**
     * Title of the section this assignment override is for, if any.
     */
    title?: string | null;
    /**
     * Date when the quiz becomes available for taking.
     */
    unlock_at?: string | null;
} | null;

/**
 * Set of assignment-overridden dates for a quiz.
 */
export type QuizAssignmentOverrideSet = {
    all_dates?: QuizAssignmentOverride;
    due_dates?: QuizAssignmentOverride;
    /**
     * ID of the quiz those dates are for.
     */
    quiz_id?: string | null;
};

/**
 * Container for set of assignment-overridden dates for a quiz.
 */
export type QuizAssignmentOverrideSetContainer = {
    /**
     * The QuizAssignmentOverrideSet
     */
    quiz_assignment_overrides?: Array<QuizAssignmentOverrideSet> | null;
};

export type QuizGroup = {
    /**
     * The ID of the Assessment question bank to pull questions from.
     */
    assessment_question_bank_id?: number | null;
    /**
     * The ID of the question group.
     */
    id: number;
    /**
     * The name of the question group.
     */
    name?: string | null;
    /**
     * The number of questions to pick from the group to display to the student.
     */
    pick_count?: number | null;
    /**
     * The order in which the question group will be retrieved and displayed.
     */
    position?: number | null;
    /**
     * The amount of points allotted to each question in the group.
     */
    question_points?: number | null;
    /**
     * The ID of the Quiz the question group belongs to.
     */
    quiz_id: number;
};

/**
 * Permissions the user has for the quiz
 */
export type QuizPermissions = {
    /**
     * whether the user may create a new quiz
     */
    create?: boolean | null;
    /**
     * whether the user may edit, update, or delete the quiz
     */
    manage?: boolean | null;
    /**
     * whether the user can view the quiz
     */
    read?: boolean | null;
    /**
     * whether the user may view quiz statistics for this quiz
     */
    read_statistics?: boolean | null;
    /**
     * whether the user may review grades for all quiz submissions for this quiz
     */
    review_grades?: boolean | null;
    /**
     * whether the user may submit a submission for the quiz
     */
    submit?: boolean | null;
    /**
     * whether the user may update the quiz
     */
    update?: boolean | null;
} | null;

export type QuizQuestion = {
    /**
     * An array of available answers to display to the student.
     */
    answers?: Array<Answer> | null;
    /**
     * The comments to display if the student answers the question correctly.
     */
    correct_comments?: string | null;
    /**
     * The ID of the quiz question.
     */
    id: number;
    /**
     * The comments to display if the student answers incorrectly.
     */
    incorrect_comments?: string | null;
    /**
     * The comments to display regardless of how the student answered.
     */
    neutral_comments?: string | null;
    /**
     * The maximum amount of points possible received for getting this question correct.
     */
    points_possible?: number | null;
    /**
     * The order in which the question will be retrieved and displayed.
     */
    position?: number | null;
    /**
     * The name of the question.
     */
    question_name?: string | null;
    /**
     * The text of the question.
     */
    question_text?: string | null;
    /**
     * The type of the question.
     */
    question_type?: string | null;
    /**
     * The ID of the Quiz the question belongs to.
     */
    quiz_id: number;
};

export type QuizReport = {
    /**
     * boolean indicating whether the report is for an anonymous survey. if true, no student names will be included in the csv
     */
    anonymous?: boolean | null;
    /**
     * when the report was created
     */
    created_at?: string | null;
    file?: FileNullable;
    /**
     * boolean indicating whether the report can be generated, which is true unless the quiz is a survey one
     */
    generatable?: boolean | null;
    /**
     * the ID of the quiz report
     */
    id?: number;
    /**
     * boolean indicating whether the report represents all submissions or only the most recent ones for each student
     */
    includes_all_versions?: boolean | null;
    progress?: ProgressNullable;
    /**
     * if the report has not yet finished generating, a URL where information about its progress can be retrieved. refer to the Progress API for more information (Note: not available in JSON-API format)
     */
    progress_url?: string | null;
    /**
     * the ID of the quiz
     */
    quiz_id?: number;
    /**
     * a human-readable (and localized) version of the report_type
     */
    readable_type?: string | null;
    /**
     * which type of report this is possible values: 'student_analysis', 'item_analysis'
     */
    report_type?: string | null;
    /**
     * when the report was last updated
     */
    updated_at?: string | null;
    /**
     * the API endpoint for this report
     */
    url?: string | null;
};

export type QuizSubmission = {
    /**
     * For quizzes that allow multiple attempts, this field specifies the quiz submission attempt number.
     */
    attempt?: number | null;
    /**
     * The time at which the quiz submission will be overdue, and be flagged as a late submission.
     */
    end_at?: string | null;
    /**
     * Number of times the student was allowed to re-take the quiz over the multiple-attempt limit.
     */
    extra_attempts?: number | null;
    /**
     * Amount of extra time allowed for the quiz submission, in minutes.
     */
    extra_time?: number | null;
    /**
     * The time at which the student submitted the quiz submission.
     */
    finished_at?: string | null;
    /**
     * Number of points the quiz submission's score was fudged by.
     */
    fudge_points?: number | null;
    /**
     * Whether the student has viewed their results to the quiz.
     */
    has_seen_results?: boolean | null;
    /**
     * The ID of the quiz submission.
     */
    id: number;
    /**
     * For quizzes that allow multiple attempts, this is the score that will be used, which might be the score of the latest, or the highest, quiz submission.
     */
    kept_score?: number | null;
    /**
     * The student can take the quiz even if it's locked for everyone else
     */
    manually_unlocked?: boolean | null;
    /**
     * Indicates whether the quiz submission is overdue and needs submission
     */
    overdue_and_needs_submission?: boolean | null;
    /**
     * The ID of the Quiz the quiz submission belongs to.
     */
    quiz_id: number;
    /**
     * The score of the quiz submission, if graded.
     */
    score?: number | null;
    /**
     * The original score of the quiz submission prior to any re-grading.
     */
    score_before_regrade?: number | null;
    /**
     * The time at which the student started the quiz submission.
     */
    started_at?: string | null;
    /**
     * The ID of the Submission the quiz submission represents.
     */
    submission_id?: number | null;
    /**
     * Amount of time spent, in seconds.
     */
    time_spent?: number | null;
    /**
     * The ID of the Student that made the quiz submission.
     */
    user_id?: number | null;
    /**
     * The current state of the quiz submission. Possible values: ['untaken'|'pending_review'|'complete'|'settings_only'|'preview'].
     */
    workflow_state?: string | null;
};

export type QuizSubmissionQuestion = {
    /**
     * The provided answer (if any) for this question. The format of this parameter depends on the type of the question, see the Appendix for more information.
     */
    answer?: string | null;
    /**
     * The possible answers for this question when those possible answers are necessary.  The presence of this parameter is dependent on permissions.
     */
    answers?: Array<string> | null;
    /**
     * Whether this question is flagged.
     */
    flagged?: boolean | null;
    /**
     * The ID of the QuizQuestion this answer is for.
     */
    id: number;
};

export type Report = {
    attachment?: FileNullable;
    /**
     * The date and time the report was created.
     */
    created_at?: string | null;
    /**
     * This is the current line count being written to the report. It updates every 1000 records.
     */
    current_line?: number | null;
    /**
     * The date and time the report finished processing.
     */
    ended_at?: string | null;
    /**
     * The url to the report download.
     */
    file_url?: string | null;
    /**
     * The unique identifier for the report.
     */
    id?: number;
    parameters?: ReportParameters;
    /**
     * The progress of the report
     */
    progress?: number | null;
    /**
     * The type of report.
     */
    report?: string | null;
    /**
     * The date and time the report started processing.
     */
    started_at?: string | null;
    /**
     * The status of the report
     */
    status?: string | null;
};

/**
 * The parameters returned will vary for each report.
 */
export type ReportParameters = {
    /**
     * If true, account data will be included. If false, account data will be omitted.
     */
    accounts?: boolean | null;
    /**
     * The id of the course to report on
     */
    course_id?: number | null;
    /**
     * If true, course data will be included. If false, course data will be omitted.
     */
    courses?: boolean | null;
    /**
     * The end date for submissions. Max time range is 2 weeks.
     */
    end_at?: string | null;
    /**
     * Include enrollment state. Defaults to 'all' Options: ['active'| 'invited'| 'creation_pending'| 'deleted'| 'rejected'| 'completed'| 'inactive'| 'all']
     */
    enrollment_state?: Array<string> | null;
    /**
     * The canvas id of the term to get grades from
     */
    enrollment_term_id?: number | null;
    /**
     * If true, enrollment data will be included. If false, enrollment data will be omitted.
     */
    enrollments?: boolean | null;
    /**
     * If true, group data will be included. If false, group data will be omitted.
     */
    groups?: boolean | null;
    /**
     * If true, deleted objects will be included. If false, deleted objects will be omitted.
     */
    include_deleted?: boolean | null;
    /**
     * If true, enrollment state will be included. If false, enrollment state will be omitted. Defaults to false.
     */
    include_enrollment_state?: boolean | null;
    /**
     * The sort order for the csv, Options: 'users', 'courses', 'outcomes'.
     */
    order?: string | null;
    /**
     * If true, section data will be included. If false, section data will be omitted.
     */
    sections?: boolean | null;
    sis_accounts_csv?: number | null;
    sis_terms_csv?: number | null;
    /**
     * The beginning date for submissions. Max time range is 2 weeks.
     */
    start_at?: string | null;
    /**
     * If true, term data will be included. If false, term data will be omitted.
     */
    terms?: boolean | null;
    /**
     * If true, user data will be included. If false, user data will be omitted.
     */
    users?: boolean | null;
    /**
     * If true, data for crosslisted courses will be included. If false, data for crosslisted courses will be omitted.
     */
    xlist?: boolean | null;
} | null;

export type Role = {
    /**
     * JSON representation of the account the role is in.
     */
    account?: {
        [key: string]: unknown;
    } | null;
    /**
     * The role type that is being used as a base for this role. For account-level roles, this is 'AccountMembership'. For course-level roles, it is an enrollment type.
     */
    base_role_type?: string | null;
    /**
     * The label of the role.
     */
    label?: string | null;
    /**
     * A dictionary of permissions keyed by name (see permissions input parameter in the 'Create a role' API).
     */
    permissions?: {
        [key: string]: unknown;
    } | null;
    /**
     * The label of the role. (Deprecated alias for 'label')
     */
    role?: string | null;
    /**
     * The state of the role: 'active', 'inactive', or 'built_in'
     */
    workflow_state?: string | null;
};

export type Rubric = {
    /**
     * If an assessment type is included in the 'include' parameter, includes an array of rubric assessment objects for a given rubric, based on the assessment type requested. If the user does not request an assessment type this key will be absent.
     */
    assessments?: Array<RubricAssessment> | null;
    /**
     * the context owning the rubric
     */
    context_id?: number | null;
    context_type?: string | null;
    /**
     * whether or not free-form comments are used
     */
    free_form_criterion_comments?: boolean | null;
    hide_score_total?: boolean | null;
    /**
     * the ID of the rubric
     */
    id?: number;
    points_possible?: number | null;
    read_only?: boolean | null;
    reusable?: boolean | null;
    /**
     * title of the rubric
     */
    title?: string | null;
};

export type RubricAssessment = {
    /**
     * the current number of attempts made on the object of the assessment
     */
    artifact_attempt?: number | null;
    /**
     * the id of the object of the assessment
     */
    artifact_id?: number | null;
    /**
     * the object of the assessment
     */
    artifact_type?: string | null;
    /**
     * the type of assessment. values will be either 'grading', 'peer_review', or 'provisional_grade'
     */
    assessment_type?: string | null;
    /**
     * user id of the person who made the assessment
     */
    assessor_id?: number | null;
    /**
     * (Optional) If 'comments_only' is included in the 'style' parameter, returned assessments will include only the comments portion of their data hash. If the user does not request a style, this key will be absent.
     */
    comments?: Array<string> | null;
    /**
     * (Optional) If 'full' is included in the 'style' parameter, returned assessments will have their full details contained in their data hash. If the user does not request a style, this key will be absent.
     */
    data?: Array<{
        [key: string]: unknown;
    }> | null;
    /**
     * the ID of the rubric
     */
    id?: number;
    rubric_association_id?: number | null;
    /**
     * the rubric the assessment belongs to
     */
    rubric_id?: number | null;
    score?: number | null;
};

export type RubricCriteria = {
    criterion_use_range?: boolean | null;
    description?: string | null;
    /**
     * The id of rubric criteria.
     */
    id?: string;
    /**
     * (Optional) The id of the learning outcome this criteria uses, if any.
     */
    learning_outcome_id?: string | null;
    long_description?: string | null;
    points?: number | null;
    ratings?: Array<RubricRating> | null;
    /**
     * (Optional) The 3rd party vendor's GUID for the outcome this criteria references, if any.
     */
    vendor_guid?: string | null;
};

export type RubricRating = {
    description?: string | null;
    id?: string;
    long_description?: string | null;
    points?: number | null;
};

export type RubricSettings = {
    id?: number | null;
    title?: string | null;
    points_possible?: number | null;
    free_form_criterion_comments?: boolean | null;
    hide_score_total?: boolean | null;
    hide_points?: boolean | null;
} | null;

/**
 * Settings that are applicable across an account's authentication configuration, even if there are multiple individual providers
 */
export type SsoSettings = {
    /**
     * If a discovery url is set, canvas will forward all users to that URL when they need to be authenticated. That page will need to then help the user figure out where they need to go to log in. If no discovery url is configured, the first configuration will be used to attempt to authenticate the user.
     */
    auth_discovery_url?: string | null;
    /**
     * The url to redirect users to for password resets. Leave blank for default Canvas behavior
     */
    change_password_url?: string | null;
    /**
     * The label used for unique login identifiers.
     */
    login_handle_name?: string | null;
    /**
     * If an unknown user url is set, Canvas will forward to that url when a service authenticates a user, but that user does not exist in Canvas. The default behavior is to present an error.
     */
    unknown_user_url?: string | null;
};

export type Scope = {
    /**
     * The controller action the scope is associated to
     */
    action?: string | null;
    /**
     * The controller the scope is associated to
     */
    controller?: string | null;
    /**
     * The resource the scope is associated with
     */
    resource?: string | null;
    /**
     * The localized resource name
     */
    resource_name?: string | null;
    /**
     * The identifier for the scope
     */
    scope?: string | null;
    /**
     * The HTTP verb for the scope
     */
    verb?: string | null;
};

export type Section = {
    /**
     * The unique Canvas identifier for the course in which the section belongs
     */
    course_id?: number | null;
    /**
     * the end date for the section, if applicable
     */
    end_at?: string | null;
    /**
     * The unique identifier for the section.
     */
    id?: number;
    /**
     * Optional: The integration ID of the section. This field is only included if the user has permission to view SIS information.
     */
    integration_id?: string | null;
    /**
     * The name of the section.
     */
    name?: string | null;
    /**
     * The unique identifier of the original course of a cross-listed section
     */
    nonxlist_course_id?: number | null;
    /**
     * Restrict user enrollments to the start and end dates of the section
     */
    restrict_enrollments_to_section_dates?: boolean | null;
    /**
     * The unique SIS identifier for the course in which the section belongs. This field is only included if the user has permission to view SIS information.
     */
    sis_course_id?: string | null;
    /**
     * The unique identifier for the SIS import if created through SIS. This field is only included if the user has permission to manage SIS information.
     */
    sis_import_id?: number | null;
    /**
     * The sis id of the section. This field is only included if the user has permission to view SIS information.
     */
    sis_section_id?: string | null;
    /**
     * the start date for the section, if applicable
     */
    start_at?: string | null;
    /**
     * optional array of students for the section, if include=['students'] is set and applicable
     */
    students?: Array<UserSectionInclude> | null;
    /**
     * optional: the total number of active and invited students in the section
     */
    total_students?: number | null;
};

export type SharedBrandConfig = {
    /**
     * The id of the account it should be shared within.
     */
    account_id?: string | null;
    /**
     * The md5 (since BrandConfigs are identified by MD5 and not numeric id) of the BrandConfig to share.
     */
    brand_config_md5?: string | null;
    /**
     * When this was created
     */
    created_at?: string | null;
    /**
     * The shared_brand_config identifier.
     */
    id?: number;
    /**
     * The name to share this theme as
     */
    name?: string | null;
    /**
     * When this was last updated
     */
    updated_at?: string | null;
};

export type SisImport = {
    /**
     * Whether stickiness was added to the batch changes.
     */
    add_sis_stickiness?: boolean | null;
    /**
     * Whether the import was run in batch mode.
     */
    batch_mode?: boolean | null;
    /**
     * The term the batch was limited to.
     */
    batch_mode_term_id?: string | null;
    /**
     * Whether stickiness was cleared.
     */
    clear_sis_stickiness?: boolean | null;
    /**
     * The date the SIS import was created.
     */
    created_at?: string | null;
    /**
     * An array of CSV files for processing
     */
    csv_attachments?: Array<Array<File>> | null;
    data?: SisImportData;
    /**
     * The ID of the SIS Import that this import was diffed against
     */
    diffed_against_import_id?: number | null;
    /**
     * The identifier of the data set that this SIS batch diffs against
     */
    diffing_data_set_identifier?: string | null;
    /**
     * The date the SIS import finished. Returns null if not finished.
     */
    ended_at?: string | null;
    errors_attachment?: FileNullable;
    /**
     * The unique identifier for the SIS import.
     */
    id?: number;
    /**
     * Enables batch mode against all terms in term file. Requires change_threshold to be set.
     */
    multi_term_batch_mode?: boolean | null;
    /**
     * Whether UI changes were overridden.
     */
    override_sis_stickiness?: boolean | null;
    /**
     * An array of CSV_file/error_message pairs.
     */
    processing_errors?: Array<Array<string>> | null;
    /**
     * Only imports that are complete will get this data. An array of CSV_file/warning_message pairs.
     */
    processing_warnings?: Array<Array<string>> | null;
    /**
     * The progress of the SIS import. The progress will reset when using batch_mode and have a different progress for the cleanup stage
     */
    progress?: string | null;
    /**
     * When set the import will skip any deletes.
     */
    skip_deletes?: boolean | null;
    /**
     * The date the SIS import was last updated.
     */
    updated_at?: string | null;
    user?: UserNullable;
    /**
     * The current state of the SIS import.
     * - 'created': The SIS import has been created.
     * - 'importing': The SIS import is currently processing.
     * - 'cleanup_batch': The SIS import is currently cleaning up courses, sections, and enrollments not included in the batch for batch_mode imports.
     * - 'imported': The SIS import has completed successfully.
     * - 'imported_with_messages': The SIS import completed with errors or warnings.
     * - 'aborted': The SIS import was aborted.
     * - 'failed_with_messages': The SIS import failed with errors.
     * - 'failed': The SIS import failed.
     */
    workflow_state?: string | null;
};

export type SisImportCounts = {
    abstract_courses?: number | null;
    accounts?: number | null;
    /**
     * the number of courses that were removed because they were not included in the batch for batch_mode imports. Only included if courses were deleted
     */
    batch_courses_deleted?: number | null;
    /**
     * the number of enrollments that were removed because they were not included in the batch for batch_mode imports. Only included if enrollments were deleted
     */
    batch_enrollments_deleted?: number | null;
    /**
     * the number of sections that were removed because they were not included in the batch for batch_mode imports. Only included if sections were deleted
     */
    batch_sections_deleted?: number | null;
    courses?: number | null;
    enrollments?: number | null;
    error_count?: number | null;
    grade_publishing_results?: number | null;
    group_memberships?: number | null;
    groups?: number | null;
    sections?: number | null;
    terms?: number | null;
    users?: number | null;
    warning_count?: number | null;
    xlists?: number | null;
} | null;

export type SisImportData = {
    counts?: SisImportCounts;
    /**
     * The type of SIS import
     */
    import_type?: string | null;
    /**
     * Which files were included in the SIS import
     */
    supplied_batches?: Array<string> | null;
} | null;

export type SisImportError = {
    /**
     * The file where the error message occurred.
     */
    file?: string | null;
    /**
     * The error message that from the record.
     */
    message?: string | null;
    /**
     * The line number where the error occurred. Some Importers do not yet support this. This is a 1 based index starting with the header row.
     */
    row?: number | null;
    /**
     * The unique identifier for the SIS import.
     */
    sis_import_id?: number | null;
};

export type Submission = {
    /**
     * A unique short ID identifying this submission without reference to the owning user. Only included if the caller has administrator access for the current account.
     */
    anonymous_id?: string | null;
    assignment?: AssignmentNullable;
    /**
     * The submission's assignment id
     */
    assignment_id?: number | null;
    /**
     * Whether the assignment is visible to the user who submitted the assignment. Submissions where `assignment_visible` is false no longer count towards the student's grade and the assignment can no longer be accessed by the student. `assignment_visible` becomes false for submissions that do not have a grade and whose assignment is no longer assigned to the student's section.
     */
    assignment_visible?: boolean | null;
    /**
     * This is the submission attempt number.
     */
    attempt?: number | null;
    /**
     * The content of the submission, if it was submitted directly in a text field.
     */
    body?: string | null;
    /**
     * The submission's course (see the course API) (optional)
     */
    course?: string | null;
    /**
     * Whether the assignment is excused.  Excused assignments have no impact on a user's grade.
     */
    excused?: boolean | null;
    /**
     * Extra submission attempts allowed fro the given user and assignment.
     */
    extra_attempts?: number | null;
    /**
     * The grade for the submission, translated into the assignment grading scheme (so a letter grade, for example).
     */
    grade?: string | null;
    /**
     * A boolean flag which is false if the student has re-submitted since the submission was last graded.
     */
    grade_matches_current_submission?: boolean | null;
    graded_at?: string | null;
    /**
     * The id of the user who graded the submission. This will be null for submissions that haven't been graded yet. It will be a positive number if a real user has graded the submission and a negative number if the submission was graded by a process (e.g. Quiz autograder and autograding LTI tools).  Specifically autograded quizzes set grader_id to the negative of the quiz id.  Submissions autograded by LTI tools set grader_id to the negative of the tool id.
     */
    grader_id?: number | null;
    /**
     * URL to the submission. This will require the user to log in.
     */
    html_url?: string | null;
    /**
     * Whether the submission was made after the applicable due date
     */
    late?: boolean | null;
    /**
     * The status of the submission in relation to the late policy. Can be late, missing, none, or null.
     */
    late_policy_status?: string | null;
    /**
     * Whether the assignment is missing.
     */
    missing?: boolean | null;
    /**
     * The amount of points automatically deducted from the score by the missing/late policy for a late or missing assignment.
     */
    points_deducted?: number | null;
    /**
     * The date this submission was posted to the student, or nil if it has not been posted
     */
    posted_at?: string | null;
    /**
     * URL to the submission preview. This will require the user to log in.
     */
    preview_url?: string | null;
    /**
     * The read status of this submission for the given user (optional). Including read_status will mark submission(s) as read.
     */
    read_status?: string | null;
    /**
     * This indicates whether the submission has been reassigned by the instructor.
     */
    redo_request?: boolean | null;
    /**
     * The raw score
     */
    score?: number | null;
    /**
     * The amount of time, in seconds, that an submission is late by.
     */
    seconds_late?: number | null;
    /**
     * Associated comments for a submission (optional)
     */
    submission_comments?: Array<SubmissionComment> | null;
    /**
     * The types of submission ex: ('online_text_entry'|'online_url'|'online_upload'|'media_recording')
     */
    submission_type?: string | null;
    /**
     * The timestamp when the assignment was submitted
     */
    submitted_at?: string | null;
    /**
     * The URL of the submission (for 'online_url' submissions).
     */
    url?: string | null;
    /**
     * The submissions user (see user API) (optional)
     */
    user?: string | null;
    /**
     * The id of the user who created the submission
     */
    user_id?: number | null;
    /**
     * The current state of the submission
     */
    workflow_state?: string | null;
};

export type SubmissionNullable = {
    /**
     * A unique short ID identifying this submission without reference to the owning user. Only included if the caller has administrator access for the current account.
     */
    anonymous_id?: string | null;
    assignment?: AssignmentNullable;
    /**
     * The submission's assignment id
     */
    assignment_id?: number | null;
    /**
     * Whether the assignment is visible to the user who submitted the assignment. Submissions where `assignment_visible` is false no longer count towards the student's grade and the assignment can no longer be accessed by the student. `assignment_visible` becomes false for submissions that do not have a grade and whose assignment is no longer assigned to the student's section.
     */
    assignment_visible?: boolean | null;
    /**
     * This is the submission attempt number.
     */
    attempt?: number | null;
    /**
     * The content of the submission, if it was submitted directly in a text field.
     */
    body?: string | null;
    /**
     * The submission's course (see the course API) (optional)
     */
    course?: string | null;
    /**
     * Whether the assignment is excused.  Excused assignments have no impact on a user's grade.
     */
    excused?: boolean | null;
    /**
     * Extra submission attempts allowed fro the given user and assingment.
     */
    extra_attempts?: number | null;
    /**
     * The grade for the submission, translated into the assignment grading scheme (so a letter grade, for example).
     */
    grade?: string | null;
    /**
     * A boolean flag which is false if the student has re-submitted since the submission was last graded.
     */
    grade_matches_current_submission?: boolean | null;
    graded_at?: string | null;
    /**
     * The id of the user who graded the submission. This will be null for submissions that haven't been graded yet. It will be a positive number if a real user has graded the submission and a negative number if the submission was graded by a process (e.g. Quiz autograder and autograding LTI tools).  Specifically autograded quizzes set grader_id to the negative of the quiz id.  Submissions autograded by LTI tools set grader_id to the negative of the tool id.
     */
    grader_id?: number | null;
    /**
     * URL to the submission. This will require the user to log in.
     */
    html_url?: string | null;
    /**
     * Whether the submission was made after the applicable due date
     */
    late?: boolean | null;
    /**
     * The status of the submission in relation to the late policy. Can be late, missing, none, or null.
     */
    late_policy_status?: string | null;
    /**
     * Whether the assignment is missing.
     */
    missing?: boolean | null;
    /**
     * The amount of points automatically deducted from the score by the missing/late policy for a late or missing assignment.
     */
    points_deducted?: number | null;
    /**
     * The date this submission was posted to the student, or nil if it has not been posted
     */
    posted_at?: string | null;
    /**
     * URL to the submission preview. This will require the user to log in.
     */
    preview_url?: string | null;
    /**
     * The read status of this submission for the given user (optional). Including read_status will mark submission(s) as read.
     */
    read_status?: string | null;
    /**
     * This indicates whether the submission has been reassigned by the instructor.
     */
    redo_request?: boolean | null;
    /**
     * The raw score
     */
    score?: number | null;
    /**
     * The amount of time, in seconds, that an submission is late by.
     */
    seconds_late?: number | null;
    /**
     * Associated comments for a submission (optional)
     */
    submission_comments?: Array<SubmissionComment> | null;
    /**
     * The types of submission ex: ('online_text_entry'|'online_url'|'online_upload'|'media_recording')
     */
    submission_type?: string | null;
    /**
     * The timestamp when the assignment was submitted
     */
    submitted_at?: string | null;
    /**
     * The URL of the submission (for 'online_url' submissions).
     */
    url?: string | null;
    /**
     * The submissions user (see user API) (optional)
     */
    user?: string | null;
    /**
     * The id of the user who created the submission
     */
    user_id?: number | null;
    /**
     * The current state of the submission
     */
    workflow_state?: string | null;
} | null;

export type SubmissionComment = {
    author?: UserDisplay;
    author_id?: number | null;
    author_name?: string | null;
    comment?: string | null;
    created_at?: string | null;
    edited_at?: string | null;
    id?: number;
    media_comment?: MediaComment;
};

export type SubmissionHistory = {
    /**
     * the id of the submission
     */
    submission_id?: number | null;
    /**
     * an array of all the versions of this submission
     */
    versions?: Array<SubmissionVersion> | null;
};

/**
 * A SubmissionVersion object contains all the fields that a Submission object does, plus additional fields prefixed with current_* new_* and previous_* described below.
 */
export type SubmissionVersion = {
    /**
     * the id of the assignment this submissions is for
     */
    assignment_id?: number | null;
    /**
     * the name of the assignment this submission is for
     */
    assignment_name?: string | null;
    /**
     * the body text of the submission
     */
    body?: string | null;
    /**
     * the most up to date grade for the current version of this submission
     */
    current_grade?: string | null;
    /**
     * the latest time stamp for the grading of this submission
     */
    current_graded_at?: string | null;
    /**
     * the name of the most recent grader for this submission
     */
    current_grader?: string | null;
    /**
     * boolean indicating whether the grade is equal to the current submission grade
     */
    grade_matches_current_submission?: boolean | null;
    /**
     * time stamp for the grading of this version of the submission
     */
    graded_at?: string | null;
    /**
     * the name of the user who graded this version of the submission
     */
    grader?: string | null;
    /**
     * the user id of the user who graded this version of the submission
     */
    grader_id?: number | null;
    /**
     * the id of the submission of which this is a version
     */
    id?: number;
    /**
     * the updated grade provided in this version of the submission
     */
    new_grade?: string | null;
    /**
     * the timestamp for the grading of this version of the submission (alias for graded_at)
     */
    new_graded_at?: string | null;
    /**
     * alias for 'grader'
     */
    new_grader?: string | null;
    /**
     * the grade for the submission version immediately preceding this one
     */
    previous_grade?: string | null;
    /**
     * the timestamp for the grading of the submission version immediately preceding this one
     */
    previous_graded_at?: string | null;
    /**
     * the name of the grader who graded the version of this submission immediately preceding this one
     */
    previous_grader?: string | null;
    /**
     * the score for this version of the submission
     */
    score?: number | null;
    /**
     * the type of submission
     */
    submission_type?: string | null;
    /**
     * the url of the submission, if there is one
     */
    url?: string | null;
    /**
     * the user ID of the student who created this submission
     */
    user_id?: number | null;
    /**
     * the name of the student who created this submission
     */
    user_name?: string | null;
    /**
     * the state of the submission at this version
     */
    workflow_state?: string | null;
};

export type SuccessTrue = {
    success?: boolean | null;
};

export type Tab = {
    /**
     * only included if true
     */
    hidden?: boolean | null;
    html_url?: string | null;
    id?: string;
    label?: string | null;
    /**
     * 1 based
     */
    position?: number | null;
    type?: string | null;
    /**
     * possible values are: public, members, admins, and none
     */
    visibility?: string | null;
};

export type Term = {
    end_at?: string | null;
    id?: number;
    name?: string | null;
    start_at?: string | null;
} | null;

export type TermsOfService = {
    /**
     * The id of the root account that owns the Terms of Service
     */
    account_id?: number | null;
    /**
     * Content of the Terms of Service
     */
    content?: string | null;
    /**
     * Terms Of Service id
     */
    id?: number;
    /**
     * Boolean dictating if the user must accept Terms of Service
     */
    passive?: boolean | null;
    /**
     * The given type for the Terms of Service
     */
    terms_type?: 'default' | 'custom' | 'no_terms';
};

export type ToolSetting = {
    /**
     * the resource type code of the resource handler to use to display originality reports
     */
    resource_type_code?: string | null;
    /**
     * a URL that may be used to override the launch URL inferred by the specified resource_type_code. If used a 'resource_type_code' must also be specified.
     */
    resource_url?: string | null;
} | null;

export type TurnitinSettings = {
    exclude_biblio?: boolean | null;
    exclude_quoted?: boolean | null;
    exclude_small_matches_type?: string | null;
    exclude_small_matches_value?: number | null;
    internet_check?: boolean | null;
    journal_check?: boolean | null;
    originality_report_visibility?: string | null;
    s_paper_check?: boolean | null;
} | null;

/**
 * Describes the copyright and license information for a File
 */
export type UsageRights = {
    /**
     * List of ids of files that were updated
     */
    file_ids?: Array<number> | null;
    /**
     * Copyright line for the file
     */
    legal_copyright?: string | null;
    /**
     * License identifier for the file.
     */
    license?: string | null;
    /**
     * Readable license name
     */
    license_name?: string | null;
    /**
     * Explanation of the action performed
     */
    message?: string | null;
    /**
     * Justification for using the file in a Canvas course. Valid values are 'own_copyright', 'public_domain', 'used_by_permission', 'fair_use', 'creative_commons'
     */
    use_justification?: string | null;
};

/**
 * A Canvas user, e.g. a student, teacher, administrator, observer, etc.
 */
export type User = {
    /**
     * Optional If avatars are enabled and caller is admin, this field can be requested and will contain the current state of the user's avatar.
     */
    avatar_state?: string | null;
    /**
     * If avatars are enabled, this field will be included and contain a url to retrieve the user's avatar.
     */
    avatar_url?: string | null;
    /**
     * Optional: The user's bio.
     */
    bio?: string | null;
    /**
     * Optional: This field can be requested with certain API calls, and will return the users primary email address.
     */
    email?: string | null;
    /**
     * Optional: This field can be requested with certain API calls, and will return a list of the users active enrollments. See the List enrollments API for more details about the format of these records.
     */
    enrollments?: Array<Enrollment> | null;
    /**
     * The first name of the user.
     */
    first_name?: string | null;
    /**
     * The ID of the user.
     */
    id: number;
    /**
     * The integration_id associated with the user.  This field is only included if the user came from a SIS import and has permissions to view SIS information.
     */
    integration_id?: string | null;
    /**
     * Optional: This field is only returned in certain API calls, and will return a timestamp representing the last time the user logged in to canvas.
     */
    last_login?: string | null;
    /**
     * The last name of the user.
     */
    last_name?: string | null;
    /**
     * Optional: This field can be requested with certain API calls, and will return the users locale in RFC 5646 format.
     */
    locale?: string | null;
    /**
     * The unique login id for the user.  This is what the user uses to log in to Canvas.
     */
    login_id?: string | null;
    /**
     * The name of the user.
     */
    name?: string | null;
    /**
     * A short name the user has selected, for use in conversations or other less formal places through the site.
     */
    short_name?: string | null;
    /**
     * A list of the sections this user is part of in the courses they are part of.
     */
    sections?: string | null;
    /**
     * The id of the SIS import.  This field is only included if the user came from a SIS import and has permissions to manage SIS information.
     */
    sis_import_id?: number | null;
    /**
     * The SIS ID associated with the user.  This field is only included if the user came from a SIS import and has permissions to view SIS information.
     */
    sis_user_id?: string | null;
    /**
     * The name of the user that is should be used for sorting groups of users, such as in the gradebook.
     */
    sortable_name?: string | null;
    /**
     * Optional: This field is only returned in certain API calls, and will return the IANA time zone name of the user's preferred timezone.
     */
    time_zone?: string | null;
};

/**
 * A Canvas user, e.g. a student, teacher, administrator, observer, etc.
 */
export type UserNullable = {
    /**
     * Optional If avatars are enabled and caller is admin, this field can be requested and will contain the current state of the user's avatar.
     */
    avatar_state?: string | null;
    /**
     * If avatars are enabled, this field will be included and contain a url to retrieve the user's avatar.
     */
    avatar_url?: string | null;
    /**
     * Optional: The user's bio.
     */
    bio?: string | null;
    /**
     * Optional: This field can be requested with certain API calls, and will return the users primary email address.
     */
    email?: string | null;
    /**
     * Optional: This field can be requested with certain API calls, and will return a list of the users active enrollments. See the List enrollments API for more details about the format of these records.
     */
    enrollments?: Array<Enrollment> | null;
    /**
     * The first name of the user.
     */
    first_name?: string | null;
    /**
     * The ID of the user.
     */
    id: number;
    /**
     * The integration_id associated with the user.  This field is only included if the user came from a SIS import and has permissions to view SIS information.
     */
    integration_id?: string | null;
    /**
     * Optional: This field is only returned in certain API calls, and will return a timestamp representing the last time the user logged in to canvas.
     */
    last_login?: string | null;
    /**
     * The last name of the user.
     */
    last_name?: string | null;
    /**
     * Optional: This field can be requested with certain API calls, and will return the users locale in RFC 5646 format.
     */
    locale?: string | null;
    /**
     * The unique login id for the user.  This is what the user uses to log in to Canvas.
     */
    login_id?: string | null;
    /**
     * The name of the user.
     */
    name?: string | null;
    /**
     * A short name the user has selected, for use in conversations or other less formal places through the site.
     */
    short_name?: string | null;
    /**
     * A list of the sections this user is part of in the courses they are part of.
     */
    sections?: string | null;
    /**
     * The id of the SIS import.  This field is only included if the user came from a SIS import and has permissions to manage SIS information.
     */
    sis_import_id?: number | null;
    /**
     * The SIS ID associated with the user.  This field is only included if the user came from a SIS import and has permissions to view SIS information.
     */
    sis_user_id?: string | null;
    /**
     * The name of the user that is should be used for sorting groups of users, such as in the gradebook.
     */
    sortable_name?: string | null;
    /**
     * Optional: This field is only returned in certain API calls, and will return the IANA time zone name of the user's preferred timezone.
     */
    time_zone?: string | null;
} | null;

/**
 * Abbreviated user object UserDisplay (see users API).
 */
export type UserDisplay = {
    id?: number | null;
    anonymous_id?: string | null;
    display_name?: string | null;
    avatar_image_url?: string | null;
    /**
     * The pronouns set on the profile (as of 12/02/2023 this is not in the API specification, but is returned with a profile call)
     */
    pronouns?: string | null;
} | null;

/**
 * Canvas user data provided in a section via include=['students']
 */
export type UserSectionInclude = {
    /**
     * The time at which this user was originally created
     */
    created_at?: string | null;
    /**
     * The ID of the user.
     */
    id: number;
    /**
     * The integration_id associated with the user.  This field is only included if the user came from a SIS import and has permissions to view SIS information.
     */
    integration_id?: string | null;
    /**
     * The unique login id for the user.  This is what the user uses to log in to Canvas.
     */
    login_id?: string | null;
    /**
     * The name of the user.
     */
    name?: string | null;
    /**
     * A short name the user has selected, for use in conversations or other less formal places through the site.
     */
    short_name?: string | null;
    /**
     * The id of the SIS import.  This field is only included if the user came from a SIS import and has permissions to manage SIS information.
     */
    sis_import_id?: number | null;
    /**
     * The SIS ID associated with the user.  This field is only included if the user came from a SIS import and has permissions to view SIS information.
     */
    sis_user_id?: string | null;
    /**
     * The name of the user that is should be used for sorting groups of users, such as in the gradebook.
     */
    sortable_name?: string | null;
};

/**
 * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
 */
export type PageParam = string;

/**
 * The numbers of items to return.
 */
export type PerPageParam = number;

export type GetSingleAssignmentLtiData = {
    body?: never;
    path: {
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * The id of the user. Can be a Canvas or LTI id for the user.
         */
        user_id?: string;
    };
    url: '/lti/assignments/{assignment_id}';
};

export type GetSingleAssignmentLtiResponses = {
    /**
     * No response was specified
     */
    200: LtiAssignment;
};

export type GetSingleAssignmentLtiResponse = GetSingleAssignmentLtiResponses[keyof GetSingleAssignmentLtiResponses];

export type ShowOriginalityReportFilesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        file_id: string;
    };
    query?: never;
    url: '/lti/assignments/{assignment_id}/files/{file_id}/originality_report';
};

export type ShowOriginalityReportFilesResponses = {
    /**
     * No response was specified
     */
    200: OriginalityReport;
};

export type ShowOriginalityReportFilesResponse = ShowOriginalityReportFilesResponses[keyof ShowOriginalityReportFilesResponses];

export type EditOriginalityReportFilesData = {
    body?: {
        /**
         * The ID of the file within Canvas that contains the originality
         * report for the submitted file provided in the request URL.
         */
        'originality_report[originality_report_file_id]'?: number;
        /**
         * The URL where the originality report for the specified
         * file may be found.
         */
        'originality_report[originality_report_url]'?: string;
        /**
         * A number between 0 and 100 representing the measure of the
         * specified file's originality.
         */
        'originality_report[originality_score]'?: number;
        /**
         * The resource type code of the resource handler Canvas should use for the
         * LTI launch for viewing originality reports. If set Canvas will launch
         * to the message with type 'basic-lti-launch-request' in the specified
         * resource handler rather than using the originality_report_url.
         */
        'originality_report[tool_setting][resource_type_code]'?: string;
        /**
         * The URL Canvas should launch to when showing an LTI originality report.
         * Note that this value is inferred from the specified resource handler's
         * message "path" value (See `resource_type_code`) unless
         * it is specified. If this parameter is used a `resource_type_code`
         * must also be specified.
         */
        'originality_report[tool_setting][resource_url]'?: string;
        /**
         * May be set to "pending", "error", or "scored". If an originality score
         * is provided a workflow state of "scored" will be inferred.
         */
        'originality_report[workflow_state]'?: string;
    };
    path: {
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        file_id: string;
    };
    query?: never;
    url: '/lti/assignments/{assignment_id}/files/{file_id}/originality_report';
};

export type EditOriginalityReportFilesResponses = {
    /**
     * No response was specified
     */
    200: OriginalityReport;
};

export type EditOriginalityReportFilesResponse = EditOriginalityReportFilesResponses[keyof EditOriginalityReportFilesResponses];

export type GetSingleSubmissionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        submission_id: string;
    };
    query?: never;
    url: '/lti/assignments/{assignment_id}/submissions/{submission_id}';
};

export type GetSingleSubmissionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetHistoryOfSingleSubmissionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        submission_id: string;
    };
    query?: never;
    url: '/lti/assignments/{assignment_id}/submissions/{submission_id}/history';
};

export type GetHistoryOfSingleSubmissionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateOriginalityReportData = {
    body: {
        /**
         * The id of the file being given an originality score. Required
         * if creating a report associated with a file.
         */
        'originality_report[file_id]'?: number;
        /**
         * The ID of the file within Canvas that contains the originality
         * report for the submitted file provided in the request URL.
         */
        'originality_report[originality_report_file_id]'?: number;
        /**
         * The URL where the originality report for the specified
         * file may be found.
         */
        'originality_report[originality_report_url]'?: string;
        /**
         * A number between 0 and 100 representing the measure of the
         * specified file's originality.
         */
        'originality_report[originality_score]': number;
        /**
         * The resource type code of the resource handler Canvas should use for the
         * LTI launch for viewing originality reports. If set Canvas will launch
         * to the message with type 'basic-lti-launch-request' in the specified
         * resource handler rather than using the originality_report_url.
         */
        'originality_report[tool_setting][resource_type_code]'?: string;
        /**
         * The URL Canvas should launch to when showing an LTI originality report.
         * Note that this value is inferred from the specified resource handler's
         * message "path" value (See `resource_type_code`) unless
         * it is specified. If this parameter is used a `resource_type_code`
         * must also be specified.
         */
        'originality_report[tool_setting][resource_url]'?: string;
        /**
         * May be set to "pending", "error", or "scored". If an originality score
         * is provided a workflow state of "scored" will be inferred.
         */
        'originality_report[workflow_state]'?: string;
    };
    path: {
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        submission_id: string;
    };
    query?: never;
    url: '/lti/assignments/{assignment_id}/submissions/{submission_id}/originality_report';
};

export type CreateOriginalityReportResponses = {
    /**
     * No response was specified
     */
    200: OriginalityReport;
};

export type CreateOriginalityReportResponse = CreateOriginalityReportResponses[keyof CreateOriginalityReportResponses];

export type ShowOriginalityReportSubmissionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        submission_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/lti/assignments/{assignment_id}/submissions/{submission_id}/originality_report/{id}';
};

export type ShowOriginalityReportSubmissionsResponses = {
    /**
     * No response was specified
     */
    200: OriginalityReport;
};

export type ShowOriginalityReportSubmissionsResponse = ShowOriginalityReportSubmissionsResponses[keyof ShowOriginalityReportSubmissionsResponses];

export type EditOriginalityReportSubmissionsData = {
    body?: {
        /**
         * The ID of the file within Canvas that contains the originality
         * report for the submitted file provided in the request URL.
         */
        'originality_report[originality_report_file_id]'?: number;
        /**
         * The URL where the originality report for the specified
         * file may be found.
         */
        'originality_report[originality_report_url]'?: string;
        /**
         * A number between 0 and 100 representing the measure of the
         * specified file's originality.
         */
        'originality_report[originality_score]'?: number;
        /**
         * The resource type code of the resource handler Canvas should use for the
         * LTI launch for viewing originality reports. If set Canvas will launch
         * to the message with type 'basic-lti-launch-request' in the specified
         * resource handler rather than using the originality_report_url.
         */
        'originality_report[tool_setting][resource_type_code]'?: string;
        /**
         * The URL Canvas should launch to when showing an LTI originality report.
         * Note that this value is inferred from the specified resource handler's
         * message "path" value (See `resource_type_code`) unless
         * it is specified. If this parameter is used a `resource_type_code`
         * must also be specified.
         */
        'originality_report[tool_setting][resource_url]'?: string;
        /**
         * May be set to "pending", "error", or "scored". If an originality score
         * is provided a workflow state of "scored" will be inferred.
         */
        'originality_report[workflow_state]'?: string;
    };
    path: {
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        submission_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/lti/assignments/{assignment_id}/submissions/{submission_id}/originality_report/{id}';
};

export type EditOriginalityReportSubmissionsResponses = {
    /**
     * No response was specified
     */
    200: OriginalityReport;
};

export type EditOriginalityReportSubmissionsResponse = EditOriginalityReportSubmissionsResponses[keyof EditOriginalityReportSubmissionsResponses];

export type GetAllUsersInGroupLtiData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/lti/groups/{group_id}/users';
};

export type GetAllUsersInGroupLtiResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type GetAllUsersInGroupLtiResponse = GetAllUsersInGroupLtiResponses[keyof GetAllUsersInGroupLtiResponses];

export type ListAllWebhookSubscriptionForToolProxyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/lti/subscriptions';
};

export type ListAllWebhookSubscriptionForToolProxyResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateWebhookSubscriptionData = {
    body: {
        /**
         * The id of the context for the subscription.
         */
        'submission[ContextId]': string;
        /**
         * The type of context for the subscription. Must be 'assignment',
         * 'account', or 'course'.
         */
        'subscription[ContextType]': string;
        /**
         * Array of strings representing the event types for
         * the subscription.
         */
        'subscription[EventTypes]': Array<string>;
        /**
         * Format to deliver the live events. Must be 'live-event' or 'caliper'.
         */
        'subscription[Format]': string;
        /**
         * An object with a single key: 'Url'. Example: { "Url": "sqs.example" }
         */
        'subscription[TransportMetadata]': {
            [key: string]: unknown;
        };
        /**
         * Must be either 'sqs' or 'https'.
         */
        'subscription[TransportType]': string;
    };
    path?: never;
    query?: never;
    url: '/lti/subscriptions';
};

export type CreateWebhookSubscriptionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteWebhookSubscriptionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/lti/subscriptions/{id}';
};

export type DeleteWebhookSubscriptionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ShowSingleWebhookSubscriptionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/lti/subscriptions/{id}';
};

export type ShowSingleWebhookSubscriptionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateWebhookSubscriptionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/lti/subscriptions/{id}';
};

export type UpdateWebhookSubscriptionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleUserLtiData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/lti/users/{id}';
};

export type GetSingleUserLtiResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type GetSingleUserLtiResponse = GetSingleUserLtiResponses[keyof GetSingleUserLtiResponses];

export type RetrieveAssignmentsEnabledForGradeExportToSisAccountsData = {
    body?: never;
    path: {
        /**
         * The ID of the account to query.
         */
        account_id: number;
    };
    query?: {
        /**
         * The ID of the course to query.
         */
        course_id?: number;
        /**
         * When searching on an account,
         */
        starts_before?: string;
        /**
         * When searching on an account,
         */
        ends_after?: string;
        /**
         * Array of additional
         */
        include?: 'student_overrides';
    };
    url: '/sis/accounts/{account_id}/assignments';
};

export type RetrieveAssignmentsEnabledForGradeExportToSisAccountsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type RetrieveAssignmentsEnabledForGradeExportToSisCoursesData = {
    body?: never;
    path: {
        /**
         * The ID of the course to query.
         */
        course_id: number;
    };
    query?: {
        /**
         * The ID of the account to query.
         */
        account_id?: number;
        /**
         * When searching on an account,
         */
        starts_before?: string;
        /**
         * When searching on an account,
         */
        ends_after?: string;
        /**
         * Array of additional
         */
        include?: 'student_overrides';
    };
    url: '/sis/courses/{course_id}/assignments';
};

export type RetrieveAssignmentsEnabledForGradeExportToSisCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DisableAssignmentsCurrentlyEnabledForGradeExportToSisData = {
    body?: {
        /**
         * The ID of the grading period.
         */
        grading_period_id?: number;
    };
    path: {
        /**
         * The ID of the course.
         */
        course_id: number;
    };
    query?: never;
    url: '/sis/courses/{course_id}/disable_post_to_sis';
};

export type DisableAssignmentsCurrentlyEnabledForGradeExportToSisResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListAccountsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Array of additional information to include.
         *
         * "lti_guid":: the 'tool_consumer_instance_guid' that will be sent for this account on LTI launches
         * "registration_settings":: returns info about the privacy policy and terms of use
         * "services":: returns services and whether they are enabled (requires account management permissions)
         */
        include?: Array<'lti_guid' | 'registration_settings' | 'services'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts';
};

export type ListAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<Account>;
};

export type ListAccountsResponse = ListAccountsResponses[keyof ListAccountsResponses];

export type SearchAccountDomainsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * campus name
         */
        name?: string;
        /**
         * no description
         */
        domain?: string;
        /**
         * no description
         */
        latitude?: number;
        /**
         * no description
         */
        longitude?: number;
    };
    url: '/v1/accounts/search';
};

export type SearchAccountDomainsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type IndexOfActiveGlobalNotificationForUserData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/account_notifications';
};

export type IndexOfActiveGlobalNotificationForUserResponses = {
    /**
     * No response was specified
     */
    200: Array<AccountNotification>;
};

export type IndexOfActiveGlobalNotificationForUserResponse = IndexOfActiveGlobalNotificationForUserResponses[keyof IndexOfActiveGlobalNotificationForUserResponses];

export type CreateGlobalNotificationData = {
    body: {
        /**
         * The end date and time of the notification in ISO8601 format.
         * e.g. 2014-01-01T01:00Z
         */
        'account_notification[end_at]': string;
        /**
         * The icon to display with the notification.
         * Note: Defaults to warning.
         */
        'account_notification[icon]'?: 'warning' | 'information' | 'question' | 'error' | 'calendar';
        /**
         * The message body of the notification.
         */
        'account_notification[message]': string;
        /**
         * The start date and time of the notification in ISO8601 format.
         * e.g. 2014-01-01T01:00Z
         */
        'account_notification[start_at]': string;
        /**
         * The subject of the notification.
         */
        'account_notification[subject]': string;
        /**
         * The role(s) to send global notification to.  Note:  ommitting this field will send to everyone
         * Example:
         * account_notification_roles: ["StudentEnrollment", "TeacherEnrollment"]
         */
        account_notification_roles?: Array<string>;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/account_notifications';
};

export type CreateGlobalNotificationResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CloseNotificationForUserData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/account_notifications/{id}';
};

export type CloseNotificationForUserResponses = {
    /**
     * No response was specified
     */
    200: AccountNotification;
};

export type CloseNotificationForUserResponse = CloseNotificationForUserResponses[keyof CloseNotificationForUserResponses];

export type ShowGlobalNotificationData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/account_notifications/{id}';
};

export type ShowGlobalNotificationResponses = {
    /**
     * No response was specified
     */
    200: AccountNotification;
};

export type ShowGlobalNotificationResponse = ShowGlobalNotificationResponses[keyof ShowGlobalNotificationResponses];

export type UpdateGlobalNotificationData = {
    body?: {
        /**
         * The end date and time of the notification in ISO8601 format.
         * e.g. 2014-01-01T01:00Z
         */
        'account_notification[end_at]'?: string;
        /**
         * The icon to display with the notification.
         */
        'account_notification[icon]'?: 'warning' | 'information' | 'question' | 'error' | 'calendar';
        /**
         * The message body of the notification.
         */
        'account_notification[message]'?: string;
        /**
         * The start date and time of the notification in ISO8601 format.
         * e.g. 2014-01-01T01:00Z
         */
        'account_notification[start_at]'?: string;
        /**
         * The subject of the notification.
         */
        'account_notification[subject]'?: string;
        /**
         * The role(s) to send global notification to.  Note:  ommitting this field will send to everyone
         * Example:
         * account_notification_roles: ["StudentEnrollment", "TeacherEnrollment"]
         */
        account_notification_roles?: Array<string>;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/account_notifications/{id}';
};

export type UpdateGlobalNotificationResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListAccountAdminsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * Scope the results to those with user IDs equal to any of the IDs specified here.
         */
        user_id?: string;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/admins';
};

export type ListAccountAdminsResponses = {
    /**
     * No response was specified
     */
    200: Array<Admin>;
};

export type ListAccountAdminsResponse = ListAccountAdminsResponses[keyof ListAccountAdminsResponses];

export type MakeAccountAdminData = {
    body: {
        /**
         * [DEPRECATED] The user's admin relationship with the account will be
         * created with the given role. Defaults to 'AccountAdmin'.
         */
        role?: string;
        /**
         * The user's admin relationship with the account will be created with the
         * given role. Defaults to the built-in role for 'AccountAdmin'.
         */
        role_id?: number;
        /**
         * Send a notification email to
         * the new admin if true. Default is true.
         */
        send_confirmation?: boolean;
        /**
         * The id of the user to promote.
         */
        user_id: number;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/admins';
};

export type MakeAccountAdminResponses = {
    /**
     * No response was specified
     */
    200: Admin;
};

export type MakeAccountAdminResponse = MakeAccountAdminResponses[keyof MakeAccountAdminResponses];

export type RemoveAccountAdminData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * [DEPRECATED] Account role to remove from the user. Defaults to
         * 'AccountAdmin'. Any other account role must be specified explicitly.
         */
        role?: string;
        /**
         * The user's admin relationship with the account will be created with the
         * given role. Defaults to the built-in role for 'AccountAdmin'.
         */
        role_id?: number;
    };
    url: '/v1/accounts/{account_id}/admins/{user_id}';
};

export type RemoveAccountAdminResponses = {
    /**
     * No response was specified
     */
    200: Admin;
};

export type RemoveAccountAdminResponse = RemoveAccountAdminResponses[keyof RemoveAccountAdminResponses];

export type GetDepartmentLevelParticipationDataCompletedData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/analytics/completed/activity';
};

export type GetDepartmentLevelParticipationDataCompletedResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetDepartmentLevelGradeDataCompletedData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/analytics/completed/grades';
};

export type GetDepartmentLevelGradeDataCompletedResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetDepartmentLevelStatisticsCompletedData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/analytics/completed/statistics';
};

export type GetDepartmentLevelStatisticsCompletedResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetDepartmentLevelParticipationDataCurrentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/analytics/current/activity';
};

export type GetDepartmentLevelParticipationDataCurrentResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetDepartmentLevelGradeDataCurrentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/analytics/current/grades';
};

export type GetDepartmentLevelGradeDataCurrentResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetDepartmentLevelStatisticsCurrentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/analytics/current/statistics';
};

export type GetDepartmentLevelStatisticsCurrentResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetDepartmentLevelParticipationDataTermsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        term_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/analytics/terms/{term_id}/activity';
};

export type GetDepartmentLevelParticipationDataTermsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetDepartmentLevelGradeDataTermsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        term_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/analytics/terms/{term_id}/grades';
};

export type GetDepartmentLevelGradeDataTermsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetDepartmentLevelStatisticsTermsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        term_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/analytics/terms/{term_id}/statistics';
};

export type GetDepartmentLevelStatisticsTermsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListAuthenticationProvidersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/authentication_providers';
};

export type ListAuthenticationProvidersResponses = {
    /**
     * No response was specified
     */
    200: Array<AuthenticationProvider>;
};

export type ListAuthenticationProvidersResponse = ListAuthenticationProvidersResponses[keyof ListAuthenticationProvidersResponses];

export type AddAuthenticationProviderData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/authentication_providers';
};

export type AddAuthenticationProviderResponses = {
    /**
     * No response was specified
     */
    200: AuthenticationProvider;
};

export type AddAuthenticationProviderResponse = AddAuthenticationProviderResponses[keyof AddAuthenticationProviderResponses];

export type DeleteAuthenticationProviderData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/authentication_providers/{id}';
};

export type DeleteAuthenticationProviderResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetAuthenticationProviderData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/authentication_providers/{id}';
};

export type GetAuthenticationProviderResponses = {
    /**
     * No response was specified
     */
    200: AuthenticationProvider;
};

export type GetAuthenticationProviderResponse = GetAuthenticationProviderResponses[keyof GetAuthenticationProviderResponses];

export type UpdateAuthenticationProviderData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/authentication_providers/{id}';
};

export type UpdateAuthenticationProviderResponses = {
    /**
     * No response was specified
     */
    200: AuthenticationProvider;
};

export type UpdateAuthenticationProviderResponse = UpdateAuthenticationProviderResponses[keyof UpdateAuthenticationProviderResponses];

export type ListContentMigrationsAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/content_migrations';
};

export type ListContentMigrationsAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<ContentMigration>;
};

export type ListContentMigrationsAccountsResponse = ListContentMigrationsAccountsResponses[keyof ListContentMigrationsAccountsResponses];

export type CreateContentMigrationAccountsData = {
    body: {
        /**
         * Move anything scheduled for day 'X' to the specified day. (0-Sunday,
         * 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
         */
        'date_shift_options[day_substitutions][X]'?: number;
        /**
         * The new end date for the source content/course
         */
        'date_shift_options[new_end_date]'?: string;
        /**
         * The new start date for the content/course
         */
        'date_shift_options[new_start_date]'?: string;
        /**
         * The original end date of the source content/course
         */
        'date_shift_options[old_end_date]'?: string;
        /**
         * The original start date of the source content/course
         */
        'date_shift_options[old_start_date]'?: string;
        /**
         * Whether to remove dates in the copied course. Cannot be used
         * in conjunction with *shift_dates*.
         */
        'date_shift_options[remove_dates]'?: boolean;
        /**
         * Whether to shift dates in the copied course
         */
        'date_shift_options[shift_dates]'?: boolean;
        /**
         * The type of the migration. Use the
         * {api:ContentMigrationsController#available_migrators Migrator} endpoint to
         * see all available migrators. Default allowed values:
         * canvas_cartridge_importer, common_cartridge_importer,
         * course_copy_importer, zip_file_importer, qti_converter, moodle_converter
         */
        migration_type: string;
        /**
         * Required if uploading a file. This is the first step in uploading a file
         * to the content migration. See the {file:file_uploads.html File Upload
         * Documentation} for details on the file upload workflow.
         */
        'pre_attachment[name]'?: string;
        /**
         * Other file upload properties, See {file:file_uploads.html File Upload
         * Documentation}
         */
        'pre_attachment[todo]'?: string;
        /**
         * A URL to download the file from. Must not require authentication.
         */
        'settings[file_url]'?: string;
        /**
         * The folder to unzip the .zip file into for a zip_file_import.
         */
        'settings[folder_id]'?: string;
        /**
         * Whether to overwrite quizzes with the same identifiers between content
         * packages.
         */
        'settings[overwrite_quizzes]'?: boolean;
        /**
         * The existing question bank ID to import questions into if not specified in
         * the content package.
         */
        'settings[question_bank_id]'?: number;
        /**
         * The question bank to import questions into if not specified in the content
         * package, if both bank id and name are set, id will take precedence.
         */
        'settings[question_bank_name]'?: string;
        /**
         * The course to copy from for a course copy migration. (required if doing
         * course copy)
         */
        'settings[source_course_id]'?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/content_migrations';
};

export type CreateContentMigrationAccountsResponses = {
    /**
     * No response was specified
     */
    200: ContentMigration;
};

export type CreateContentMigrationAccountsResponse = CreateContentMigrationAccountsResponses[keyof CreateContentMigrationAccountsResponses];

export type ListMigrationSystemsAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/content_migrations/migrators';
};

export type ListMigrationSystemsAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<Migrator>;
};

export type ListMigrationSystemsAccountsResponse = ListMigrationSystemsAccountsResponses[keyof ListMigrationSystemsAccountsResponses];

export type ListMigrationIssuesAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        content_migration_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/content_migrations/{content_migration_id}/migration_issues';
};

export type ListMigrationIssuesAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<MigrationIssue>;
};

export type ListMigrationIssuesAccountsResponse = ListMigrationIssuesAccountsResponses[keyof ListMigrationIssuesAccountsResponses];

export type GetMigrationIssueAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        content_migration_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/content_migrations/{content_migration_id}/migration_issues/{id}';
};

export type GetMigrationIssueAccountsResponses = {
    /**
     * No response was specified
     */
    200: MigrationIssue;
};

export type GetMigrationIssueAccountsResponse = GetMigrationIssueAccountsResponses[keyof GetMigrationIssueAccountsResponses];

export type UpdateMigrationIssueAccountsData = {
    body: {
        /**
         * Set the workflow_state of the issue.
         */
        workflow_state: 'active' | 'resolved';
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        content_migration_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/content_migrations/{content_migration_id}/migration_issues/{id}';
};

export type UpdateMigrationIssueAccountsResponses = {
    /**
     * No response was specified
     */
    200: MigrationIssue;
};

export type UpdateMigrationIssueAccountsResponse = UpdateMigrationIssueAccountsResponses[keyof UpdateMigrationIssueAccountsResponses];

export type GetContentMigrationAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/content_migrations/{id}';
};

export type GetContentMigrationAccountsResponses = {
    /**
     * No response was specified
     */
    200: ContentMigration;
};

export type GetContentMigrationAccountsResponse = GetContentMigrationAccountsResponses[keyof GetContentMigrationAccountsResponses];

export type UpdateContentMigrationAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/content_migrations/{id}';
};

export type UpdateContentMigrationAccountsResponses = {
    /**
     * No response was specified
     */
    200: ContentMigration;
};

export type UpdateContentMigrationAccountsResponse = UpdateContentMigrationAccountsResponses[keyof UpdateContentMigrationAccountsResponses];

export type GetAllCoursesAccountsData = {
    body?: never;
    path: {
        /**
         * The ID of the account
         */
        account_id: string;
    };
    query?: {
        /**
         * Filter courses by enrollment status
         */
        with_enrollments?: boolean;
        'enrollment_type[]'?: Array<'teacher' | 'student' | 'ta' | 'observer' | 'designer'>;
        /**
         * If true, include only published courses. If false, exclude published courses. If not present, do not filter on published status.
         */
        published?: boolean;
        /**
         * If true, include only completed courses (these may be in state completed, or their enrollment term may have ended). If false, exclude completed courses. If not present, do not filter on completed status.
         */
        completed?: boolean;
        /**
         * If true, include only blueprint courses. If false, exclude them. Ifnot present, do not filter on this basis.
         */
        blueprint?: boolean;
        /**
         * If true, include only courses that inherit content from a blueprint course. If false, exclude them. If not present, do not filter on this basis.
         */
        blueprint_associated?: boolean;
        /**
         * If true, include only public courses. If false, exclude them. If not present, do not filter on this basis.
         */
        public?: boolean;
        /**
         * List of User IDs of teachers; if supplied, include only courses taught by one of the referenced users.
         */
        'by_teachers[]'?: Array<number>;
        /**
         * List of Account IDs; if supplied, include only courses associated with one of the referenced subaccounts
         */
        'by_subaccounts[]'?: Array<number>;
        /**
         * If present, only return courses that have at least one enrollment. Equivalent to with_enrollments=true; retained for compatibility.
         */
        hide_enrollmentless_courses?: boolean;
        /**
         * If set, only return courses that are in the given state(s). By default, all states but deleted are returned.
         */
        'state[]'?: Array<'created' | 'claimed' | 'available' | 'completed' | 'deleted' | 'all'>;
        /**
         * If set, only includes courses from the specified term.
         */
        enrollment_term_id?: number;
        /**
         * The partial course name, code, or full ID to match and return in the results list. Must be at least 3 characters.
         */
        search_term?: string;
        /**
         * All explanations can be seen in the Course API index documentation
         */
        'include[]'?: Array<'syllabus_body' | 'term' | 'course_progress' | 'storage_quota_used_mb' | 'total_students' | 'teachers' | 'account_name' | 'concluded' | 'post_manually'>;
        /**
         * The column to sort results by.
         */
        sort?: 'course_status' | 'course_name' | 'sis_course_id' | 'teacher' | 'account_name';
        /**
         * The order to sort the given column by.
         */
        order?: 'asc' | 'desc';
        /**
         * The filter to search by. course searches for course names, course codes, and SIS IDs. teacher searches for teacher names
         */
        search_by?: 'course' | 'teacher';
        /**
         * If set, only return courses that start before the value (inclusive) or their enrollment term starts before the value (inclusive) or both the courses start_at and the enrollment terms start_at are set to null. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         */
        starts_before?: string;
        /**
         * If set, only return courses that end after the value (inclusive) or their enrollment term ends after the value (inclusive) or both the courses end_at and the enrollment terms end_at are set to null. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         */
        ends_after?: string;
        /**
         * If set, only return homeroom courses.
         */
        homeroom?: boolean;
    };
    url: '/v1/accounts/{account_id}/courses';
};

export type GetAllCoursesAccountsResponses = {
    /**
     * A list of courses
     */
    200: Array<Course>;
};

export type GetAllCoursesAccountsResponse = GetAllCoursesAccountsResponses[keyof GetAllCoursesAccountsResponses];

export type CreateNewCourseData = {
    body?: {
        /**
         * If true, students can attach files to forum posts.
         */
        'course[allow_student_forum_attachments]'?: boolean;
        /**
         * If true, students will be able to modify the course wiki.
         */
        'course[allow_student_wiki_edits]'?: boolean;
        /**
         * If true, course members will be able to comment on wiki pages.
         */
        'course[allow_wiki_comments]'?: boolean;
        /**
         * Set to true to weight final grade based on assignment groups percentages.
         */
        'course[apply_assignment_group_weights]'?: boolean;
        /**
         * The course code for the course.
         */
        'course[course_code]'?: string;
        /**
         * Optional. Specifies the format of the course. (Should be 'on_campus', 'online', or 'blended')
         */
        'course[course_format]'?: string;
        /**
         * The type of page that users will see when they first visit the course
         * * 'feed' Recent Activity Dashboard
         * * 'modules' Course Modules/Sections Page
         * * 'assignments' Course Assignments List
         * * 'syllabus' Course Syllabus Page
         * other types may be added in the future
         */
        'course[default_view]'?: 'feed' | 'wiki' | 'modules' | 'syllabus' | 'assignments';
        /**
         * Course end date in ISO8601 format. e.g. 2011-01-01T01:00Z
         */
        'course[end_at]'?: string;
        /**
         * The grading standard id to set for the course.  If no value is provided for this argument the current grading_standard will be un-set from this course.
         */
        'course[grading_standard_id]'?: number;
        /**
         * If this option is set to true, the totals in student grades summary will
         * be hidden.
         */
        'course[hide_final_grades]'?: boolean;
        /**
         * The unique Integration identifier.
         */
        'course[integration_id]'?: string;
        /**
         * Set to true if course is public to both authenticated and unauthenticated users.
         */
        'course[is_public]'?: boolean;
        /**
         * Set to true if course is public only to authenticated users.
         */
        'course[is_public_to_auth_users]'?: boolean;
        /**
         * The name of the licensing. Should be one of the following abbreviations
         * (a descriptive name is included in parenthesis for reference):
         * - 'private' (Private Copyrighted)
         * - 'cc_by_nc_nd' (CC Attribution Non-Commercial No Derivatives)
         * - 'cc_by_nc_sa' (CC Attribution Non-Commercial Share Alike)
         * - 'cc_by_nc' (CC Attribution Non-Commercial)
         * - 'cc_by_nd' (CC Attribution No Derivatives)
         * - 'cc_by_sa' (CC Attribution Share Alike)
         * - 'cc_by' (CC Attribution)
         * - 'public_domain' (Public Domain).
         */
        'course[license]'?: string;
        /**
         * The name of the course. If omitted, the course will be named "Unnamed
         * Course."
         */
        'course[name]'?: string;
        /**
         * Set to true if the course is open enrollment.
         */
        'course[open_enrollment]'?: boolean;
        /**
         * A publicly visible description of the course.
         */
        'course[public_description]'?: string;
        /**
         * Set to true to make the course syllabus public.
         */
        'course[public_syllabus]'?: boolean;
        /**
         * Set to true to make the course syllabus public for authenticated users.
         */
        'course[public_syllabus_to_auth]'?: boolean;
        /**
         * Set to true to restrict user enrollments to the start and end dates of the
         * course.
         */
        'course[restrict_enrollments_to_course_dates]'?: boolean;
        /**
         * Set to true if the course is self enrollment.
         */
        'course[self_enrollment]'?: boolean;
        /**
         * The unique SIS identifier.
         */
        'course[sis_course_id]'?: string;
        /**
         * Course start date in ISO8601 format, e.g. 2011-01-01T01:00Z
         */
        'course[start_at]'?: string;
        /**
         * The syllabus body for the course
         */
        'course[syllabus_body]'?: string;
        /**
         * The unique ID of the term to create to course in.
         */
        'course[term_id]'?: number;
        /**
         * The time zone for the course. Allowed time zones are
         * {http://www.iana.org/time-zones IANA time zones} or friendlier
         * {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
         */
        'course[time_zone]'?: string;
        /**
         * When true, will first try to re-activate a deleted course with matching sis_course_id if possible.
         */
        enable_sis_reactivation?: boolean;
        /**
         * Set to true to enroll the current user as the teacher.
         */
        enroll_me?: boolean;
        /**
         * If this option is set to true, the course will be available to students
         * immediately.
         */
        offer?: boolean;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/courses';
};

export type CreateNewCourseResponses = {
    /**
     * No response was specified
     */
    200: Course;
};

export type CreateNewCourseResponse = CreateNewCourseResponses[keyof CreateNewCourseResponses];

export type UpdateCoursesData = {
    body: {
        /**
         * List of ids of courses to update. At most 500 courses may be updated in one call.
         */
        course_ids: Array<string>;
        /**
         * no description
         */
        event: 'offer' | 'conclude' | 'delete' | 'undelete';
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/courses';
};

export type UpdateCoursesResponses = {
    /**
     * No response was specified
     */
    200: Progress;
};

export type UpdateCoursesResponse = UpdateCoursesResponses[keyof UpdateCoursesResponses];

export type GetSingleCourseAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * - "all_courses": Also search recently deleted courses.
         * - "permissions": Include permissions the current user has
         * for the course.
         * - "observed_users": include observed users in the enrollments
         * - "course_image": Optional course image data for when there is a course image
         * and the course image feature flag has been enabled
         */
        include?: Array<'needs_grading_count' | 'syllabus_body' | 'public_description' | 'total_scores' | 'current_grading_period_scores' | 'term' | 'account' | 'course_progress' | 'sections' | 'storage_quota_used_mb' | 'total_students' | 'passback_status' | 'favorites' | 'teachers' | 'observed_users' | 'all_courses' | 'permissions' | 'course_image'>;
    };
    url: '/v1/accounts/{account_id}/courses/{id}';
};

export type GetSingleCourseAccountsResponses = {
    /**
     * No response was specified
     */
    200: Course;
};

export type GetSingleCourseAccountsResponse = GetSingleCourseAccountsResponses[keyof GetSingleCourseAccountsResponses];

export type CreateToolFromToolconfigurationAccountsData = {
    body?: {
        /**
         * if course
         */
        course_id?: string;
    };
    path: {
        /**
         * if account
         */
        account_id: string;
        /**
         * no description
         */
        developer_key_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/developer_keys/{developer_key_id}/create_tool';
};

export type CreateToolFromToolconfigurationAccountsResponses = {
    /**
     * No response was specified
     */
    200: ContextExternalTool;
};

export type CreateToolFromToolconfigurationAccountsResponse = CreateToolFromToolconfigurationAccountsResponses[keyof CreateToolFromToolconfigurationAccountsResponses];

export type EnrollmentByIdData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * The ID of the enrollment object
         */
        id: number;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/enrollments/{id}';
};

export type EnrollmentByIdResponses = {
    /**
     * No response was specified
     */
    200: Enrollment;
};

export type EnrollmentByIdResponse = EnrollmentByIdResponses[keyof EnrollmentByIdResponses];

export type ListExternalToolsAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The partial name of the tools to match and return.
         */
        search_term?: string;
        /**
         * If true, then only tools that are meant to be selectable are returned
         */
        selectable?: boolean;
        /**
         * If true, then include tools installed in all accounts above the current context
         */
        include_parents?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/external_tools';
};

export type ListExternalToolsAccountsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateExternalToolAccountsData = {
    body: {
        /**
         * The layout type to use when launching the tool. Must be
         * "full_width", "full_width_in_context", "borderless", or "default"
         */
        'account_navigation[display_type]'?: string;
        /**
         * Set this to enable this feature
         */
        'account_navigation[enabled]'?: boolean;
        /**
         * The height of the dialog the tool is launched in
         */
        'account_navigation[selection_height]'?: string;
        /**
         * The width of the dialog the tool is launched in
         */
        'account_navigation[selection_width]'?: string;
        /**
         * The text that will show on the left-tab in the account navigation
         */
        'account_navigation[text]'?: string;
        /**
         * The url of the external tool for account navigation
         */
        'account_navigation[url]'?: string;
        /**
         * Configuration can be passed in as CC xml instead of using query
         * parameters. If this value is "by_url" or "by_xml" then an xml
         * configuration will be expected in either the "config_xml" or "config_url"
         * parameter. Note that the name parameter overrides the tool name provided
         * in the xml
         */
        config_type?: string;
        /**
         * URL where the server can retrieve an XML tool configuration, as specified
         * in the CC xml specification. This is required if "config_type" is set to
         * "by_url"
         */
        config_url?: string;
        /**
         * XML tool configuration, as specified in the CC xml specification. This is
         * required if "config_type" is set to "by_xml"
         */
        config_xml?: string;
        /**
         * The consumer key for the external tool
         */
        consumer_key: string;
        /**
         * Set this to enable this feature
         */
        'course_home_sub_navigation[enabled]'?: boolean;
        /**
         * The url of the icon to show in the right-side course home navigation menu
         */
        'course_home_sub_navigation[icon_url]'?: string;
        /**
         * The text that will show on the right-side course home navigation menu
         */
        'course_home_sub_navigation[text]'?: string;
        /**
         * The url of the external tool for right-side course home navigation menu
         */
        'course_home_sub_navigation[url]'?: string;
        /**
         * Whether the navigation option will show in the course by default or
         * whether the teacher will have to explicitly enable it
         */
        'course_navigation[default]'?: boolean;
        /**
         * The layout type to use when launching the tool. Must be
         * "full_width", "full_width_in_context", "borderless", or "default"
         */
        'course_navigation[display_type]'?: string;
        /**
         * Set this to enable this feature
         */
        'course_navigation[enabled]'?: boolean;
        /**
         * The text that will show on the left-tab in the course navigation
         */
        'course_navigation[text]'?: string;
        /**
         * Who will see the navigation tab. "admins" for course admins, "members" for
         * students, null for everyone
         */
        'course_navigation[visibility]'?: 'admins' | 'members';
        /**
         * Determines how the navigation tab will be opened.
         * "_blank"	Launches the external tool in a new window or tab.
         * "_self"	(Default) Launches the external tool in an iframe inside of Canvas.
         */
        'course_navigation[windowTarget]'?: '_blank' | '_self';
        /**
         * Custom fields that will be sent to the tool consumer; can be used
         * multiple times
         */
        'custom_fields[field_name]'?: string;
        /**
         * A description of the tool
         */
        description?: string;
        /**
         * The domain to match links against. Either "url" or "domain" should be
         * set, not both.
         */
        domain?: string;
        /**
         * Set this to enable this feature
         */
        'editor_button[enabled]'?: boolean;
        /**
         * The url of the icon to show in the WYSIWYG editor
         */
        'editor_button[icon_url]'?: string;
        /**
         * Set this to ContentItemSelectionRequest to tell the tool to use
         * content-item; otherwise, omit
         */
        'editor_button[message_type]'?: string;
        /**
         * The height of the dialog the tool is launched in
         */
        'editor_button[selection_height]'?: string;
        /**
         * The width of the dialog the tool is launched in
         */
        'editor_button[selection_width]'?: string;
        /**
         * The url of the external tool
         */
        'editor_button[url]'?: string;
        /**
         * Set this to enable this feature
         */
        'homework_submission[enabled]'?: boolean;
        /**
         * Set this to ContentItemSelectionRequest to tell the tool to use
         * content-item; otherwise, omit
         */
        'homework_submission[message_type]'?: string;
        /**
         * The text that will show on the homework submission tab
         */
        'homework_submission[text]'?: string;
        /**
         * The url of the external tool
         */
        'homework_submission[url]'?: string;
        /**
         * The url of the icon to show for this tool
         */
        icon_url?: string;
        /**
         * Set this to enable this feature
         */
        'link_selection[enabled]'?: boolean;
        /**
         * Set this to ContentItemSelectionRequest to tell the tool to use
         * content-item; otherwise, omit
         */
        'link_selection[message_type]'?: string;
        /**
         * The text that will show for the link selection text
         */
        'link_selection[text]'?: string;
        /**
         * The url of the external tool
         */
        'link_selection[url]'?: string;
        /**
         * Set this to enable this feature
         */
        'migration_selection[enabled]'?: boolean;
        /**
         * Set this to ContentItemSelectionRequest to tell the tool to use
         * content-item; otherwise, omit
         */
        'migration_selection[message_type]'?: string;
        /**
         * The url of the external tool
         */
        'migration_selection[url]'?: string;
        /**
         * The name of the tool
         */
        name: string;
        /**
         * Default: false, if set to true the tool won't show up in the external tool
         * selection UI in modules and assignments
         */
        not_selectable?: boolean;
        /**
         * Default: false, if set to true LTI query params will not be copied to the
         * post body.
         */
        oauth_compliant?: boolean;
        /**
         * What information to send to the external tool.
         */
        privacy_level: 'anonymous' | 'name_only' | 'public';
        /**
         * Set this to enable this feature
         */
        'resource_selection[enabled]'?: boolean;
        /**
         * The url of the icon to show in the module external tool list
         */
        'resource_selection[icon_url]'?: string;
        /**
         * The height of the dialog the tool is launched in
         */
        'resource_selection[selection_height]'?: string;
        /**
         * The width of the dialog the tool is launched in
         */
        'resource_selection[selection_width]'?: string;
        /**
         * The url of the external tool
         */
        'resource_selection[url]'?: string;
        /**
         * The shared secret with the external tool
         */
        shared_secret: string;
        /**
         * The default text to show for this tool
         */
        text?: string;
        /**
         * Set this to enable this feature
         */
        'tool_configuration[enabled]'?: boolean;
        /**
         * Set this to ContentItemSelectionRequest to tell the tool to use
         * content-item; otherwise, omit
         */
        'tool_configuration[message_type]'?: string;
        /**
         * Set this to default the lis_person_contact_email_primary to prefer
         * provisioned sis_email; otherwise, omit
         */
        'tool_configuration[prefer_sis_email]'?: boolean;
        /**
         * The url of the external tool
         */
        'tool_configuration[url]'?: string;
        /**
         * The url to match links against. Either "url" or "domain" should be set,
         * not both.
         */
        url?: string;
        /**
         * Set this to enable this feature
         */
        'user_navigation[enabled]'?: boolean;
        /**
         * The text that will show on the left-tab in the user navigation
         */
        'user_navigation[text]'?: string;
        /**
         * The url of the external tool for user navigation
         */
        'user_navigation[url]'?: string;
        /**
         * Who will see the navigation tab. "admins" for admins, "public" or
         * "members" for everyone
         */
        'user_navigation[visibility]'?: 'admins' | 'members' | 'public';
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/external_tools';
};

export type CreateExternalToolAccountsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSessionlessLaunchUrlForExternalToolAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The external id of the tool to launch.
         */
        id?: string;
        /**
         * The LTI launch url for the external tool.
         */
        url?: string;
        /**
         * The assignment id for an assignment launch. Required if launch_type is set to "assessment".
         */
        assignment_id?: string;
        /**
         * The assignment id for a module item launch. Required if launch_type is set to "module_item".
         */
        module_item_id?: string;
        /**
         * The type of launch to perform on the external tool. Placement names (eg. "course_navigation")
         * can also be specified to use the custom launch url for that placement; if done, the tool id
         * must be provided.
         */
        launch_type?: 'assessment' | 'module_item';
    };
    url: '/v1/accounts/{account_id}/external_tools/sessionless_launch';
};

export type GetSessionlessLaunchUrlForExternalToolAccountsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteExternalToolAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        external_tool_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/external_tools/{external_tool_id}';
};

export type DeleteExternalToolAccountsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleExternalToolAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        external_tool_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/external_tools/{external_tool_id}';
};

export type GetSingleExternalToolAccountsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type EditExternalToolAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        external_tool_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/external_tools/{external_tool_id}';
};

export type EditExternalToolAccountsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListFeaturesAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/features';
};

export type ListFeaturesAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<Feature>;
};

export type ListFeaturesAccountsResponse = ListFeaturesAccountsResponses[keyof ListFeaturesAccountsResponses];

export type ListEnabledFeaturesAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/features/enabled';
};

export type ListEnabledFeaturesAccountsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type RemoveFeatureFlagAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        feature: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/features/flags/{feature}';
};

export type RemoveFeatureFlagAccountsResponses = {
    /**
     * No response was specified
     */
    200: FeatureFlag;
};

export type RemoveFeatureFlagAccountsResponse = RemoveFeatureFlagAccountsResponses[keyof RemoveFeatureFlagAccountsResponses];

export type GetFeatureFlagAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        feature: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/features/flags/{feature}';
};

export type GetFeatureFlagAccountsResponses = {
    /**
     * No response was specified
     */
    200: FeatureFlag;
};

export type GetFeatureFlagAccountsResponse = GetFeatureFlagAccountsResponses[keyof GetFeatureFlagAccountsResponses];

export type SetFeatureFlagAccountsData = {
    body?: {
        /**
         * "off":: The feature is not available for the course, user, or account and sub-accounts.
         * "allowed":: (valid only on accounts) The feature is off in the account, but may be enabled in
         * sub-accounts and courses by setting a feature flag on the sub-account or course.
         * "on":: The feature is turned on unconditionally for the user, course, or account and sub-accounts.
         */
        state?: false | 'allowed' | true;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        feature: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/features/flags/{feature}';
};

export type SetFeatureFlagAccountsResponses = {
    /**
     * No response was specified
     */
    200: FeatureFlag;
};

export type SetFeatureFlagAccountsResponse = SetFeatureFlagAccountsResponses[keyof SetFeatureFlagAccountsResponses];

export type ListGradingPeriodsAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/grading_periods';
};

export type ListGradingPeriodsAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<GradingPeriod>;
};

export type ListGradingPeriodsAccountsResponse = ListGradingPeriodsAccountsResponses[keyof ListGradingPeriodsAccountsResponses];

export type DeleteGradingPeriodAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/grading_periods/{id}';
};

export type DeleteGradingPeriodAccountsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListGradingStandardsAvailableInContextAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/grading_standards';
};

export type ListGradingStandardsAvailableInContextAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<GradingStandard>;
};

export type ListGradingStandardsAvailableInContextAccountsResponse = ListGradingStandardsAvailableInContextAccountsResponses[keyof ListGradingStandardsAvailableInContextAccountsResponses];

export type CreateNewGradingStandardAccountsData = {
    body: {
        /**
         * The name for an entry value within a GradingStandard that describes the range of the value
         * e.g. A-
         */
        'grading_scheme_entry[name]': Array<string>;
        /**
         * The value for the name of the entry within a GradingStandard.
         * The entry represents the lower bound of the range for the entry.
         * This range includes the value up to the next entry in the GradingStandard,
         * or 100 if there is no upper bound. The lowest value will have a lower bound range of 0.
         * e.g. 93
         */
        'grading_scheme_entry[value]': Array<number>;
        /**
         * The title for the Grading Standard.
         */
        title: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/grading_standards';
};

export type CreateNewGradingStandardAccountsResponses = {
    /**
     * No response was specified
     */
    200: GradingStandard;
};

export type CreateNewGradingStandardAccountsResponse = CreateNewGradingStandardAccountsResponses[keyof CreateNewGradingStandardAccountsResponses];

export type GetSingleGradingStandardInContextAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        grading_standard_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/grading_standards/{grading_standard_id}';
};

export type GetSingleGradingStandardInContextAccountsResponses = {
    /**
     * No response was specified
     */
    200: GradingStandard;
};

export type GetSingleGradingStandardInContextAccountsResponse = GetSingleGradingStandardInContextAccountsResponses[keyof GetSingleGradingStandardInContextAccountsResponses];

export type ListGroupCategoriesForContextAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/group_categories';
};

export type ListGroupCategoriesForContextAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<GroupCategory>;
};

export type ListGroupCategoriesForContextAccountsResponse = ListGroupCategoriesForContextAccountsResponses[keyof ListGroupCategoriesForContextAccountsResponses];

export type CreateGroupCategoryAccountsData = {
    body: {
        /**
         * Assigns group leaders automatically when generating and allocating students to groups
         * Valid values are:
         * "first":: the first student to be allocated to a group is the leader
         * "random":: a random student from all members is chosen as the leader
         */
        auto_leader?: 'first' | 'random';
        /**
         * Create this number of groups (Course Only).
         */
        create_group_count?: number;
        /**
         * Limit the maximum number of users in each group (Course Only). Requires
         * self signup.
         */
        group_limit?: number;
        /**
         * Name of the group category
         */
        name: string;
        /**
         * Allow students to sign up for a group themselves (Course Only).
         * valid values are:
         * "enabled":: allows students to self sign up for any group in course
         * "restricted":: allows students to self sign up only for groups in the
         * same section null disallows self sign up
         */
        self_signup?: 'enabled' | 'restricted';
        /**
         * The unique SIS identifier.
         */
        sis_group_category_id?: string;
        /**
         * (Deprecated)
         * Create this number of groups, and evenly distribute students
         * among them. not allowed with "enable_self_signup". because
         * the group assignment happens synchronously, it's recommended
         * that you instead use the assign_unassigned_members endpoint.
         * (Course Only)
         */
        split_group_count?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/group_categories';
};

export type CreateGroupCategoryAccountsResponses = {
    /**
     * No response was specified
     */
    200: GroupCategory;
};

export type CreateGroupCategoryAccountsResponse = CreateGroupCategoryAccountsResponses[keyof CreateGroupCategoryAccountsResponses];

export type ListGroupsAvailableInContextAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * Will only include groups that the user belongs to if this is set
         */
        only_own_groups?: boolean;
        /**
         * - "tabs": Include the list of tabs configured for each group.  See the
         * {api:TabsController#index List available tabs API} for more information.
         */
        include?: Array<'tabs'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/groups';
};

export type ListGroupsAvailableInContextAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<Group>;
};

export type ListGroupsAvailableInContextAccountsResponse = ListGroupsAvailableInContextAccountsResponses[keyof ListGroupsAvailableInContextAccountsResponses];

export type GetHelpLinksData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/help_links';
};

export type GetHelpLinksResponses = {
    /**
     * No response was specified
     */
    200: HelpLinks;
};

export type GetHelpLinksResponse = GetHelpLinksResponses[keyof GetHelpLinksResponses];

export type ListUserLoginsAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/logins';
};

export type ListUserLoginsAccountsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateUserLoginData = {
    body: {
        /**
         * The authentication provider this login is associated with. Logins
         * associated with a specific provider can only be used with that provider.
         * Legacy providers (LDAP, CAS, SAML) will search for logins associated with
         * them, or unassociated logins. New providers will only search for logins
         * explicitly associated with them. This can be the integer ID of the
         * provider, or the type of the provider (in which case, it will find the
         * first matching provider).
         */
        'login[authentication_provider_id]'?: string;
        /**
         * Integration ID for the login. To set this parameter, the caller must be able to
         * manage SIS permissions on the account. The Integration ID is a secondary
         * identifier useful for more complex SIS integrations.
         */
        'login[integration_id]'?: string;
        /**
         * The new login's password.
         */
        'login[password]'?: string;
        /**
         * SIS ID for the login. To set this parameter, the caller must be able to
         * manage SIS permissions on the account.
         */
        'login[sis_user_id]'?: string;
        /**
         * The unique ID for the new login.
         */
        'login[unique_id]': string;
        /**
         * The ID of the user to create the login for.
         */
        'user[id]': string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/logins';
};

export type CreateUserLoginResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type EditUserLoginData = {
    body?: {
        /**
         * Integration ID for the login. To set this parameter, the caller must be able to
         * manage SIS permissions on the account. The Integration ID is a secondary
         * identifier useful for more complex SIS integrations.
         */
        'login[integration_id]'?: string;
        /**
         * The new password for the login. Can only be set by an admin user if admins
         * are allowed to change passwords for the account.
         */
        'login[password]'?: string;
        /**
         * SIS ID for the login. To set this parameter, the caller must be able to
         * manage SIS permissions on the account.
         */
        'login[sis_user_id]'?: string;
        /**
         * The new unique ID for the login.
         */
        'login[unique_id]'?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/logins/{id}';
};

export type EditUserLoginResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetAllOutcomeLinksForContextAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The detail level of the outcomes. Defaults to "abbrev".
         * Specify "full" for more information.
         */
        outcome_style?: string;
        /**
         * The detail level of the outcome groups. Defaults to "abbrev".
         * Specify "full" for more information.
         */
        outcome_group_style?: string;
    };
    url: '/v1/accounts/{account_id}/outcome_group_links';
};

export type GetAllOutcomeLinksForContextAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<OutcomeLink>;
};

export type GetAllOutcomeLinksForContextAccountsResponse = GetAllOutcomeLinksForContextAccountsResponses[keyof GetAllOutcomeLinksForContextAccountsResponses];

export type GetAllOutcomeGroupsForContextAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_groups';
};

export type GetAllOutcomeGroupsForContextAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<OutcomeGroup>;
};

export type GetAllOutcomeGroupsForContextAccountsResponse = GetAllOutcomeGroupsForContextAccountsResponses[keyof GetAllOutcomeGroupsForContextAccountsResponses];

export type DeleteOutcomeGroupAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_groups/{id}';
};

export type DeleteOutcomeGroupAccountsResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type DeleteOutcomeGroupAccountsResponse = DeleteOutcomeGroupAccountsResponses[keyof DeleteOutcomeGroupAccountsResponses];

export type ShowOutcomeGroupAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_groups/{id}';
};

export type ShowOutcomeGroupAccountsResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type ShowOutcomeGroupAccountsResponse = ShowOutcomeGroupAccountsResponses[keyof ShowOutcomeGroupAccountsResponses];

export type UpdateOutcomeGroupAccountsData = {
    body?: {
        /**
         * The new outcome group description.
         */
        description?: string;
        /**
         * The id of the new parent outcome group.
         */
        parent_outcome_group_id?: number;
        /**
         * The new outcome group title.
         */
        title?: string;
        /**
         * A custom GUID for the learning standard.
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_groups/{id}';
};

export type UpdateOutcomeGroupAccountsResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type UpdateOutcomeGroupAccountsResponse = UpdateOutcomeGroupAccountsResponses[keyof UpdateOutcomeGroupAccountsResponses];

export type ImportOutcomeGroupAccountsData = {
    body: {
        /**
         * If true, perform action asynchronously.  In that case, this endpoint
         * will return a Progress object instead of an OutcomeGroup.
         * Use the {api:ProgressController#show progress endpoint}
         * to query the status of the operation.  The imported outcome group id
         * and url will be returned in the results of the Progress object
         * as "outcome_group_id" and "outcome_group_url"
         */
        async?: boolean;
        /**
         * The ID of the source outcome group.
         */
        source_outcome_group_id: number;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_groups/{id}/import';
};

export type ImportOutcomeGroupAccountsResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type ImportOutcomeGroupAccountsResponse = ImportOutcomeGroupAccountsResponses[keyof ImportOutcomeGroupAccountsResponses];

export type ListLinkedOutcomesAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * The detail level of the outcomes. Defaults to "abbrev".
         * Specify "full" for more information.
         */
        outcome_style?: string;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/outcome_groups/{id}/outcomes';
};

export type ListLinkedOutcomesAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<OutcomeLink>;
};

export type ListLinkedOutcomesAccountsResponse = ListLinkedOutcomesAccountsResponses[keyof ListLinkedOutcomesAccountsResponses];

export type CreateLinkOutcomeAccountsData = {
    body?: {
        /**
         * The new calculation int.  Only applies if the calculation_method is "decaying_average" or "n_mastery"
         */
        calculation_int?: number;
        /**
         * The new calculation method.  Defaults to "highest"
         */
        calculation_method?: 'decaying_average' | 'n_mastery' | 'latest' | 'highest';
        /**
         * The description of the new outcome.
         */
        description?: string;
        /**
         * A friendly name shown in reports for outcomes with cryptic titles,
         * such as common core standards names.
         */
        display_name?: string;
        /**
         * The mastery threshold for the embedded rubric criterion.
         */
        mastery_points?: number;
        /**
         * The ID of the old outcome group. Only used if outcome_id is present.
         */
        move_from?: number;
        /**
         * The ID of the existing outcome to link.
         */
        outcome_id?: number;
        /**
         * The description of a rating level for the embedded rubric criterion.
         */
        'ratings[description]'?: Array<string>;
        /**
         * The points corresponding to a rating level for the embedded rubric criterion.
         */
        'ratings[points]'?: Array<number>;
        /**
         * The title of the new outcome. Required if outcome_id is absent.
         */
        title?: string;
        /**
         * A custom GUID for the learning standard.
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_groups/{id}/outcomes';
};

export type CreateLinkOutcomeAccountsResponses = {
    /**
     * No response was specified
     */
    200: OutcomeLink;
};

export type CreateLinkOutcomeAccountsResponse = CreateLinkOutcomeAccountsResponses[keyof CreateLinkOutcomeAccountsResponses];

export type UnlinkOutcomeAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
        /**
         * ID
         */
        outcome_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_groups/{id}/outcomes/{outcome_id}';
};

export type UnlinkOutcomeAccountsResponses = {
    /**
     * No response was specified
     */
    200: OutcomeLink;
};

export type UnlinkOutcomeAccountsResponse = UnlinkOutcomeAccountsResponses[keyof UnlinkOutcomeAccountsResponses];

export type CreateLinkOutcomeAccountsOutcomeIdData = {
    body?: {
        /**
         * The new calculation int.  Only applies if the calculation_method is "decaying_average" or "n_mastery"
         */
        calculation_int?: number;
        /**
         * The new calculation method.  Defaults to "highest"
         */
        calculation_method?: 'decaying_average' | 'n_mastery' | 'latest' | 'highest';
        /**
         * The description of the new outcome.
         */
        description?: string;
        /**
         * A friendly name shown in reports for outcomes with cryptic titles,
         * such as common core standards names.
         */
        display_name?: string;
        /**
         * The mastery threshold for the embedded rubric criterion.
         */
        mastery_points?: number;
        /**
         * The ID of the old outcome group. Only used if outcome_id is present.
         */
        move_from?: number;
        /**
         * The description of a rating level for the embedded rubric criterion.
         */
        'ratings[description]'?: Array<string>;
        /**
         * The points corresponding to a rating level for the embedded rubric criterion.
         */
        'ratings[points]'?: Array<number>;
        /**
         * The title of the new outcome. Required if outcome_id is absent.
         */
        title?: string;
        /**
         * A custom GUID for the learning standard.
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
        /**
         * The ID of the existing outcome to link.
         */
        outcome_id: number;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_groups/{id}/outcomes/{outcome_id}';
};

export type CreateLinkOutcomeAccountsOutcomeIdResponses = {
    /**
     * No response was specified
     */
    200: OutcomeLink;
};

export type CreateLinkOutcomeAccountsOutcomeIdResponse = CreateLinkOutcomeAccountsOutcomeIdResponses[keyof CreateLinkOutcomeAccountsOutcomeIdResponses];

export type ListSubgroupsAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/outcome_groups/{id}/subgroups';
};

export type ListSubgroupsAccountsResponses = {
    /**
     * No response was specified
     */
    200: Array<OutcomeGroup>;
};

export type ListSubgroupsAccountsResponse = ListSubgroupsAccountsResponses[keyof ListSubgroupsAccountsResponses];

export type CreateSubgroupAccountsData = {
    body: {
        /**
         * The description of the new outcome group.
         */
        description?: string;
        /**
         * The title of the new outcome group.
         */
        title: string;
        /**
         * A custom GUID for the learning standard
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_groups/{id}/subgroups';
};

export type CreateSubgroupAccountsResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type CreateSubgroupAccountsResponse = CreateSubgroupAccountsResponses[keyof CreateSubgroupAccountsResponses];

export type ImportOutcomesAccountsData = {
    body?: {
        /**
         * There are two ways to post outcome import data - either via a
         * application/x-www-form-urlencoded form-field-style attachment, or via a non-multipart
         * raw post request.
         *
         * 'attachment' is required for application/x-www-form-urlencoded style posts. Assumed to
         * be outcome data from a file upload form field named 'attachment'.
         *
         * Examples:
         * curl -F attachment=@<filename> -H "Authorization: Bearer <token>" \
         * 'https://<canvas>/api/v1/accounts/<account_id>/outcome_imports?import_type=instructure_csv'
         * curl -F attachment=@<filename> -H "Authorization: Bearer <token>" \
         * 'https://<canvas>/api/v1/courses/<course_id>/outcome_imports?import_type=instructure_csv'
         *
         * If you decide to do a raw post, you can skip the 'attachment' argument,
         * but you will then be required to provide a suitable Content-Type header.
         * You are encouraged to also provide the 'extension' argument.
         *
         * Examples:
         * curl -H 'Content-Type: text/csv' --data-binary @<filename>.csv \
         * -H "Authorization: Bearer <token>" \
         * 'https://<canvas>/api/v1/accounts/<account_id>/outcome_imports?import_type=instructure_csv'
         *
         * curl -H 'Content-Type: text/csv' --data-binary @<filename>.csv \
         * -H "Authorization: Bearer <token>" \
         * 'https://<canvas>/api/v1/courses/<course_id>/outcome_imports?import_type=instructure_csv'
         */
        attachment?: string;
        /**
         * Recommended for raw post request style imports. This field will be used to
         * distinguish between csv and other file format extensions that
         * would usually be provided with the filename in the multipart post request
         * scenario. If not provided, this value will be inferred from the
         * Content-Type, falling back to csv-file format if all else fails.
         */
        extension?: string;
        /**
         * Choose the data format for reading outcome data. With a standard Canvas
         * install, this option can only be 'instructure_csv', and if unprovided,
         * will be assumed to be so. Can be part of the query string.
         */
        import_type?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_imports';
};

export type ImportOutcomesAccountsResponses = {
    /**
     * No response was specified
     */
    200: OutcomeImport;
};

export type ImportOutcomesAccountsResponse = ImportOutcomesAccountsResponses[keyof ImportOutcomesAccountsResponses];

export type GetOutcomeImportStatusAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_imports/{id}';
};

export type GetOutcomeImportStatusAccountsResponses = {
    /**
     * No response was specified
     */
    200: OutcomeImport;
};

export type GetOutcomeImportStatusAccountsResponse = GetOutcomeImportStatusAccountsResponses[keyof GetOutcomeImportStatusAccountsResponses];

export type GetProficiencyRatingsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_proficiency';
};

export type GetProficiencyRatingsResponses = {
    /**
     * No response was specified
     */
    200: Proficiency;
};

export type GetProficiencyRatingsResponse = GetProficiencyRatingsResponses[keyof GetProficiencyRatingsResponses];

export type CreateUpdateProficiencyRatingsData = {
    body?: {
        /**
         * The color associated with the rating level. Should be a hex color code like '00FFFF'.
         */
        'ratings[color]'?: Array<number>;
        /**
         * The description of the rating level.
         */
        'ratings[description]'?: Array<string>;
        /**
         * Indicates the rating level where mastery is first achieved. Only one rating in a proficiency should be marked for mastery.
         */
        'ratings[mastery]'?: Array<number>;
        /**
         * The non-negative number of points of the rating level. Points across ratings should be strictly decreasing in value.
         */
        'ratings[points]'?: Array<number>;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/outcome_proficiency';
};

export type CreateUpdateProficiencyRatingsResponses = {
    /**
     * No response was specified
     */
    200: Proficiency;
};

export type CreateUpdateProficiencyRatingsResponse = CreateUpdateProficiencyRatingsResponses[keyof CreateUpdateProficiencyRatingsResponses];

export type AccountPermissionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * List of permissions to check against the authenticated user.
         * Permission names are documented in the {api:RoleOverridesController#add_role Create a role} endpoint.
         */
        permissions?: Array<string>;
    };
    url: '/v1/accounts/{account_id}/permissions';
};

export type AccountPermissionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListAvailableReportsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/reports';
};

export type ListAvailableReportsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type IndexOfReportsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        report: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/reports/{report}';
};

export type IndexOfReportsResponses = {
    /**
     * No response was specified
     */
    200: Array<Report>;
};

export type IndexOfReportsResponse = IndexOfReportsResponses[keyof IndexOfReportsResponses];

export type StartReportData = {
    body?: {
        /**
         * The parameters will vary for each report. To fetch a list
         * of available parameters for each report, see {api:AccountReportsController#available_reports List Available Reports}.
         * A few example parameters have been provided below. Note that the example
         * parameters provided below may not be valid for every report.
         */
        parameters?: string;
        /**
         * The id of the course to report on.
         * Note: this parameter has been listed to serve as an example and may not be
         * valid for every report.
         */
        'parameters[course_id]'?: number;
        /**
         * If true, user data will be included. If
         * false, user data will be omitted. Note: this parameter has been listed to
         * serve as an example and may not be valid for every report.
         */
        'parameters[users]'?: boolean;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        report: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/reports/{report}';
};

export type StartReportResponses = {
    /**
     * No response was specified
     */
    200: Report;
};

export type StartReportResponse = StartReportResponses[keyof StartReportResponses];

export type DeleteReportData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        report: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/reports/{report}/{id}';
};

export type DeleteReportResponses = {
    /**
     * No response was specified
     */
    200: Report;
};

export type DeleteReportResponse = DeleteReportResponses[keyof DeleteReportResponses];

export type StatusOfReportData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        report: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/reports/{report}/{id}';
};

export type StatusOfReportResponses = {
    /**
     * No response was specified
     */
    200: Report;
};

export type StatusOfReportResponse = StatusOfReportResponses[keyof StatusOfReportResponses];

export type ListRolesData = {
    body?: never;
    path: {
        /**
         * The id of the account to retrieve roles for.
         */
        account_id: string;
    };
    query?: {
        /**
         * Filter by role state. If this argument is omitted, only 'active' roles are
         * returned.
         */
        state?: Array<'active' | 'inactive'>;
        /**
         * If this argument is true, all roles inherited from parent accounts will
         * be included.
         */
        show_inherited?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/roles';
};

export type ListRolesResponses = {
    /**
     * No response was specified
     */
    200: Array<Role>;
};

export type ListRolesResponse = ListRolesResponses[keyof ListRolesResponses];

export type CreateNewRoleData = {
    body: {
        /**
         * Specifies the role type that will be used as a base
         * for the permissions granted to this role.
         *
         * Defaults to 'AccountMembership' if absent
         */
        base_role_type?: 'AccountMembership' | 'StudentEnrollment' | 'TeacherEnrollment' | 'TaEnrollment' | 'ObserverEnrollment' | 'DesignerEnrollment';
        /**
         * Label for the role.
         */
        label: string;
        /**
         * If the value is 1, permission <X> cascades down to sub accounts of the
         * account this role is in. The default value is 1.  Must be true if
         * applies_to_self is false.This value is only returned if enabled is true.
         */
        'permissions[X][applies_to_descendants]'?: boolean;
        /**
         * If the value is 1, permission <X> applies to the account this role is in.
         * The default value is 1. Must be true if applies_to_descendants is false.
         * This value is only returned if enabled is true.
         */
        'permissions[X][applies_to_self]'?: boolean;
        /**
         * If explicit is 1 and enabled is 1, permission <X> will be explicitly
         * granted to this role. If explicit is 1 and enabled has any other value
         * (typically 0), permission <X> will be explicitly denied to this role. If
         * explicit is any other value (typically 0) or absent, or if enabled is
         * absent, the value for permission <X> will be inherited from upstream.
         * Ignored if permission <X> is locked upstream (in an ancestor account).
         *
         * May occur multiple times with unique values for <X>. Recognized
         * permission names for <X> are:
         *
         * [For Account-Level Roles Only]
         * become_user                      -- Become other users
         * import_sis                       -- Import SIS data
         * manage_account_memberships       -- Add/remove other admins for the account
         * manage_account_settings          -- Manage account-level settings
         * manage_alerts                    -- Manage global alerts
         * manage_courses                   -- Manage ( add / edit / delete ) courses
         * manage_developer_keys            -- Manage developer keys
         * manage_global_outcomes           -- Manage learning outcomes
         * manage_jobs                      -- Manage background jobs
         * manage_role_overrides            -- Manage permissions
         * manage_storage_quotas            -- Set storage quotas for courses, groups, and users
         * manage_sis                       -- Manage SIS data
         * manage_site_settings             -- Manage site-wide and plugin settings
         * manage_user_logins               -- Modify login details for users
         * read_course_content              -- View course content
         * read_course_list                 -- View the list of courses
         * read_messages                    -- View notifications sent to users
         * site_admin                       -- Use the Site Admin section and admin all other accounts
         * view_error_reports               -- View error reports
         * view_statistics                  -- View statistics
         * manage_feature_flags             -- Enable or disable features at an account level
         *
         * [For both Account-Level and Course-Level roles]
         * Note: Applicable enrollment types for course-level roles are given in brackets:
         * S = student, T = teacher, A = TA, D = designer, O = observer.
         * Lower-case letters indicate permissions that are off by default.
         * A missing letter indicates the permission cannot be enabled for the role
         * or any derived custom roles.
         * change_course_state              -- [ TaD ] Change course state
         * comment_on_others_submissions    -- [sTAD ] View all students' submissions and make comments on them
         * create_collaborations            -- [STADo] Create student collaborations
         * create_conferences               -- [STADo] Create web conferences
         * import_outcomes                  -- [ TaDo] Import outcome data
         * manage_admin_users               -- [ Tad ] Add/remove other teachers, course designers or TAs to the course
         * manage_assignments               -- [ TADo] Manage (add / edit / delete) assignments and quizzes
         * manage_calendar                  -- [sTADo] Add, edit and delete events on the course calendar
         * manage_content                   -- [ TADo] Manage all other course content
         * manage_files                     -- [ TADo] Manage (add / edit / delete) course files
         * manage_grades                    -- [ TA  ] Edit grades
         * manage_groups                    -- [ TAD ] Manage (create / edit / delete) groups
         * manage_interaction_alerts        -- [ Ta  ] Manage alerts
         * manage_outcomes                  -- [sTaDo] Manage learning outcomes
         * manage_sections                  -- [ TaD ] Manage (create / edit / delete) course sections
         * manage_students                  -- [ TAD ] Add/remove students for the course
         * manage_user_notes                -- [ TA  ] Manage faculty journal entries
         * manage_rubrics                   -- [ TAD ] Edit assessing rubrics
         * manage_wiki                      -- [ TADo] Manage (add / edit / delete) pages
         * read_forum                       -- [STADO] View discussions
         * moderate_forum                   -- [sTADo] Moderate discussions (delete/edit others' posts, lock topics)
         * post_to_forum                    -- [STADo] Post to discussions
         * create_forum                     -- [STADo] Create discussions
         * read_announcements               -- [STADO] View announcements
         * read_question_banks              -- [ TADo] View and link to question banks
         * read_reports                     -- [ TAD ] View usage reports for the course
         * read_roster                      -- [STADo] See the list of users
         * read_sis                         -- [sTa  ] Read SIS data
         * send_messages                    -- [STADo] Send messages to individual course members
         * send_messages_all                -- [sTADo] Send messages to the entire class
         * view_all_grades                  -- [ TAd ] View all grades
         * view_group_pages                 -- [sTADo] View the group pages of all student groups
         * lti_add_edit                     -- [ TAD ] LTI add and edit
         * read_email_addresses             -- [sTAdo] See other users' primary email address
         * view_user_logins                 -- [ TA  ] View login ids for users
         * generate_observer_pairing_code   -- [ tAdo] Allow observer pairing code generation
         *
         * Some of these permissions are applicable only for roles on the site admin
         * account, on a root account, or for course-level roles with a particular base role type;
         * if a specified permission is inapplicable, it will be ignored.
         *
         * Additional permissions may exist based on installed plugins.
         */
        'permissions[X][enabled]'?: boolean;
        /**
         * no description
         */
        'permissions[X][explicit]'?: boolean;
        /**
         * If the value is 1, permission <X> will be locked downstream (new roles in
         * subaccounts cannot override the setting). For any other value, permission
         * <X> is left unlocked. Ignored if permission <X> is already locked
         * upstream. May occur multiple times with unique values for <X>.
         */
        'permissions[X][locked]'?: boolean;
        /**
         * Deprecated alias for label.
         */
        role?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/roles';
};

export type CreateNewRoleResponses = {
    /**
     * No response was specified
     */
    200: Role;
};

export type CreateNewRoleResponse = CreateNewRoleResponses[keyof CreateNewRoleResponses];

export type DeactivateRoleData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query: {
        /**
         * The unique identifier for the role
         */
        role_id: number;
        /**
         * The name for the role
         */
        role?: string;
    };
    url: '/v1/accounts/{account_id}/roles/{id}';
};

export type DeactivateRoleResponses = {
    /**
     * No response was specified
     */
    200: Role;
};

export type DeactivateRoleResponse = DeactivateRoleResponses[keyof DeactivateRoleResponses];

export type GetSingleRoleData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
        /**
         * The id of the account containing the role
         */
        account_id: string;
    };
    query: {
        /**
         * The unique identifier for the role
         */
        role_id: number;
        /**
         * The name for the role
         */
        role?: string;
    };
    url: '/v1/accounts/{account_id}/roles/{id}';
};

export type GetSingleRoleResponses = {
    /**
     * No response was specified
     */
    200: Role;
};

export type GetSingleRoleResponse = GetSingleRoleResponses[keyof GetSingleRoleResponses];

export type UpdateRoleData = {
    body?: {
        /**
         * The label for the role. Can only change the label of a custom role that belongs directly to the account.
         */
        label?: string;
        /**
         * If the value is 1, permission <X> cascades down to sub accounts of the
         * account this role is in. The default value is 1.  Must be true if
         * applies_to_self is false.This value is only returned if enabled is true.
         */
        'permissions[X][applies_to_descendants]'?: boolean;
        /**
         * If the value is 1, permission <X> applies to the account this role is in.
         * The default value is 1. Must be true if applies_to_descendants is false.
         * This value is only returned if enabled is true.
         */
        'permissions[X][applies_to_self]'?: boolean;
        /**
         * These arguments are described in the documentation for the
         * {api:RoleOverridesController#add_role add_role method}.
         */
        'permissions[X][enabled]'?: boolean;
        /**
         * no description
         */
        'permissions[X][explicit]'?: boolean;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/roles/{id}';
};

export type UpdateRoleResponses = {
    /**
     * No response was specified
     */
    200: Role;
};

export type UpdateRoleResponse = UpdateRoleResponses[keyof UpdateRoleResponses];

export type ActivateRoleData = {
    body: {
        /**
         * The name for the role
         */
        role?: unknown;
        /**
         * The unique identifier for the role
         */
        role_id: number;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/roles/{id}/activate';
};

export type ActivateRoleResponses = {
    /**
     * No response was specified
     */
    200: Role;
};

export type ActivateRoleResponse = ActivateRoleResponses[keyof ActivateRoleResponses];

export type RedirectToRootOutcomeGroupForContextAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/root_outcome_group';
};

export type RedirectToRootOutcomeGroupForContextAccountsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListRubricsAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/rubrics';
};

export type ListRubricsAccountsResponses = {
    /**
     * No response was specified
     */
    200: Rubric;
};

export type ListRubricsAccountsResponse = ListRubricsAccountsResponses[keyof ListRubricsAccountsResponses];

export type GetSingleRubricAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * If included, the type of associated rubric assessments to return. If not included, assessments will be omitted.
         */
        include?: 'assessments' | 'graded_assessments' | 'peer_assessments';
        /**
         * Applicable only if assessments are being returned. If included, returns either all criteria data associated with the assessment, or just the comments. If not included, both data and comments are omitted.
         */
        style?: 'full' | 'comments_only';
    };
    url: '/v1/accounts/{account_id}/rubrics/{id}';
};

export type GetSingleRubricAccountsResponses = {
    /**
     * No response was specified
     */
    200: Rubric;
};

export type GetSingleRubricAccountsResponse = GetSingleRubricAccountsResponses[keyof GetSingleRubricAccountsResponses];

export type ListScopesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The attribute to group the scopes by. By default no grouping is done.
         */
        group_by?: 'resource_name';
    };
    url: '/v1/accounts/{account_id}/scopes';
};

export type ListScopesResponses = {
    /**
     * No response was specified
     */
    200: Array<Scope>;
};

export type ListScopesResponse = ListScopesResponses[keyof ListScopesResponses];

export type SelfRegisterUserData = {
    body: {
        /**
         * The communication channel address, e.g. the user's email address.
         */
        'communication_channel[address]'?: string;
        /**
         * The communication channel type, e.g. 'email' or 'sms'.
         */
        'communication_channel[type]'?: string;
        /**
         * User's login ID. Must be a valid email address.
         */
        'pseudonym[unique_id]': string;
        /**
         * The user's birth date.
         */
        'user[birthdate]'?: string;
        /**
         * The user's preferred language, from the list of languages Canvas supports.
         * This is in RFC-5646 format.
         */
        'user[locale]'?: string;
        /**
         * The full name of the user. This name will be used by teacher for grading.
         */
        'user[name]': string;
        /**
         * User's name as it will be displayed in discussions, messages, and comments.
         */
        'user[short_name]'?: string;
        /**
         * User's name as used to sort alphabetically in lists.
         */
        'user[sortable_name]'?: string;
        /**
         * Whether the user accepts the terms of use.
         */
        'user[terms_of_use]': boolean;
        /**
         * The time zone for the user. Allowed time zones are
         * {http://www.iana.org/time-zones IANA time zones} or friendlier
         * {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
         */
        'user[time_zone]'?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/self_registration';
};

export type SelfRegisterUserResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type SelfRegisterUserResponse = SelfRegisterUserResponses[keyof SelfRegisterUserResponses];

export type ShareBrandconfigThemeData = {
    body: {
        /**
         * MD5 of brand_config to share
         */
        'shared_brand_config[brand_config_md5]': string;
        /**
         * Name to share this BrandConfig (theme) as.
         */
        'shared_brand_config[name]': string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/shared_brand_configs';
};

export type ShareBrandconfigThemeResponses = {
    /**
     * No response was specified
     */
    200: SharedBrandConfig;
};

export type ShareBrandconfigThemeResponse = ShareBrandconfigThemeResponses[keyof ShareBrandconfigThemeResponses];

export type UpdateSharedThemeData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/shared_brand_configs/{id}';
};

export type UpdateSharedThemeResponses = {
    /**
     * No response was specified
     */
    200: SharedBrandConfig;
};

export type UpdateSharedThemeResponse = UpdateSharedThemeResponses[keyof UpdateSharedThemeResponses];

export type GetSisImportErrorListSisImportErrorsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/sis_import_errors';
};

export type GetSisImportErrorListSisImportErrorsResponses = {
    /**
     * No response was specified
     */
    200: Array<SisImportError>;
};

export type GetSisImportErrorListSisImportErrorsResponse = GetSisImportErrorListSisImportErrorsResponses[keyof GetSisImportErrorListSisImportErrorsResponses];

export type GetSisImportListData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * If set, only shows imports created after the specified date (use ISO8601 format)
         */
        created_since?: string;
    };
    url: '/v1/accounts/{account_id}/sis_imports';
};

export type GetSisImportListResponses = {
    /**
     * No response was specified
     */
    200: Array<SisImport>;
};

export type GetSisImportListResponse = GetSisImportListResponses[keyof GetSisImportListResponses];

export type ImportSisDataData = {
    body?: {
        /**
         * This option, if present, will process all changes as if they were UI
         * changes. This means that "stickiness" will be added to changed fields.
         * This option is only processed if 'override_sis_stickiness' is also provided.
         */
        add_sis_stickiness?: boolean;
        /**
         * There are two ways to post SIS import data - either via a
         * application/x-www-form-urlencoded form-field-style attachment, or via a non-multipart
         * raw post request.
         *
         * 'attachment' is required for application/x-www-form-urlencoded style posts. Assumed to
         * be SIS data from a file upload form field named 'attachment'.
         *
         * Examples:
         * curl -F attachment=@<filename> -H "Authorization: Bearer <token>" \
         * https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv
         *
         * If you decide to do a raw post, you can skip the 'attachment' argument,
         * but you will then be required to provide a suitable Content-Type header.
         * You are encouraged to also provide the 'extension' argument.
         *
         * Examples:
         * curl -H 'Content-Type: application/octet-stream' --data-binary @<filename>.zip \
         * -H "Authorization: Bearer <token>" \
         * https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv&extension=zip
         *
         * curl -H 'Content-Type: application/zip' --data-binary @<filename>.zip \
         * -H "Authorization: Bearer <token>" \
         * https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv
         *
         * curl -H 'Content-Type: text/csv' --data-binary @<filename>.csv \
         * -H "Authorization: Bearer <token>" \
         * https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv
         *
         * curl -H 'Content-Type: text/csv' --data-binary @<filename>.csv \
         * -H "Authorization: Bearer <token>" \
         * https://<canvas>/api/v1/accounts/<account_id>/sis_imports.json?import_type=instructure_csv&batch_mode=1&batch_mode_term_id=15
         */
        attachment?: string;
        /**
         * If set, this SIS import will be run in batch mode, deleting any data
         * previously imported via SIS that is not present in this latest import.
         * See the SIS CSV Format page for details.
         * Batch mode cannot be used with diffing.
         */
        batch_mode?: boolean;
        /**
         * Limit deletions to only this term. Required if batch mode is enabled.
         */
        batch_mode_term_id?: string;
        /**
         * If set with batch_mode, the batch cleanup process will not run if the
         * number of items deleted is higher than the percentage set. If set to 10
         * and a term has 200 enrollments, and batch would delete more than 20 of
         * the enrollments the batch will abort before the enrollments are deleted.
         * The change_threshold will be evaluated for course, sections, and
         * enrollments independently.
         * If set with diffing, diffing  will not be performed if the files are
         * greater than the threshold as a percent. If set to 5 and the file is more
         * than 5% smaller or more than 5% larger than the file that is being
         * compared to, diffing will not be performed. If the files are less than 5%,
         * diffing will be performed. See the SIS CSV Format documentation for more
         * details.
         * Required for multi_term_batch_mode.
         */
        change_threshold?: number;
        /**
         * This option, if present, will clear "stickiness" from all fields touched
         * by this import. Requires that 'override_sis_stickiness' is also provided.
         * If 'add_sis_stickiness' is also provided, 'clear_sis_stickiness' will
         * overrule the behavior of 'add_sis_stickiness'
         */
        clear_sis_stickiness?: boolean;
        /**
         * If set on a CSV import, Canvas will attempt to optimize the SIS import by
         * comparing this set of CSVs to the previous set that has the same data set
         * identifier, and only applying the difference between the two. See the
         * SIS CSV Format documentation for more details.
         * Diffing cannot be used with batch_mode
         */
        diffing_data_set_identifier?: string;
        /**
         * If diffing_drop_status is passed, this SIS import will use this status for
         * enrollments that are not included in the sis_batch. Defaults to 'deleted'
         */
        diffing_drop_status?: 'deleted' | 'completed' | 'inactive';
        /**
         * If true, and diffing_data_set_identifier is sent, this SIS import will be
         * part of the data set, but diffing will not be performed. See the SIS CSV
         * Format documentation for details.
         */
        diffing_remaster_data_set?: boolean;
        /**
         * Recommended for raw post request style imports. This field will be used to
         * distinguish between zip, xml, csv, and other file format extensions that
         * would usually be provided with the filename in the multipart post request
         * scenario. If not provided, this value will be inferred from the
         * Content-Type, falling back to zip-file format if all else fails.
         */
        extension?: string;
        /**
         * Choose the data format for reading SIS data. With a standard Canvas
         * install, this option can only be 'instructure_csv', and if unprovided,
         * will be assumed to be so. Can be part of the query string.
         */
        import_type?: string;
        /**
         * Runs batch mode against all terms in terms file. Requires change_threshold.
         */
        multi_term_batch_mode?: boolean;
        /**
         * Many fields on records in Canvas can be marked "sticky," which means that
         * when something changes in the UI apart from the SIS, that field gets
         * "stuck." In this way, by default, SIS imports do not override UI changes.
         * If this field is present, however, it will tell the SIS import to ignore
         * "stickiness" and override all fields.
         */
        override_sis_stickiness?: boolean;
        /**
         * When set the import will skip any deletes. This does not account for
         * objects that are deleted during the batch mode cleanup process.
         */
        skip_deletes?: boolean;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/sis_imports';
};

export type ImportSisDataResponses = {
    /**
     * No response was specified
     */
    200: SisImport;
};

export type ImportSisDataResponse = ImportSisDataResponses[keyof ImportSisDataResponses];

export type AbortAllPendingSisImportsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/sis_imports/abort_all_pending';
};

export type AbortAllPendingSisImportsResponses = {
    /**
     * No response was specified
     */
    200: boolean;
};

export type AbortAllPendingSisImportsResponse = AbortAllPendingSisImportsResponses[keyof AbortAllPendingSisImportsResponses];

export type GetSisImportStatusData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/sis_imports/{id}';
};

export type GetSisImportStatusResponses = {
    /**
     * No response was specified
     */
    200: SisImport;
};

export type GetSisImportStatusResponse = GetSisImportStatusResponses[keyof GetSisImportStatusResponses];

export type AbortSisImportData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/sis_imports/{id}/abort';
};

export type AbortSisImportResponses = {
    /**
     * No response was specified
     */
    200: SisImport;
};

export type AbortSisImportResponse = AbortSisImportResponses[keyof AbortSisImportResponses];

export type GetSisImportErrorListSisImportsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/sis_imports/{id}/errors';
};

export type GetSisImportErrorListSisImportsResponses = {
    /**
     * No response was specified
     */
    200: Array<SisImportError>;
};

export type GetSisImportErrorListSisImportsResponse = GetSisImportErrorListSisImportsResponses[keyof GetSisImportErrorListSisImportsResponses];

export type RestoreWorkflowStatesOfSisImportedItemsData = {
    body?: {
        /**
         * If set, will only restore items that were deleted from batch_mode.
         */
        batch_mode?: boolean;
        /**
         * If set, will only restore enrollments that were concluded. This will
         * ignore any items that were created or deleted.
         */
        unconclude_only?: boolean;
        /**
         * If set, will only restore items that were deleted. This will ignore any
         * items that were created or modified.
         */
        undelete_only?: boolean;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/sis_imports/{id}/restore_states';
};

export type RestoreWorkflowStatesOfSisImportedItemsResponses = {
    /**
     * No response was specified
     */
    200: Progress;
};

export type RestoreWorkflowStatesOfSisImportedItemsResponse = RestoreWorkflowStatesOfSisImportedItemsResponses[keyof RestoreWorkflowStatesOfSisImportedItemsResponses];

export type ShowAccountAuthSettingsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/sso_settings';
};

export type ShowAccountAuthSettingsResponses = {
    /**
     * No response was specified
     */
    200: SsoSettings;
};

export type ShowAccountAuthSettingsResponse = ShowAccountAuthSettingsResponses[keyof ShowAccountAuthSettingsResponses];

export type UpdateAccountAuthSettingsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/sso_settings';
};

export type UpdateAccountAuthSettingsResponses = {
    /**
     * No response was specified
     */
    200: SsoSettings;
};

export type UpdateAccountAuthSettingsResponse = UpdateAccountAuthSettingsResponses[keyof UpdateAccountAuthSettingsResponses];

export type GetSubAccountsOfAccountData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * If true, the entire account tree underneath
         * this account will be returned (though still paginated). If false, only
         * direct sub-accounts of this account will be returned. Defaults to false.
         */
        recursive?: boolean;
    };
    url: '/v1/accounts/{account_id}/sub_accounts';
};

export type GetSubAccountsOfAccountResponses = {
    /**
     * No response was specified
     */
    200: Array<Account>;
};

export type GetSubAccountsOfAccountResponse = GetSubAccountsOfAccountResponses[keyof GetSubAccountsOfAccountResponses];

export type CreateNewSubAccountData = {
    body: {
        /**
         * The default group storage quota to be used, if not otherwise specified.
         */
        'account[default_group_storage_quota_mb]'?: number;
        /**
         * The default course storage quota to be used, if not otherwise specified.
         */
        'account[default_storage_quota_mb]'?: number;
        /**
         * The default user storage quota to be used, if not otherwise specified.
         */
        'account[default_user_storage_quota_mb]'?: number;
        /**
         * The name of the new sub-account.
         */
        'account[name]': string;
        /**
         * The account's identifier in the Student Information System.
         */
        'account[sis_account_id]'?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/sub_accounts';
};

export type CreateNewSubAccountResponses = {
    /**
     * No response was specified
     */
    200: Account;
};

export type CreateNewSubAccountResponse = CreateNewSubAccountResponses[keyof CreateNewSubAccountResponses];

export type DeleteSubAccountData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/sub_accounts/{id}';
};

export type DeleteSubAccountResponses = {
    /**
     * No response was specified
     */
    200: Account;
};

export type DeleteSubAccountResponse = DeleteSubAccountResponses[keyof DeleteSubAccountResponses];

export type ListEnrollmentTermsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
        /**
         * If set, only returns terms that are in the given state.
         * Defaults to 'active'.
         */
        workflow_state?: Array<'active' | 'deleted' | 'all'>;
        /**
         * Array of additional information to include.
         *
         * "overrides":: term start/end dates overridden for different enrollment types
         */
        include?: Array<'overrides'>;
    };
    url: '/v1/accounts/{account_id}/terms';
};

export type ListEnrollmentTermsResponses = {
    /**
     * No response was specified
     */
    200: Array<EnrollmentTerm>;
};

export type ListEnrollmentTermsResponse = ListEnrollmentTermsResponses[keyof ListEnrollmentTermsResponses];

export type CreateEnrollmentTermData = {
    body?: {
        /**
         * The day/time the term ends.
         * Accepts times in ISO 8601 format, e.g. 2015-01-10T18:48:00Z.
         */
        'enrollment_term[end_at]'?: string;
        /**
         * The name of the term.
         */
        'enrollment_term[name]'?: string;
        /**
         * The day/time the term ends, overridden for the given enrollment type.
         * *enrollment_type* can be one of StudentEnrollment, TeacherEnrollment, TaEnrollment, or DesignerEnrollment
         */
        'enrollment_term[overrides][enrollment_type][end_at]'?: string;
        /**
         * The day/time the term starts, overridden for the given enrollment type.
         * *enrollment_type* can be one of StudentEnrollment, TeacherEnrollment, TaEnrollment, or DesignerEnrollment
         */
        'enrollment_term[overrides][enrollment_type][start_at]'?: string;
        /**
         * The unique SIS identifier for the term.
         */
        'enrollment_term[sis_term_id]'?: string;
        /**
         * The day/time the term starts.
         * Accepts times in ISO 8601 format, e.g. 2015-01-10T18:48:00Z.
         */
        'enrollment_term[start_at]'?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/terms';
};

export type CreateEnrollmentTermResponses = {
    /**
     * No response was specified
     */
    200: EnrollmentTerm;
};

export type CreateEnrollmentTermResponse = CreateEnrollmentTermResponses[keyof CreateEnrollmentTermResponses];

export type DeleteEnrollmentTermData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/terms/{id}';
};

export type DeleteEnrollmentTermResponses = {
    /**
     * No response was specified
     */
    200: EnrollmentTerm;
};

export type DeleteEnrollmentTermResponse = DeleteEnrollmentTermResponses[keyof DeleteEnrollmentTermResponses];

export type UpdateEnrollmentTermData = {
    body?: {
        /**
         * The day/time the term ends.
         * Accepts times in ISO 8601 format, e.g. 2015-01-10T18:48:00Z.
         */
        'enrollment_term[end_at]'?: string;
        /**
         * The name of the term.
         */
        'enrollment_term[name]'?: string;
        /**
         * The day/time the term ends, overridden for the given enrollment type.
         * *enrollment_type* can be one of StudentEnrollment, TeacherEnrollment, TaEnrollment, or DesignerEnrollment
         */
        'enrollment_term[overrides][enrollment_type][end_at]'?: string;
        /**
         * The day/time the term starts, overridden for the given enrollment type.
         * *enrollment_type* can be one of StudentEnrollment, TeacherEnrollment, TaEnrollment, or DesignerEnrollment
         */
        'enrollment_term[overrides][enrollment_type][start_at]'?: string;
        /**
         * The unique SIS identifier for the term.
         */
        'enrollment_term[sis_term_id]'?: string;
        /**
         * The day/time the term starts.
         * Accepts times in ISO 8601 format, e.g. 2015-01-10T18:48:00Z.
         */
        'enrollment_term[start_at]'?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/terms/{id}';
};

export type UpdateEnrollmentTermResponses = {
    /**
     * No response was specified
     */
    200: EnrollmentTerm;
};

export type UpdateEnrollmentTermResponse = UpdateEnrollmentTermResponses[keyof UpdateEnrollmentTermResponses];

export type GetTermsOfServiceData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/terms_of_service';
};

export type GetTermsOfServiceResponses = {
    /**
     * No response was specified
     */
    200: TermsOfService;
};

export type GetTermsOfServiceResponse = GetTermsOfServiceResponses[keyof GetTermsOfServiceResponses];

export type ListUsersInAccountData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The partial name or full ID of the users to match and return in the
         * results list. Must be at least 3 characters.
         *
         * Note that the API will prefer matching on canonical user ID if the ID has
         * a numeric form. It will only search against other fields if non-numeric
         * in form, or if the numeric value doesn't yield any matches. Queries by
         * administrative users will search on SIS ID, login ID, name, or email
         * address; non-administrative queries will only be compared against name.
         */
        search_term?: string;
        /**
         * The column to sort results by.
         */
        sort?: 'username' | 'email' | 'sis_id' | 'last_login';
        /**
         * The order to sort the given column by.
         */
        order?: 'asc' | 'desc';
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/accounts/{account_id}/users';
};

export type ListUsersInAccountResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type ListUsersInAccountResponse = ListUsersInAccountResponses[keyof ListUsersInAccountResponses];

export type CreateUserData = {
    body: {
        /**
         * The communication channel address, e.g. the user's email address.
         */
        'communication_channel[address]'?: string;
        /**
         * Only valid for account admins. If true, returns the new user account
         * confirmation URL in the response.
         */
        'communication_channel[confirmation_url]'?: boolean;
        /**
         * Only valid for site admins and account admins making requests; If true, the channel is
         * automatically validated and no confirmation email or SMS is sent.
         * Otherwise, the user must respond to a confirmation message to confirm the
         * channel.
         *
         * If this is true, it is recommended to set <tt>"pseudonym[send_confirmation]"</tt> to true as well.
         * Otherwise, the user will not receive any messages about their account creation.
         */
        'communication_channel[skip_confirmation]'?: boolean;
        /**
         * The communication channel type, e.g. 'email' or 'sms'.
         */
        'communication_channel[type]'?: string;
        /**
         * If you're setting the password for the newly created user, you can provide this param
         * with a valid URL pointing into this Canvas installation, and the response will include
         * a destination field that's a URL that you can redirect a browser to and have the newly
         * created user automatically logged in. The URL is only valid for a short time, and must
         * match the domain this request is directed to, and be for a well-formed path that Canvas
         * can recognize.
         */
        destination?: unknown;
        /**
         * When true, will first try to re-activate a deleted user with matching sis_user_id if possible.
         */
        enable_sis_reactivation?: boolean;
        /**
         * If true, validations are performed on the newly created user (and their associated pseudonym)
         * even if the request is made by a privileged user like an admin. When set to false,
         * or not included in the request parameters, any newly created users are subject to
         * validations unless the request is made by a user with a 'manage_user_logins' right.
         * In which case, certain validations such as 'require_acceptance_of_terms' and
         * 'require_presence_of_name' are not enforced. Use this parameter to return helpful json
         * errors while building users with an admin request.
         */
        force_validations?: boolean;
        /**
         * The authentication provider this login is associated with. Logins
         * associated with a specific provider can only be used with that provider.
         * Legacy providers (LDAP, CAS, SAML) will search for logins associated with
         * them, or unassociated logins. New providers will only search for logins
         * explicitly associated with them. This can be the integer ID of the
         * provider, or the type of the provider (in which case, it will find the
         * first matching provider).
         */
        'pseudonym[authentication_provider_id]'?: string;
        /**
         * Send user a self-registration style email if true.
         * Setting it means the users will get a notification asking them
         * to "complete the registration process" by clicking it, setting
         * a password, and letting them in.  Will only be executed on
         * if the user does not need admin approval.
         * Defaults to false unless explicitly provided.
         */
        'pseudonym[force_self_registration]'?: boolean;
        /**
         * Integration ID for the login. To set this parameter, the caller must be able to
         * manage SIS permissions. The Integration ID is a secondary
         * identifier useful for more complex SIS integrations.
         */
        'pseudonym[integration_id]'?: string;
        /**
         * User's password. Cannot be set during self-registration.
         */
        'pseudonym[password]'?: string;
        /**
         * Send user notification of account creation if true.
         * Automatically set to true during self-registration.
         */
        'pseudonym[send_confirmation]'?: boolean;
        /**
         * SIS ID for the user's account. To set this parameter, the caller must be
         * able to manage SIS permissions.
         */
        'pseudonym[sis_user_id]'?: string;
        /**
         * User's login ID. If this is a self-registration, it must be a valid
         * email address.
         */
        'pseudonym[unique_id]': string;
        /**
         * The user's birth date.
         */
        'user[birthdate]'?: string;
        /**
         * The user's preferred language, from the list of languages Canvas supports.
         * This is in RFC-5646 format.
         */
        'user[locale]'?: string;
        /**
         * The full name of the user. This name will be used by teacher for grading.
         * Required if this is a self-registration.
         */
        'user[name]'?: string;
        /**
         * User's name as it will be displayed in discussions, messages, and comments.
         */
        'user[short_name]'?: string;
        /**
         * Automatically mark the user as registered.
         *
         * If this is true, it is recommended to set <tt>"pseudonym[send_confirmation]"</tt> to true as well.
         * Otherwise, the user will not receive any messages about their account creation.
         *
         * The users communication channel confirmation can be skipped by setting
         * <tt>"communication_channel[skip_confirmation]"</tt> to true as well.
         */
        'user[skip_registration]'?: boolean;
        /**
         * User's name as used to sort alphabetically in lists.
         */
        'user[sortable_name]'?: string;
        /**
         * Whether the user accepts the terms of use. Required if this is a
         * self-registration and this canvas instance requires users to accept
         * the terms (on by default).
         *
         * If this is true, it will mark the user as having accepted the terms of use.
         */
        'user[terms_of_use]'?: boolean;
        /**
         * The time zone for the user. Allowed time zones are
         * {http://www.iana.org/time-zones IANA time zones} or friendlier
         * {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
         */
        'user[time_zone]'?: string;
    };
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/users';
};

export type CreateUserResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type CreateUserResponse = CreateUserResponses[keyof CreateUserResponses];

export type DeleteUserFromRootAccountData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/accounts/{account_id}/users/{user_id}';
};

export type DeleteUserFromRootAccountResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type DeleteUserFromRootAccountResponse = DeleteUserFromRootAccountResponses[keyof DeleteUserFromRootAccountResponses];

export type GetSingleAccountData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{id}';
};

export type GetSingleAccountResponses = {
    /**
     * No response was specified
     */
    200: Account;
};

export type GetSingleAccountResponse = GetSingleAccountResponses[keyof GetSingleAccountResponses];

export type UpdateAccountData = {
    body?: {
        /**
         * The default group storage quota to be used, if not otherwise specified.
         */
        'account[default_group_storage_quota_mb]'?: number;
        /**
         * The default course storage quota to be used, if not otherwise specified.
         */
        'account[default_storage_quota_mb]'?: number;
        /**
         * The default time zone of the account. Allowed time zones are
         * {http://www.iana.org/time-zones IANA time zones} or friendlier
         * {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
         */
        'account[default_time_zone]'?: string;
        /**
         * The default user storage quota to be used, if not otherwise specified.
         */
        'account[default_user_storage_quota_mb]'?: number;
        /**
         * Updates the account name
         */
        'account[name]'?: string;
        /**
         * Give this a set of keys and boolean values to enable or disable services matching the keys
         */
        'account[services]'?: unknown;
        /**
         * Lock this setting for sub-accounts and courses
         */
        'account[settings][lock_all_announcements][locked]'?: boolean;
        /**
         * Disable comments on announcements
         */
        'account[settings][lock_all_announcements][value]'?: boolean;
        /**
         * Lock this setting for sub-accounts and courses
         */
        'account[settings][restrict_student_future_listing][locked]'?: boolean;
        /**
         * Restrict students from viewing future enrollments in course list
         */
        'account[settings][restrict_student_future_listing][value]'?: boolean;
        /**
         * Lock this setting for sub-accounts and courses
         */
        'account[settings][restrict_student_future_view][locked]'?: boolean;
        /**
         * Restrict students from viewing courses before start date
         */
        'account[settings][restrict_student_future_view][value]'?: boolean;
        /**
         * Lock this setting for sub-accounts and courses
         */
        'account[settings][restrict_student_past_view][locked]'?: boolean;
        /**
         * Restrict students from viewing courses after end date
         */
        'account[settings][restrict_student_past_view][value]'?: boolean;
        /**
         * Updates the account sis_account_id
         * Must have manage_sis permission and must not be a root_account.
         */
        'account[sis_account_id]'?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{id}';
};

export type UpdateAccountResponses = {
    /**
     * No response was specified
     */
    200: Account;
};

export type UpdateAccountResponse = UpdateAccountResponses[keyof UpdateAccountResponses];

export type ListAnnouncementsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * List of context_codes to retrieve announcements for (for example, +course_123+). Only courses
         * are presently supported. The call will fail unless the caller has View Announcements permission
         * in all listed courses.
         */
        context_codes: Array<string>;
        /**
         * Only return announcements posted since the start_date (inclusive).
         * Defaults to 14 days ago. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         */
        start_date?: string;
        /**
         * Only return announcements posted before the end_date (inclusive).
         * Defaults to 28 days from start_date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         * Announcements scheduled for future posting will only be returned to course administrators.
         */
        end_date?: string;
        /**
         * Only return active announcements that have been published.
         * Applies only to requesting users that have permission to view
         * unpublished items.
         * Defaults to false for users with access to view unpublished items,
         * otherwise true and unmodifiable.
         */
        active_only?: boolean;
        /**
         * Optional list of resources to include with the response. May include
         * a string of the name of the resource. Possible values are:
         * "sections", "sections_user_count"
         * if "sections" is passed, includes the course sections that are associated
         * with the topic, if the topic is specific to sertain sections of the course.
         * If "sections_user_count" is passed, then:
         * (a) If sections were asked for *and* the topic is specific to certain
         * course sections sections, includes the number of users in each
         * section. (as part of the section json asked for above)
         * (b) Else, includes at the root level the total number of users in the
         * topic's context (group or course) that the topic applies to.
         */
        include?: Array<string>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/announcements';
};

export type ListAnnouncementsResponses = {
    /**
     * No response was specified
     */
    200: Array<DiscussionTopic>;
};

export type ListAnnouncementsResponse = ListAnnouncementsResponses[keyof ListAnnouncementsResponses];

export type ListAppointmentGroupsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Defaults to "reservable"
         */
        scope?: 'reservable' | 'manageable';
        /**
         * Array of context codes used to limit returned results.
         */
        context_codes?: Array<string>;
        /**
         * Defaults to false. If true, includes past appointment groups
         */
        include_past_appointments?: boolean;
        /**
         * Array of additional information to include.
         *
         * "appointments":: calendar event time slots for this appointment group
         * "child_events":: reservations of those time slots
         * "participant_count":: number of reservations
         * "reserved_times":: the event id, start time and end time of reservations
         * the current user has made)
         * "all_context_codes":: all context codes associated with this appointment group
         */
        include?: Array<'appointments' | 'child_events' | 'participant_count' | 'reserved_times' | 'all_context_codes'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/appointment_groups';
};

export type ListAppointmentGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateAppointmentGroupData = {
    body: {
        /**
         * Array of context codes (courses, e.g. course_1) this group should be
         * linked to (1 or more). Users in the course(s) with appropriate permissions
         * will be able to sign up for this appointment group.
         */
        'appointment_group[context_codes]': Array<string>;
        /**
         * Longer text description of the appointment group.
         */
        'appointment_group[description]'?: string;
        /**
         * Location address.
         */
        'appointment_group[location_address]'?: string;
        /**
         * Location name of the appointment group.
         */
        'appointment_group[location_name]'?: string;
        /**
         * Maximum number of time slots a user may register for.
         */
        'appointment_group[max_appointments_per_participant]'?: number;
        /**
         * Minimum number of time slots a user must register for. If not set, users
         * do not need to sign up for any time slots.
         */
        'appointment_group[min_appointments_per_participant]'?: number;
        /**
         * Nested array of start time/end time pairs indicating time slots for this
         * appointment group. Refer to the example request.
         */
        'appointment_group[new_appointments][X]'?: Array<string>;
        /**
         * "private":: participants cannot see who has signed up for a particular
         * time slot
         * "protected":: participants can see who has signed up.  Defaults to
         * "private".
         */
        'appointment_group[participant_visibility]'?: 'private' | 'protected';
        /**
         * Maximum number of participants that may register for each time slot.
         * Defaults to null (no limit).
         */
        'appointment_group[participants_per_appointment]'?: number;
        /**
         * Indicates whether this appointment group should be published (i.e. made
         * available for signup). Once published, an appointment group cannot be
         * unpublished. Defaults to false.
         */
        'appointment_group[publish]'?: boolean;
        /**
         * Array of sub context codes (course sections or a single group category)
         * this group should be linked to. Used to limit the appointment group to
         * particular sections. If a group category is specified, students will sign
         * up in groups and the participant_type will be "Group" instead of "User".
         */
        'appointment_group[sub_context_codes]'?: Array<string>;
        /**
         * Short title for the appointment group.
         */
        'appointment_group[title]': string;
    };
    path?: never;
    query?: never;
    url: '/v1/appointment_groups';
};

export type CreateAppointmentGroupResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetNextAppointmentData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * List of ids of appointment groups to search.
         */
        appointment_group_ids?: Array<string>;
    };
    url: '/v1/appointment_groups/next_appointment';
};

export type GetNextAppointmentResponses = {
    /**
     * No response was specified
     */
    200: Array<CalendarEvent>;
};

export type GetNextAppointmentResponse = GetNextAppointmentResponses[keyof GetNextAppointmentResponses];

export type DeleteAppointmentGroupData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Reason for deleting/canceling the appointment group.
         */
        cancel_reason?: string;
    };
    url: '/v1/appointment_groups/{id}';
};

export type DeleteAppointmentGroupResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleAppointmentGroupData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Array of additional information to include. See include[] argument of
         * "List appointment groups" action.
         *
         * "child_events":: reservations of time slots time slots
         * "appointments":: will always be returned
         * "all_context_codes":: all context codes associated with this appointment group
         */
        include?: Array<'child_events' | 'appointments' | 'all_context_codes'>;
    };
    url: '/v1/appointment_groups/{id}';
};

export type GetSingleAppointmentGroupResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateAppointmentGroupData = {
    body: {
        /**
         * Array of context codes (courses, e.g. course_1) this group should be
         * linked to (1 or more). Users in the course(s) with appropriate permissions
         * will be able to sign up for this appointment group.
         */
        'appointment_group[context_codes]': Array<string>;
        /**
         * Longer text description of the appointment group.
         */
        'appointment_group[description]'?: string;
        /**
         * Location address.
         */
        'appointment_group[location_address]'?: string;
        /**
         * Location name of the appointment group.
         */
        'appointment_group[location_name]'?: string;
        /**
         * Maximum number of time slots a user may register for.
         */
        'appointment_group[max_appointments_per_participant]'?: number;
        /**
         * Minimum number of time slots a user must register for. If not set, users
         * do not need to sign up for any time slots.
         */
        'appointment_group[min_appointments_per_participant]'?: number;
        /**
         * Nested array of start time/end time pairs indicating time slots for this
         * appointment group. Refer to the example request.
         */
        'appointment_group[new_appointments][X]'?: Array<string>;
        /**
         * "private":: participants cannot see who has signed up for a particular
         * time slot
         * "protected":: participants can see who has signed up. Defaults to "private".
         */
        'appointment_group[participant_visibility]'?: 'private' | 'protected';
        /**
         * Maximum number of participants that may register for each time slot.
         * Defaults to null (no limit).
         */
        'appointment_group[participants_per_appointment]'?: number;
        /**
         * Indicates whether this appointment group should be published (i.e. made
         * available for signup). Once published, an appointment group cannot be
         * unpublished. Defaults to false.
         */
        'appointment_group[publish]'?: boolean;
        /**
         * Array of sub context codes (course sections or a single group category)
         * this group should be linked to. Used to limit the appointment group to
         * particular sections. If a group category is specified, students will sign
         * up in groups and the participant_type will be "Group" instead of "User".
         */
        'appointment_group[sub_context_codes]'?: Array<string>;
        /**
         * Short title for the appointment group.
         */
        'appointment_group[title]'?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/appointment_groups/{id}';
};

export type UpdateAppointmentGroupResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListStudentGroupParticipantsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Limits results to the a given participation status, defaults to "all"
         */
        registration_status?: 'all' | 'registered';
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/appointment_groups/{id}/groups';
};

export type ListStudentGroupParticipantsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListUserParticipantsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Limits results to the a given participation status, defaults to "all"
         */
        registration_status?: 'all' | 'registered';
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/appointment_groups/{id}/users';
};

export type ListUserParticipantsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type QueryByAccountData = {
    body?: never;
    path: {
        /**
         * ID
         */
        account_id: string;
    };
    query?: {
        /**
         * The beginning of the time range from which you want events.
         * Events are stored for one year.
         */
        start_time?: string;
        /**
         * The end of the time range from which you want events.
         */
        end_time?: string;
    };
    url: '/v1/audit/authentication/accounts/{account_id}';
};

export type QueryByAccountResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type QueryByLoginData = {
    body?: never;
    path: {
        /**
         * ID
         */
        login_id: string;
    };
    query?: {
        /**
         * The beginning of the time range from which you want events.
         * Events are stored for one year.
         */
        start_time?: string;
        /**
         * The end of the time range from which you want events.
         */
        end_time?: string;
    };
    url: '/v1/audit/authentication/logins/{login_id}';
};

export type QueryByLoginResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type QueryByUserData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * The beginning of the time range from which you want events.
         * Events are stored for one year.
         */
        start_time?: string;
        /**
         * The end of the time range from which you want events.
         */
        end_time?: string;
    };
    url: '/v1/audit/authentication/users/{user_id}';
};

export type QueryByUserResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type QueryByCourseData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The beginning of the time range from which you want events.
         */
        start_time?: string;
        /**
         * The end of the time range from which you want events.
         */
        end_time?: string;
    };
    url: '/v1/audit/course/courses/{course_id}';
};

export type QueryByCourseResponses = {
    /**
     * No response was specified
     */
    200: Array<CourseEvent>;
};

export type QueryByCourseResponse = QueryByCourseResponses[keyof QueryByCourseResponses];

export type QueryByAssignmentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * The beginning of the time range from which you want events.
         */
        start_time?: string;
        /**
         * The end of the time range from which you want events.
         */
        end_time?: string;
    };
    url: '/v1/audit/grade_change/assignments/{assignment_id}';
};

export type QueryByAssignmentResponses = {
    /**
     * No response was specified
     */
    200: Array<GradeChangeEvent>;
};

export type QueryByAssignmentResponse = QueryByAssignmentResponses[keyof QueryByAssignmentResponses];

export type QueryByCourseGradeChangeData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The beginning of the time range from which you want events.
         */
        start_time?: string;
        /**
         * The end of the time range from which you want events.
         */
        end_time?: string;
    };
    url: '/v1/audit/grade_change/courses/{course_id}';
};

export type QueryByCourseGradeChangeResponses = {
    /**
     * No response was specified
     */
    200: Array<GradeChangeEvent>;
};

export type QueryByCourseGradeChangeResponse = QueryByCourseGradeChangeResponses[keyof QueryByCourseGradeChangeResponses];

export type QueryByGraderData = {
    body?: never;
    path: {
        /**
         * ID
         */
        grader_id: string;
    };
    query?: {
        /**
         * The beginning of the time range from which you want events.
         */
        start_time?: string;
        /**
         * The end of the time range from which you want events.
         */
        end_time?: string;
    };
    url: '/v1/audit/grade_change/graders/{grader_id}';
};

export type QueryByGraderResponses = {
    /**
     * No response was specified
     */
    200: Array<GradeChangeEvent>;
};

export type QueryByGraderResponse = QueryByGraderResponses[keyof QueryByGraderResponses];

export type QueryByStudentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        student_id: string;
    };
    query?: {
        /**
         * The beginning of the time range from which you want events.
         */
        start_time?: string;
        /**
         * The end of the time range from which you want events.
         */
        end_time?: string;
    };
    url: '/v1/audit/grade_change/students/{student_id}';
};

export type QueryByStudentResponses = {
    /**
     * No response was specified
     */
    200: Array<GradeChangeEvent>;
};

export type QueryByStudentResponse = QueryByStudentResponses[keyof QueryByStudentResponses];

export type GetBrandConfigVariablesThatShouldBeUsedForThisDomainData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/brand_variables';
};

export type GetBrandConfigVariablesThatShouldBeUsedForThisDomainResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListCalendarEventsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Defaults to "event"
         */
        type?: 'event' | 'assignment';
        /**
         * Only return events since the start_date (inclusive).
         * Defaults to today. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         */
        start_date?: string;
        /**
         * Only return events before the end_date (inclusive).
         * Defaults to start_date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         * If end_date is the same as start_date, then only events on that day are
         * returned.
         */
        end_date?: string;
        /**
         * Defaults to false (dated events only).
         * If true, only return undated events and ignore start_date and end_date.
         */
        undated?: boolean;
        /**
         * Defaults to false (uses start_date, end_date, and undated criteria).
         * If true, all events are returned, ignoring start_date, end_date, and undated criteria.
         */
        all_events?: boolean;
        /**
         * List of context codes of courses/groups/users whose events you want to see.
         * If not specified, defaults to the current user (i.e personal calendar,
         * no course/group events). Limited to 10 context codes, additional ones are
         * ignored. The format of this field is the context type, followed by an
         * underscore, followed by the context id. For example: course_42
         */
        context_codes?: Array<string>;
        /**
         * Array of attributes to exclude. Possible values are "description", "child_events" and "assignment"
         */
        excludes?: Array<Array<{
            [key: string]: unknown;
        }>>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/calendar_events';
};

export type ListCalendarEventsResponses = {
    /**
     * No response was specified
     */
    200: Array<CalendarEvent>;
};

export type ListCalendarEventsResponse = ListCalendarEventsResponses[keyof ListCalendarEventsResponses];

export type CreateCalendarEventData = {
    body: {
        /**
         * When true event is considered to span the whole day and times are ignored.
         */
        'calendar_event[all_day]'?: boolean;
        /**
         * Context code(s) corresponding to the section-level start and end time(s).
         */
        'calendar_event[child_event_data][X][context_code]'?: string;
        /**
         * Section-level end time(s) if this is a course event.
         */
        'calendar_event[child_event_data][X][end_at]'?: string;
        /**
         * Section-level start time(s) if this is a course event. X can be any
         * identifier, provided that it is consistent across the start_at, end_at
         * and context_code
         */
        'calendar_event[child_event_data][X][start_at]'?: string;
        /**
         * Context code of the course/group/user whose calendar this event should be
         * added to.
         */
        'calendar_event[context_code]': string;
        /**
         * Longer HTML description of the event.
         */
        'calendar_event[description]'?: string;
        /**
         * Defaults to false.  If set to `true`, an increasing counter number will be appended to the event title
         * when the event is duplicated.  (e.g. Event 1, Event 2, Event 3, etc)
         */
        'calendar_event[duplicate][append_iterator]'?: boolean;
        /**
         * Number of times to copy/duplicate the event.  Count cannot exceed 200.
         */
        'calendar_event[duplicate][count]'?: number;
        /**
         * Defaults to "weekly".  The frequency at which to duplicate the event
         */
        'calendar_event[duplicate][frequency]'?: 'daily' | 'weekly' | 'monthly';
        /**
         * Defaults to 1 if duplicate `count` is set.  The interval between the duplicated events.
         */
        'calendar_event[duplicate][interval]'?: number;
        /**
         * End date/time of the event.
         */
        'calendar_event[end_at]'?: string;
        /**
         * Location address
         */
        'calendar_event[location_address]'?: string;
        /**
         * Location name of the event.
         */
        'calendar_event[location_name]'?: string;
        /**
         * Start date/time of the event.
         */
        'calendar_event[start_at]'?: string;
        /**
         * Time zone of the user editing the event. Allowed time zones are
         * {http://www.iana.org/time-zones IANA time zones} or friendlier
         * {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
         */
        'calendar_event[time_zone_edited]'?: string;
        /**
         * Short title for the calendar event.
         */
        'calendar_event[title]'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/calendar_events';
};

export type CreateCalendarEventResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteCalendarEventData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Reason for deleting/canceling the event.
         */
        cancel_reason?: string;
    };
    url: '/v1/calendar_events/{id}';
};

export type DeleteCalendarEventResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleCalendarEventOrAssignmentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/calendar_events/{id}';
};

export type GetSingleCalendarEventOrAssignmentResponses = {
    /**
     * No response was specified
     */
    200: CalendarEvent;
};

export type GetSingleCalendarEventOrAssignmentResponse = GetSingleCalendarEventOrAssignmentResponses[keyof GetSingleCalendarEventOrAssignmentResponses];

export type UpdateCalendarEventData = {
    body?: {
        /**
         * When true event is considered to span the whole day and times are ignored.
         */
        'calendar_event[all_day]'?: boolean;
        /**
         * Context code(s) corresponding to the section-level start and end time(s).
         */
        'calendar_event[child_event_data][X][context_code]'?: string;
        /**
         * Section-level end time(s) if this is a course event.
         */
        'calendar_event[child_event_data][X][end_at]'?: string;
        /**
         * Section-level start time(s) if this is a course event. X can be any
         * identifier, provided that it is consistent across the start_at, end_at
         * and context_code
         */
        'calendar_event[child_event_data][X][start_at]'?: string;
        /**
         * Context code of the course/group/user to move this event to.
         * Scheduler appointments and events with section-specific times cannot be moved between calendars.
         */
        'calendar_event[context_code]'?: string;
        /**
         * Longer HTML description of the event.
         */
        'calendar_event[description]'?: string;
        /**
         * End date/time of the event.
         */
        'calendar_event[end_at]'?: string;
        /**
         * Location address
         */
        'calendar_event[location_address]'?: string;
        /**
         * Location name of the event.
         */
        'calendar_event[location_name]'?: string;
        /**
         * Start date/time of the event.
         */
        'calendar_event[start_at]'?: string;
        /**
         * Time zone of the user editing the event. Allowed time zones are
         * {http://www.iana.org/time-zones IANA time zones} or friendlier
         * {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
         */
        'calendar_event[time_zone_edited]'?: string;
        /**
         * Short title for the calendar event.
         */
        'calendar_event[title]'?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/calendar_events/{id}';
};

export type UpdateCalendarEventResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ReserveTimeSlotData = {
    body?: {
        /**
         * Defaults to false. If true, cancel any previous reservation(s) for this
         * participant and appointment group.
         */
        cancel_existing?: boolean;
        /**
         * Comments to associate with this reservation
         */
        comments?: string;
        /**
         * User or group id for whom you are making the reservation (depends on the
         * participant type). Defaults to the current user (or user's candidate group).
         */
        participant_id?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/calendar_events/{id}/reservations';
};

export type ReserveTimeSlotResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ReserveTimeSlotParticipantIdData = {
    body?: {
        /**
         * Defaults to false. If true, cancel any previous reservation(s) for this
         * participant and appointment group.
         */
        cancel_existing?: boolean;
        /**
         * Comments to associate with this reservation
         */
        comments?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
        /**
         * User or group id for whom you are making the reservation (depends on the
         * participant type). Defaults to the current user (or user's candidate group).
         */
        participant_id: string;
    };
    query?: never;
    url: '/v1/calendar_events/{id}/reservations/{participant_id}';
};

export type ReserveTimeSlotParticipantIdResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListMembersOfCollaborationData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * - "collaborator_lti_id": Optional information to include with each member.
         * Represents an identifier to be used for the member in an LTI context.
         * - "avatar_image_url": Optional information to include with each member.
         * The url for the avatar of a collaborator with type 'user'.
         */
        include?: Array<'collaborator_lti_id' | 'avatar_image_url'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/collaborations/{id}/members';
};

export type ListMembersOfCollaborationResponses = {
    /**
     * No response was specified
     */
    200: Array<Collaborator>;
};

export type ListMembersOfCollaborationResponse = ListMembersOfCollaborationResponses[keyof ListMembersOfCollaborationResponses];

export type ListOfCommmessagesForUserData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The user id for whom you want to retrieve CommMessages
         */
        user_id: string;
        /**
         * The beginning of the time range you want to retrieve message from.
         */
        start_time?: string;
        /**
         * The end of the time range you want to retrieve messages for.
         */
        end_time?: string;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/comm_messages';
};

export type ListOfCommmessagesForUserResponses = {
    /**
     * No response was specified
     */
    200: Array<CommMessage>;
};

export type ListOfCommmessagesForUserResponse = ListOfCommmessagesForUserResponses[keyof ListOfCommmessagesForUserResponses];

export type ListConversationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * When set, only return conversations of the specified type. For example,
         * set to "unread" to return only conversations that haven't been read.
         * The default behavior is to return all non-archived conversations (i.e.
         * read and unread).
         */
        scope?: 'unread' | 'starred' | 'archived';
        /**
         * When set, only return conversations for the specified courses, groups
         * or users. The id should be prefixed with its type, e.g. "user_123" or
         * "course_456". Can be an array (by setting "filter[]") or single value
         * (by setting "filter")
         */
        filter?: Array<string>;
        /**
         * When filter[] contains multiple filters, combine them with this mode,
         * filtering conversations that at have at least all of the contexts ("and")
         * or at least one of the contexts ("or")
         */
        filter_mode?: 'and' | 'or' | 'default or';
        /**
         * (Obsolete) Submissions are no
         * longer linked to conversations. This parameter is ignored.
         */
        interleave_submissions?: boolean;
        /**
         * Default is false. If true,
         * the top-level element of the response will be an object rather than
         * an array, and will have the keys "conversations" which will contain the
         * paged conversation data, and "conversation_ids" which will contain the
         * ids of all conversations under this scope/filter in the same order.
         */
        include_all_conversation_ids?: boolean;
        /**
         * "participant_avatars":: Optionally include an "avatar_url" key for each user participanting in the conversation
         */
        include?: Array<'participant_avatars'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/conversations';
};

export type ListConversationsResponses = {
    /**
     * No response was specified
     */
    200: Array<Conversation>;
};

export type ListConversationsResponse = ListConversationsResponses[keyof ListConversationsResponses];

export type CreateConversationData = {
    body: {
        /**
         * An array of attachments ids. These must be files that have been previously
         * uploaded to the sender's "conversation attachments" folder.
         */
        attachment_ids?: Array<string>;
        /**
         * The message to be sent
         */
        body: string;
        /**
         * The course or group that is the context for this conversation. Same format
         * as courses or groups in the recipients argument.
         */
        context_code?: string;
        /**
         * Used when generating "visible" in the API response. See the explanation
         * under the {api:ConversationsController#index index API action}
         */
        filter?: Array<string>;
        /**
         * Used when generating "visible" in the API response. See the explanation
         * under the {api:ConversationsController#index index API action}
         */
        filter_mode?: 'and' | 'or' | 'default or';
        /**
         * Defaults to false. If true, this will be a group conversation (i.e. all
         * recipients may see all messages and replies). If false, individual private
         * conversations will be started with each recipient. Must be set false if the
         * number of recipients is over the set maximum (default is 100).
         */
        group_conversation?: boolean;
        /**
         * Media comment id of an audio of video file to be associated with this
         * message.
         */
        media_comment_id?: string;
        /**
         * Type of the associated media file
         */
        media_comment_type?: 'audio' | 'video';
        /**
         * Determines whether the messages will be created/sent synchronously or
         * asynchronously. Defaults to sync, and this option is ignored if this is a
         * group conversation or there is just one recipient (i.e. it must be a bulk
         * private message). When sent async, the response will be an empty array
         * (batch status can be queried via the {api:ConversationsController#batches batches API})
         */
        mode?: 'sync' | 'async';
        /**
         * An array of recipient ids. These may be user ids or course/group ids
         * prefixed with "course_" or "group_" respectively, e.g.
         * recipients[]=1&recipients[]=2&recipients[]=course_3. If the course/group
         * has over 100 enrollments, 'bulk_message' and 'group_conversation' must be
         * set to true.
         */
        recipients: Array<string>;
        /**
         * Used when generating "visible" in the API response. See the explanation
         * under the {api:ConversationsController#index index API action}
         */
        scope?: 'unread' | 'starred' | 'archived';
        /**
         * The subject of the conversation. This is ignored when reusing a
         * conversation. Maximum length is 255 characters.
         */
        subject?: string;
        /**
         * Will add a faculty journal entry for each recipient as long as the user
         * making the api call has permission, the recipient is a student and
         * faculty journals are enabled in the account.
         */
        user_note?: boolean;
    };
    path?: never;
    query?: never;
    url: '/v1/conversations';
};

export type CreateConversationResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type BatchUpdateConversationsData = {
    body: {
        /**
         * List of conversations to update. Limited to 500 conversations.
         */
        conversation_ids: Array<string>;
        /**
         * The action to take on each conversation.
         */
        event: 'mark_as_read' | 'mark_as_unread' | 'star' | 'unstar' | 'archive' | 'destroy';
    };
    path?: never;
    query?: never;
    url: '/v1/conversations';
};

export type BatchUpdateConversationsResponses = {
    /**
     * No response was specified
     */
    200: Progress;
};

export type BatchUpdateConversationsResponse = BatchUpdateConversationsResponses[keyof BatchUpdateConversationsResponses];

export type GetRunningBatchesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/conversations/batches';
};

export type GetRunningBatchesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type FindRecipientsConversationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Search terms used for matching users/courses/groups (e.g. "bob smith"). If
         * multiple terms are given (separated via whitespace), only results matching
         * all terms will be returned.
         */
        search?: string;
        /**
         * Limit the search to a particular course/group (e.g. "course_3" or "group_4").
         */
        context?: string;
        /**
         * Array of ids to exclude from the search. These may be user ids or
         * course/group ids prefixed with "course_" or "group_" respectively,
         * e.g. exclude[]=1&exclude[]=2&exclude[]=course_3
         */
        exclude?: Array<string>;
        /**
         * Limit the search just to users or contexts (groups/courses).
         */
        type?: 'user' | 'context';
        /**
         * Search for a specific user id. This ignores the other above parameters,
         * and will never return more than one result.
         */
        user_id?: number;
        /**
         * When searching by user_id, only users that could be normally messaged by
         * this user will be returned. This parameter allows you to specify a
         * conversation that will be referenced for a shared context -- if both the
         * current user and the searched user are in the conversation, the user will
         * be returned. This is used to start new side conversations.
         */
        from_conversation_id?: number;
        /**
         * Array of permission strings to be checked for each matched context (e.g.
         * "send_messages"). This argument determines which permissions may be
         * returned in the response; it won't prevent contexts from being returned if
         * they don't grant the permission(s).
         */
        permissions?: Array<string>;
    };
    url: '/v1/conversations/find_recipients';
};

export type FindRecipientsConversationsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkAllAsReadData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/conversations/mark_all_as_read';
};

export type MarkAllAsReadResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UnreadCountData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/conversations/unread_count';
};

export type UnreadCountResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteConversationData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/conversations/{id}';
};

export type DeleteConversationResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleConversationData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * (Obsolete) Submissions are no
         * longer linked to conversations. This parameter is ignored.
         */
        interleave_submissions?: boolean;
        /**
         * Used when generating "visible" in the API response. See the explanation
         * under the {api:ConversationsController#index index API action}
         */
        scope?: 'unread' | 'starred' | 'archived';
        /**
         * Used when generating "visible" in the API response. See the explanation
         * under the {api:ConversationsController#index index API action}
         */
        filter?: Array<string>;
        /**
         * Used when generating "visible" in the API response. See the explanation
         * under the {api:ConversationsController#index index API action}
         */
        filter_mode?: 'and' | 'or' | 'default or';
        /**
         * Default true. If true, unread
         * conversations will be automatically marked as read. This will default
         * to false in a future API release, so clients should explicitly send
         * true if that is the desired behavior.
         */
        auto_mark_as_read?: boolean;
    };
    url: '/v1/conversations/{id}';
};

export type GetSingleConversationResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type EditConversationData = {
    body?: {
        /**
         * Toggle the starred state of the current user's view of the conversation.
         */
        'conversation[starred]'?: boolean;
        /**
         * Toggle the current user's subscription to the conversation (only valid for
         * group conversations). If unsubscribed, the user will still have access to
         * the latest messages, but the conversation won't be automatically flagged
         * as unread, nor will it jump to the top of the inbox.
         */
        'conversation[subscribed]'?: boolean;
        /**
         * Change the state of this conversation
         */
        'conversation[workflow_state]'?: 'read' | 'unread' | 'archived';
        /**
         * Used when generating "visible" in the API response. See the explanation
         * under the {api:ConversationsController#index index API action}
         */
        filter?: Array<string>;
        /**
         * Used when generating "visible" in the API response. See the explanation
         * under the {api:ConversationsController#index index API action}
         */
        filter_mode?: 'and' | 'or' | 'default or';
        /**
         * Used when generating "visible" in the API response. See the explanation
         * under the {api:ConversationsController#index index API action}
         */
        scope?: 'unread' | 'starred' | 'archived';
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/conversations/{id}';
};

export type EditConversationResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type AddMessageData = {
    body: {
        /**
         * An array of attachments ids. These must be files that have been previously
         * uploaded to the sender's "conversation attachments" folder.
         */
        attachment_ids?: Array<string>;
        /**
         * The message to be sent.
         */
        body: string;
        /**
         * no description
         */
        included_messages?: Array<string>;
        /**
         * Media comment id of an audio of video file to be associated with this
         * message.
         */
        media_comment_id?: string;
        /**
         * Type of the associated media file.
         */
        media_comment_type?: 'audio' | 'video';
        /**
         * no description
         */
        recipients?: Array<string>;
        /**
         * Will add a faculty journal entry for each recipient as long as the user
         * making the api call has permission, the recipient is a student and
         * faculty journals are enabled in the account.
         */
        user_note?: boolean;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/conversations/{id}/add_message';
};

export type AddMessageResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type AddRecipientsData = {
    body: {
        /**
         * An array of recipient ids. These may be user ids or course/group ids
         * prefixed with "course_" or "group_" respectively, e.g.
         * recipients[]=1&recipients[]=2&recipients[]=course_3
         */
        recipients: Array<string>;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/conversations/{id}/add_recipients';
};

export type AddRecipientsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteMessageData = {
    body: {
        /**
         * Array of message ids to be deleted
         */
        remove: Array<string>;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/conversations/{id}/remove_messages';
};

export type DeleteMessageResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListAccountsForCourseAdminsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/course_accounts';
};

export type ListAccountsForCourseAdminsResponses = {
    /**
     * No response was specified
     */
    200: Array<Account>;
};

export type ListAccountsForCourseAdminsResponse = ListAccountsForCourseAdminsResponses[keyof ListAccountsForCourseAdminsResponses];

export type ListYourCoursesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
        /**
         * When set, only return courses where the user is enrolled as this type. For
         * example, set to "teacher" to return only courses where the user is
         * enrolled as a Teacher.  This argument is ignored if enrollment_role is given.
         */
        enrollment_type?: 'teacher' | 'student' | 'ta' | 'observer' | 'designer';
        /**
         * Deprecated
         * When set, only return courses where the user is enrolled with the specified
         * course-level role.  This can be a role created with the
         * {api:RoleOverridesController#add_role Add Role API} or a base role type of
         * 'StudentEnrollment', 'TeacherEnrollment', 'TaEnrollment', 'ObserverEnrollment',
         * or 'DesignerEnrollment'.
         */
        enrollment_role?: string;
        /**
         * When set, only return courses where the user is enrolled with the specified
         * course-level role.  This can be a role created with the
         * {api:RoleOverridesController#add_role Add Role API} or a built_in role type of
         * 'StudentEnrollment', 'TeacherEnrollment', 'TaEnrollment', 'ObserverEnrollment',
         * or 'DesignerEnrollment'.
         */
        enrollment_role_id?: number;
        /**
         * When set, only return courses where the user has an enrollment with the given state.
         * This will respect section/course/term date overrides.
         */
        enrollment_state?: 'active' | 'invited_or_pending' | 'completed';
        /**
         * When set, only return courses that are not configured as blueprint courses.
         */
        exclude_blueprint_courses?: boolean;
        /**
         * - "needs_grading_count": Optional information to include with each Course.
         * When needs_grading_count is given, and the current user has grading
         * rights, the total number of submissions needing grading for all
         * assignments is returned.
         * - "syllabus_body": Optional information to include with each Course.
         * When syllabus_body is given the user-generated html for the course
         * syllabus is returned.
         * - "public_description": Optional information to include with each Course.
         * When public_description is given the user-generated text for the course
         * public description is returned.
         * - "total_scores": Optional information to include with each Course.
         * When total_scores is given, any student enrollments will also
         * include the fields 'computed_current_score', 'computed_final_score',
         * 'computed_current_grade', and 'computed_final_grade', as well as (if
         * the user has permission) 'unposted_current_score',
         * 'unposted_final_score', 'unposted_current_grade', and
         * 'unposted_final_grade' (see Enrollment documentation for more
         * information on these fields). This argument is ignored if the course is
         * configured to hide final grades.
         * - "current_grading_period_scores": Optional information to include with
         * each Course. When current_grading_period_scores is given and total_scores
         * is given, any student enrollments will also include the fields
         * 'has_grading_periods',
         * 'totals_for_all_grading_periods_option', 'current_grading_period_title',
         * 'current_grading_period_id', current_period_computed_current_score',
         * 'current_period_computed_final_score',
         * 'current_period_computed_current_grade', and
         * 'current_period_computed_final_grade', as well as (if the user has permission)
         * 'current_period_unposted_current_score',
         * 'current_period_unposted_final_score',
         * 'current_period_unposted_current_grade', and
         * 'current_period_unposted_final_grade' (see Enrollment documentation for
         * more information on these fields). In addition, when this argument is
         * passed, the course will have a 'has_grading_periods' attribute
         * on it. This argument is ignored if the course is configured to hide final
         * grades or if the total_scores argument is not included.
         * - "term": Optional information to include with each Course. When
         * term is given, the information for the enrollment term for each course
         * is returned.
         * - "account": Optional information to include with each Course. When
         * account is given, the account json for each course is returned.
         * - "course_progress": Optional information to include with each Course.
         * When course_progress is given, each course will include a
         * 'course_progress' object with the fields: 'requirement_count', an integer
         * specifying the total number of requirements in the course,
         * 'requirement_completed_count', an integer specifying the total number of
         * requirements in this course that have been completed, and
         * 'next_requirement_url', a string url to the next requirement item, and
         * 'completed_at', the date the course was completed (null if incomplete).
         * 'next_requirement_url' will be null if all requirements have been
         * completed or the current module does not require sequential progress.
         * "course_progress" will return an error message if the course is not
         * module based or the user is not enrolled as a student in the course.
         * - "sections": Section enrollment information to include with each Course.
         * Returns an array of hashes containing the section ID (id), section name
         * (name), start and end dates (start_at, end_at), as well as the enrollment
         * type (enrollment_role, e.g. 'StudentEnrollment').
         * - "storage_quota_used_mb": The amount of storage space used by the files in this course
         * - "total_students": Optional information to include with each Course.
         * Returns an integer for the total amount of active and invited students.
         * - "passback_status": Include the grade passback_status
         * - "favorites": Optional information to include with each Course.
         * Indicates if the user has marked the course as a favorite course.
         * - "teachers": Teacher information to include with each Course.
         * Returns an array of hashes containing the {api:Users:UserDisplay UserDisplay} information
         * for each teacher in the course.
         * - "observed_users": Optional information to include with each Course.
         * Will include data for observed users if the current user has an
         * observer enrollment.
         * - "tabs": Optional information to include with each Course.
         * Will include the list of tabs configured for each course.  See the
         * {api:TabsController#index List available tabs API} for more information.
         * - "course_image": Optional course image data for when there is a course image
         * and the course image feature flag has been enabled
         */
        include?: Array<'needs_grading_count' | 'syllabus_body' | 'public_description' | 'total_scores' | 'current_grading_period_scores' | 'term' | 'account' | 'course_progress' | 'sections' | 'storage_quota_used_mb' | 'total_students' | 'passback_status' | 'favorites' | 'teachers' | 'observed_users' | 'course_image'>;
        /**
         * If set, only return courses that are in the given state(s).
         * By default, "available" is returned for students and observers, and
         * anything except "deleted", for all other enrollment types
         */
        state?: Array<'unpublished' | 'available' | 'completed' | 'deleted'>;
    };
    url: '/v1/courses';
};

export type ListYourCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<CourseWithIncludes>;
};

export type ListYourCoursesResponse = ListYourCoursesResponses[keyof ListYourCoursesResponses];

export type CourseActivityStreamData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/activity_stream';
};

export type CourseActivityStreamResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CourseActivityStreamSummaryData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/activity_stream/summary';
};

export type CourseActivityStreamSummaryResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetCourseLevelParticipationDataData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/analytics/activity';
};

export type GetCourseLevelParticipationDataResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetCourseLevelAssignmentDataData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * If async is true, then the course_assignments call can happen asynch-
         * ronously and MAY return a response containing a progress_url key instead
         * of an assignments array. If it does, then it is the caller's
         * responsibility to poll the API again to see if the progress is complete.
         * If the data is ready (possibly even on the first async call) then it
         * will be passed back normally, as documented in the example response.
         */
        async?: boolean;
    };
    url: '/v1/courses/{course_id}/analytics/assignments';
};

export type GetCourseLevelAssignmentDataResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetCourseLevelStudentSummaryDataData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The order results in which results are returned.  Defaults to "name".
         */
        sort_column?: 'name' | 'name_descending' | 'score' | 'score_descending' | 'participations' | 'participations_descending' | 'page_views' | 'page_views_descending';
        /**
         * If set, returns only the specified student.
         */
        student_id?: string;
    };
    url: '/v1/courses/{course_id}/analytics/student_summaries';
};

export type GetCourseLevelStudentSummaryDataResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetUserInACourseLevelParticipationDataData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        student_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/analytics/users/{student_id}/activity';
};

export type GetUserInACourseLevelParticipationDataResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetUserInACourseLevelAssignmentDataData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        student_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/analytics/users/{student_id}/assignments';
};

export type GetUserInACourseLevelAssignmentDataResponses = {
    /**
     * Returns a list of assignments for the course sorted by due date
     */
    200: Array<Assignment>;
};

export type GetUserInACourseLevelAssignmentDataResponse = GetUserInACourseLevelAssignmentDataResponses[keyof GetUserInACourseLevelAssignmentDataResponses];

export type GetUserInACourseLevelMessagingDataData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        student_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/analytics/users/{student_id}/communication';
};

export type GetUserInACourseLevelMessagingDataResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListAssignmentGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * Associations to include with the group. "discussion_topic", "all_dates"
         * "assignment_visibility" & "submission" are only valid if "assignments" is also included.
         * The "assignment_visibility" option additionally requires that the Differentiated Assignments course feature be turned on.
         */
        include?: Array<'assignments' | 'discussion_topic' | 'all_dates' | 'assignment_visibility' | 'overrides' | 'submission'>;
        /**
         * If "assignments" are included, those with the specified submission types
         * will be excluded from the assignment groups.
         */
        exclude_assignment_submission_types?: Array<'online_quiz' | 'discussion_topic' | 'wiki_page' | 'external_tool'>;
        /**
         * Apply assignment overrides for each assignment, defaults to true.
         */
        override_assignment_dates?: boolean;
        /**
         * The id of the grading period in which assignment groups are being requested
         * (Requires grading periods to exist.)
         */
        grading_period_id?: number;
        /**
         * If true, all assignments returned will apply to the current user in the
         * specified grading period. If assignments apply to other students in the
         * specified grading period, but not the current user, they will not be
         * returned. (Requires the grading_period_id argument and grading periods to
         * exist. In addition, the current user must be a student.)
         */
        scope_assignments_to_student?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/assignment_groups';
};

export type ListAssignmentGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<AssignmentGroup>;
};

export type ListAssignmentGroupsResponse = ListAssignmentGroupsResponses[keyof ListAssignmentGroupsResponses];

export type CreateAssignmentGroupData = {
    body?: {
        /**
         * The percent of the total grade that this assignment group represents
         */
        group_weight?: number;
        /**
         * The integration data of the Assignment Group
         */
        integration_data?: {
            [key: string]: unknown;
        };
        /**
         * The assignment group's name
         */
        name?: string;
        /**
         * The position of this assignment group in relation to the other assignment groups
         */
        position?: number;
        /**
         * The grading rules that are applied within this assignment group
         * See the Assignment Group object definition for format
         */
        rules?: string;
        /**
         * The sis source id of the Assignment Group
         */
        sis_source_id?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignment_groups';
};

export type CreateAssignmentGroupResponses = {
    /**
     * No response was specified
     */
    200: AssignmentGroup;
};

export type CreateAssignmentGroupResponse = CreateAssignmentGroupResponses[keyof CreateAssignmentGroupResponses];

export type DestroyAssignmentGroupData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_group_id: string;
    };
    query?: {
        /**
         * The ID of an active Assignment Group to which the assignments that are
         * currently assigned to the destroyed Assignment Group will be assigned.
         * NOTE: If this argument is not provided, any assignments in this Assignment
         * Group will be deleted.
         */
        move_assignments_to?: number;
    };
    url: '/v1/courses/{course_id}/assignment_groups/{assignment_group_id}';
};

export type DestroyAssignmentGroupResponses = {
    /**
     * No response was specified
     */
    200: AssignmentGroup;
};

export type DestroyAssignmentGroupResponse = DestroyAssignmentGroupResponses[keyof DestroyAssignmentGroupResponses];

export type GetAssignmentGroupData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_group_id: string;
    };
    query?: {
        /**
         * Associations to include with the group. "discussion_topic" and "assignment_visibility" and "submission"
         * are only valid if "assignments" is also included. The "assignment_visibility" option additionally
         * requires that the Differentiated Assignments course feature be turned on.
         */
        include?: Array<'assignments' | 'discussion_topic' | 'assignment_visibility' | 'submission'>;
        /**
         * Apply assignment overrides for each assignment, defaults to true.
         */
        override_assignment_dates?: boolean;
        /**
         * The id of the grading period in which assignment groups are being requested
         * (Requires grading periods to exist on the account)
         */
        grading_period_id?: number;
    };
    url: '/v1/courses/{course_id}/assignment_groups/{assignment_group_id}';
};

export type GetAssignmentGroupResponses = {
    /**
     * No response was specified
     */
    200: AssignmentGroup;
};

export type GetAssignmentGroupResponse = GetAssignmentGroupResponses[keyof GetAssignmentGroupResponses];

export type EditAssignmentGroupData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_group_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignment_groups/{assignment_group_id}';
};

export type EditAssignmentGroupResponses = {
    /**
     * No response was specified
     */
    200: AssignmentGroup;
};

export type EditAssignmentGroupResponse = EditAssignmentGroupResponses[keyof EditAssignmentGroupResponses];

export type ListAssignmentsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * Associations to include with the assignment. The "assignment_visibility" option
         * requires that the Differentiated Assignments course feature be turned on. If
         * "observed_users" is passed, submissions for observed users will also be included as an array.
         */
        include?: Array<'submission' | 'assignment_visibility' | 'all_dates' | 'overrides' | 'observed_users'>;
        /**
         * The partial title of the assignments to match and return.
         */
        search_term?: string;
        /**
         * Apply assignment overrides for each assignment, defaults to true.
         */
        override_assignment_dates?: boolean;
        /**
         * Split up "needs_grading_count" by sections into the "needs_grading_count_by_section" key, defaults to false
         */
        needs_grading_count_by_section?: boolean;
        /**
         * If included, only return certain assignments depending on due date and submission status.
         */
        bucket?: 'past' | 'overdue' | 'undated' | 'ungraded' | 'unsubmitted' | 'upcoming' | 'future';
        /**
         * if set, return only assignments specified
         */
        assignment_ids?: Array<string>;
        /**
         * Determines the order of the assignments. Defaults to "position".
         */
        order_by?: 'position' | 'name';
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/assignments';
};

export type ListAssignmentsResponses = {
    /**
     * No response was specified
     */
    200: Array<Assignment>;
};

export type ListAssignmentsResponse = ListAssignmentsResponses[keyof ListAssignmentsResponses];

export type CreateAssignmentData = {
    body: {
        'assignment[allowed_extensions]'?: Array<string>;
        /**
         * The assignment group id to put the assignment in.
         * Defaults to the top assignment group in the course.
         */
        'assignment[assignment_group_id]'?: number;
        /**
         * List of overrides for the assignment.
         */
        'assignment[assignment_overrides]'?: Array<AssignmentOverride>;
        /**
         * Whether peer reviews will be assigned automatically by Canvas or if
         * teachers must manually assign peer reviews. Does not apply if peer reviews
         * are not enabled.
         */
        'assignment[automatic_peer_reviews]'?: boolean;
        /**
         * The assignment's description, supports HTML.
         */
        'assignment[description]'?: string;
        /**
         * The day/time the assignment is due. Must be between the lock dates if there are lock dates.
         * Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z.
         */
        'assignment[due_at]'?: string;
        /**
         * Hash of external tool parameters if submission_types is ["external_tool"].
         * See Assignment object definition for format.
         */
        'assignment[external_tool_tag_attributes]'?: string;
        /**
         * If this is a group assignment, teachers have the options to grade
         * students individually. If false, Canvas will apply the assignment's
         * score to each member of the group. If true, the teacher can manually
         * assign scores to each member of the group.
         */
        'assignment[grade_group_students_individually]'?: number;
        /**
         * The grading standard id to set for the course.  If no value is provided for this argument the current grading_standard will be un-set from this course.
         * This will update the grading_type for the course to 'letter_grade' unless it is already 'gpa_scale'.
         */
        'assignment[grading_standard_id]'?: number;
        /**
         * The strategy used for grading the assignment.
         * The assignment defaults to "points" if this field is omitted.
         */
        'assignment[grading_type]'?: 'pass_fail' | 'percent' | 'letter_grade' | 'gpa_scale' | 'points';
        /**
         * If present, the assignment will become a group assignment assigned
         * to the group.
         */
        'assignment[group_category_id]'?: number;
        /**
         * Data used for SIS integrations. Requires admin-level token with the "Manage SIS" permission. JSON string required.
         */
        'assignment[integration_data]'?: string;
        /**
         * Unique ID from third party integrations
         */
        'assignment[integration_id]'?: string;
        /**
         * The day/time the assignment is locked after. Must be after the due date if there is a due date.
         * Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z.
         */
        'assignment[lock_at]'?: string;
        /**
         * Whether this assignment is moderated.
         */
        'assignment[moderated_grading]'?: boolean;
        /**
         * Whether this assignment is muted.
         * A muted assignment does not send change notifications
         * and hides grades from students.
         * Defaults to false.
         */
        'assignment[muted]'?: boolean;
        /**
         * The assignment name.
         */
        'assignment[name]': string;
        /**
         * If true, Canvas will send a notification to students in the class
         * notifying them that the content has changed.
         */
        'assignment[notify_of_update]'?: boolean;
        /**
         * Whether this assignment is counted towards a student's final grade.
         */
        'assignment[omit_from_final_grade]'?: boolean;
        /**
         * Whether this assignment is only visible to overrides
         * (Only useful if 'differentiated assignments' account setting is on)
         */
        'assignment[only_visible_to_overrides]'?: boolean;
        /**
         * If submission_types does not include external_tool,discussion_topic,
         * online_quiz, or on_paper, determines whether or not peer reviews
         * will be turned on for the assignment.
         */
        'assignment[peer_reviews]'?: boolean;
        /**
         * The maximum points possible on the assignment.
         */
        'assignment[points_possible]'?: number;
        /**
         * The position of this assignment in the group when displaying
         * assignment lists.
         */
        'assignment[position]'?: number;
        /**
         * Whether this assignment is published.
         * (Only useful if 'draft state' account setting is on)
         * Unpublished assignments are not visible to students.
         */
        'assignment[published]'?: boolean;
        /**
         * Whether this assignment should use the Quizzes 2 LTI tool. Sets the
         * submission type to 'external_tool' and configures the external tool
         * attributes to use the Quizzes 2 LTI tool configured for this course.
         * Has no effect if no Quizzes 2 LTI tool is configured.
         */
        'assignment[quiz_lti]'?: boolean;
        'assignment[submission_types]'?: Array<'online_quiz' | 'none' | 'on_paper' | 'discussion_topic' | 'external_tool' | 'online_upload' | 'online_text_entry' | 'online_url' | 'media_recording'>;
        /**
         * Only applies when the Turnitin plugin is enabled for a course and
         * the submission_types array includes "online_upload".
         * Toggles Turnitin submissions for the assignment.
         * Will be ignored if Turnitin is not available for the course.
         */
        'assignment[turnitin_enabled]'?: boolean;
        /**
         * Settings to send along to turnitin. See Assignment object definition for
         * format.
         */
        'assignment[turnitin_settings]'?: string;
        /**
         * The day/time the assignment is unlocked. Must be before the due date if there is a due date.
         * Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z.
         */
        'assignment[unlock_at]'?: string;
        /**
         * Only applies when the VeriCite plugin is enabled for a course and
         * the submission_types array includes "online_upload".
         * Toggles VeriCite submissions for the assignment.
         * Will be ignored if VeriCite is not available for the course.
         */
        'assignment[vericite_enabled]'?: boolean;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments';
};

export type CreateAssignmentResponses = {
    /**
     * No response was specified
     */
    200: Assignment;
};

export type CreateAssignmentResponse = CreateAssignmentResponses[keyof CreateAssignmentResponses];

export type ListMultipleAssignmentsGradeableStudentsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * Assignments being requested
         */
        assignment_ids?: Array<string>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/assignments/gradeable_students';
};

export type ListMultipleAssignmentsGradeableStudentsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type BatchRetrieveOverridesInCourseData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query: {
        /**
         * Ids of overrides to retrieve
         */
        'assignment_overrides[id]': Array<string>;
        /**
         * Ids of assignments for each override
         */
        'assignment_overrides[assignment_id]': Array<string>;
    };
    url: '/v1/courses/{course_id}/assignments/overrides';
};

export type BatchRetrieveOverridesInCourseResponses = {
    /**
     * No response was specified
     */
    200: Array<AssignmentOverride>;
};

export type BatchRetrieveOverridesInCourseResponse = BatchRetrieveOverridesInCourseResponses[keyof BatchRetrieveOverridesInCourseResponses];

export type BatchCreateOverridesInCourseData = {
    body: {
        /**
         * Attributes for the new assignment overrides.
         * See {api:AssignmentOverridesController#create Create an assignment override} for available
         * attributes
         */
        assignment_overrides: Array<AssignmentOverride>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/overrides';
};

export type BatchCreateOverridesInCourseResponses = {
    /**
     * No response was specified
     */
    200: Array<AssignmentOverride>;
};

export type BatchCreateOverridesInCourseResponse = BatchCreateOverridesInCourseResponses[keyof BatchCreateOverridesInCourseResponses];

export type BatchUpdateOverridesInCourseData = {
    body: {
        assignment_overrides: Array<AssignmentOverride>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/overrides';
};

export type BatchUpdateOverridesInCourseResponses = {
    /**
     * No response was specified
     */
    200: Array<AssignmentOverride>;
};

export type BatchUpdateOverridesInCourseResponse = BatchUpdateOverridesInCourseResponses[keyof BatchUpdateOverridesInCourseResponses];

export type ShowProvisionalGradeStatusForStudentAnonymousData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * The id of the student to show the status for
         */
        anonymous_id?: string;
    };
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/anonymous_provisional_grades/status';
};

export type ShowProvisionalGradeStatusForStudentAnonymousResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListGradeableStudentsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * The numeric value leading to the next paginated page. This needs to be parsed from the response header (Link field).
         */
        page?: number;
        /**
         * The number of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/gradeable_students';
};

export type ListGradeableStudentsResponses = {
    /**
     * Returns a list of UserDisplay objects
     */
    200: Array<UserDisplay>;
};

export type ListGradeableStudentsResponse = ListGradeableStudentsResponses[keyof ListGradeableStudentsResponses];

export type ListStudentsSelectedForModerationData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/moderated_students';
};

export type ListStudentsSelectedForModerationResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type ListStudentsSelectedForModerationResponse = ListStudentsSelectedForModerationResponses[keyof ListStudentsSelectedForModerationResponses];

export type SelectStudentsForModerationData = {
    body?: {
        /**
         * user ids for students to select for moderation
         */
        student_ids?: Array<number>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/moderated_students';
};

export type SelectStudentsForModerationResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type SelectStudentsForModerationResponse = SelectStudentsForModerationResponses[keyof SelectStudentsForModerationResponses];

export type ListAssignmentOverridesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/overrides';
};

export type ListAssignmentOverridesResponses = {
    /**
     * No response was specified
     */
    200: Array<AssignmentOverride>;
};

export type ListAssignmentOverridesResponse = ListAssignmentOverridesResponses[keyof ListAssignmentOverridesResponses];

export type CreateAssignmentOverrideData = {
    body?: {
        /**
         * The ID
         * of the override's target section. If present, must identify an active
         * section of the assignment's course not already targetted by a different
         * override.
         */
        'assignment_override[course_section_id]'?: number;
        /**
         * The day/time
         * the overridden assignment is due. Accepts times in ISO 8601 format, e.g.
         * 2014-10-21T18:48:00Z. If absent, this override will not affect due date.
         * May be present but null to indicate the override removes any previous due
         * date.
         */
        'assignment_override[due_at]'?: string;
        /**
         * The ID of the
         * override's target group. If present, the following conditions must be met
         * for the override to be successful:
         *
         * 1. the assignment MUST be a group assignment (a group_category_id is assigned to it)
         * 2. the ID must identify an active group in the group set the assignment is in
         * 3. the ID must not be targetted by a different override
         *
         * See {Appendix: Group assignments} for more info.
         */
        'assignment_override[group_id]'?: number;
        /**
         * The day/time
         * the overridden assignment becomes locked. Accepts times in ISO 8601
         * format, e.g. 2014-10-21T18:48:00Z. If absent, this override will not
         * affect the lock date. May be present but null to indicate the override
         * removes any previous lock date.
         */
        'assignment_override[lock_at]'?: string;
        /**
         * The IDs of
         * the override's target students. If present, the IDs must each identify a
         * user with an active student enrollment in the course that is not already
         * targetted by a different adhoc override.
         */
        'assignment_override[student_ids]'?: Array<number>;
        /**
         * The title of the adhoc
         * assignment override. Required if student_ids is present, ignored
         * otherwise (the title is set to the name of the targetted group or section
         * instead).
         */
        'assignment_override[title]'?: string;
        /**
         * The day/time
         * the overridden assignment becomes unlocked. Accepts times in ISO 8601
         * format, e.g. 2014-10-21T18:48:00Z. If absent, this override will not
         * affect the unlock date. May be present but null to indicate the override
         * removes any previous unlock date.
         */
        'assignment_override[unlock_at]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/overrides';
};

export type CreateAssignmentOverrideResponses = {
    /**
     * No response was specified
     */
    200: AssignmentOverride;
};

export type CreateAssignmentOverrideResponse = CreateAssignmentOverrideResponses[keyof CreateAssignmentOverrideResponses];

export type DeleteAssignmentOverrideData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/overrides/{id}';
};

export type DeleteAssignmentOverrideResponses = {
    /**
     * No response was specified
     */
    200: AssignmentOverride;
};

export type DeleteAssignmentOverrideResponse = DeleteAssignmentOverrideResponses[keyof DeleteAssignmentOverrideResponses];

export type GetSingleAssignmentOverrideData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/overrides/{id}';
};

export type GetSingleAssignmentOverrideResponses = {
    /**
     * No response was specified
     */
    200: AssignmentOverride;
};

export type GetSingleAssignmentOverrideResponse = GetSingleAssignmentOverrideResponses[keyof GetSingleAssignmentOverrideResponses];

export type UpdateAssignmentOverrideData = {
    body?: {
        /**
         * The day/time
         * the overridden assignment is due. Accepts times in ISO 8601 format, e.g.
         * 2014-10-21T18:48:00Z. If absent, this override will not affect due date.
         * May be present but null to indicate the override removes any previous due
         * date.
         */
        'assignment_override[due_at]'?: string;
        /**
         * The day/time
         * the overridden assignment becomes locked. Accepts times in ISO 8601
         * format, e.g. 2014-10-21T18:48:00Z. If absent, this override will not
         * affect the lock date. May be present but null to indicate the override
         * removes any previous lock date.
         */
        'assignment_override[lock_at]'?: string;
        /**
         * The IDs of the
         * override's target students. If present, the IDs must each identify a
         * user with an active student enrollment in the course that is not already
         * targetted by a different adhoc override. Ignored unless the override
         * being updated is adhoc.
         */
        'assignment_override[student_ids]'?: Array<number>;
        /**
         * The title of an adhoc
         * assignment override. Ignored unless the override being updated is adhoc.
         */
        'assignment_override[title]'?: string;
        /**
         * The day/time
         * the overridden assignment becomes unlocked. Accepts times in ISO 8601
         * format, e.g. 2014-10-21T18:48:00Z. If absent, this override will not
         * affect the unlock date. May be present but null to indicate the override
         * removes any previous unlock date.
         */
        'assignment_override[unlock_at]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/overrides/{id}';
};

export type UpdateAssignmentOverrideResponses = {
    /**
     * No response was specified
     */
    200: AssignmentOverride;
};

export type UpdateAssignmentOverrideResponse = UpdateAssignmentOverrideResponses[keyof UpdateAssignmentOverrideResponses];

export type GetAllPeerReviewsCoursesPeerReviewsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * Associations to include with the peer review.
         */
        include?: Array<'submission_comments' | 'user'>;
    };
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/peer_reviews';
};

export type GetAllPeerReviewsCoursesPeerReviewsResponses = {
    /**
     * No response was specified
     */
    200: Array<PeerReview>;
};

export type GetAllPeerReviewsCoursesPeerReviewsResponse = GetAllPeerReviewsCoursesPeerReviewsResponses[keyof GetAllPeerReviewsCoursesPeerReviewsResponses];

export type BulkSelectProvisionalGradesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/provisional_grades/bulk_select';
};

export type BulkSelectProvisionalGradesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type PublishProvisionalGradesForAssignmentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/provisional_grades/publish';
};

export type PublishProvisionalGradesForAssignmentResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ShowProvisionalGradeStatusForStudentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * The id of the student to show the status for
         */
        student_id?: number;
    };
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/provisional_grades/status';
};

export type ShowProvisionalGradeStatusForStudentResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CopyProvisionalGradeData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        provisional_grade_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/provisional_grades/{provisional_grade_id}/copy_to_final_mark';
};

export type CopyProvisionalGradeResponses = {
    /**
     * No response was specified
     */
    200: ProvisionalGrade;
};

export type CopyProvisionalGradeResponse = CopyProvisionalGradeResponses[keyof CopyProvisionalGradeResponses];

export type SelectProvisionalGradeData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        provisional_grade_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/provisional_grades/{provisional_grade_id}/select';
};

export type SelectProvisionalGradeResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type SubmissionSummaryCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * If this argument is true, the response will take into account student groups.
         */
        grouped?: boolean;
    };
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submission_summary';
};

export type SubmissionSummaryCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListAssignmentSubmissionsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * Associations to include with the group.  "group" will add group_id and group_name.
         */
        include?: Array<'submission_history' | 'submission_comments' | 'rubric_assessment' | 'assignment' | 'visibility' | 'course' | 'user' | 'group'>;
        /**
         * If this argument is true, the response will be grouped by student groups.
         */
        grouped?: boolean;
        /**
         * The numeric value leading to the next paginated page. This needs to be parsed from the response header (Link field).
         */
        page?: number;
        /**
         * The number of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submissions';
};

export type ListAssignmentSubmissionsCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<Submission>;
};

export type ListAssignmentSubmissionsCoursesResponse = ListAssignmentSubmissionsCoursesResponses[keyof ListAssignmentSubmissionsCoursesResponses];

export type SubmitAssignmentCoursesData = {
    body: {
        /**
         * Include a textual comment with the submission.
         */
        'comment[text_comment]'?: string;
        /**
         * Submit the assignment as an HTML document snippet. Note this HTML snippet
         * will be sanitized using the same ruleset as a submission made from the
         * Canvas web UI. The sanitized HTML will be returned in the response as the
         * submission body. Requires a submission_type of "online_text_entry".
         */
        'submission[body]'?: string;
        /**
         * Submit the assignment as a set of one or more previously uploaded files
         * residing in the submitting user's files section (or the group's files
         * section, for group assignments).
         *
         * To upload a new file to submit, see the submissions {api:SubmissionsApiController#create_file Upload a file API}.
         *
         * Requires a submission_type of "online_upload".
         */
        'submission[file_ids]'?: Array<number>;
        /**
         * The media comment id to submit. Media comment ids can be submitted via
         * this API, however, note that there is not yet an API to generate or list
         * existing media comments, so this functionality is currently of limited use.
         *
         * Requires a submission_type of "media_recording".
         */
        'submission[media_comment_id]'?: string;
        /**
         * The type of media comment being submitted.
         */
        'submission[media_comment_type]'?: 'audio' | 'video';
        /**
         * The type of submission being made. The assignment submission_types must
         * include this submission type as an allowed option, or the submission will be rejected with a 400 error.
         *
         * The submission_type given determines which of the following parameters is
         * used. For instance, to submit a URL, submission [submission_type] must be
         * set to "online_url", otherwise the submission [url] parameter will be
         * ignored.
         */
        'submission[submission_type]': 'online_text_entry' | 'online_url' | 'online_upload' | 'media_recording' | 'basic_lti_launch';
        /**
         * Submit the assignment as a URL. The URL scheme must be "http" or "https",
         * no "ftp" or other URL schemes are allowed. If no scheme is given (e.g.
         * "www.example.com") then "http" will be assumed. Requires a submission_type
         * of "online_url" or "basic_lti_launch".
         */
        'submission[url]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submissions';
};

export type SubmitAssignmentCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GradeOrCommentOnMultipleSubmissionsCoursesAssignmentsData = {
    body?: {
        /**
         * Specifies which assignment to grade.  This argument is not necessary when
         * using the assignment-specific endpoints.
         */
        'grade_data[student_id][assignment_id]'?: number;
        /**
         * See documentation for the excuse argument in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][excuse]'?: boolean;
        /**
         * See documentation for the comment[] arguments in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][file_ids]'?: Array<number>;
        /**
         * no description
         */
        'grade_data[student_id][group_comment]'?: boolean;
        /**
         * no description
         */
        'grade_data[student_id][media_comment_id]'?: string;
        /**
         * no description
         */
        'grade_data[student_id][media_comment_type]'?: 'audio' | 'video';
        /**
         * See documentation for the posted_grade argument in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][posted_grade]'?: string;
        /**
         * See documentation for the rubric_assessment argument in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][rubric_assessment]'?: unknown;
        /**
         * no description
         */
        'grade_data[student_id][text_comment]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/update_grades';
};

export type GradeOrCommentOnMultipleSubmissionsCoursesAssignmentsResponses = {
    /**
     * No response was specified
     */
    200: Progress;
};

export type GradeOrCommentOnMultipleSubmissionsCoursesAssignmentsResponse = GradeOrCommentOnMultipleSubmissionsCoursesAssignmentsResponses[keyof GradeOrCommentOnMultipleSubmissionsCoursesAssignmentsResponses];

export type DeletePeerReviewCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        submission_id: string;
    };
    query: {
        /**
         * user_id to delete as reviewer on this assignment
         */
        user_id: number;
    };
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{submission_id}/peer_reviews';
};

export type DeletePeerReviewCoursesResponses = {
    /**
     * No response was specified
     */
    200: PeerReview;
};

export type DeletePeerReviewCoursesResponse = DeletePeerReviewCoursesResponses[keyof DeletePeerReviewCoursesResponses];

export type GetAllPeerReviewsCoursesSubmissionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        submission_id: string;
    };
    query?: {
        /**
         * Associations to include with the peer review.
         */
        include?: Array<'submission_comments' | 'user'>;
    };
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{submission_id}/peer_reviews';
};

export type GetAllPeerReviewsCoursesSubmissionsResponses = {
    /**
     * No response was specified
     */
    200: Array<PeerReview>;
};

export type GetAllPeerReviewsCoursesSubmissionsResponse = GetAllPeerReviewsCoursesSubmissionsResponses[keyof GetAllPeerReviewsCoursesSubmissionsResponses];

export type CreatePeerReviewCoursesData = {
    body: {
        /**
         * user_id to assign as reviewer on this assignment
         */
        user_id: number;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        submission_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{submission_id}/peer_reviews';
};

export type CreatePeerReviewCoursesResponses = {
    /**
     * No response was specified
     */
    200: PeerReview;
};

export type CreatePeerReviewCoursesResponse = CreatePeerReviewCoursesResponses[keyof CreatePeerReviewCoursesResponses];

export type GetSingleSubmissionCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * Associations to include with the group.
         */
        include?: Array<'submission_history' | 'submission_comments' | 'rubric_assessment' | 'visibility' | 'course' | 'user'>;
    };
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}';
};

export type GetSingleSubmissionCoursesResponses = {
    /**
     * The submission object
     */
    200: Submission;
};

export type GetSingleSubmissionCoursesResponse = GetSingleSubmissionCoursesResponses[keyof GetSingleSubmissionCoursesResponses];

export type GradeOrCommentOnSubmissionCoursesData = {
    body?: {
        /**
         * Attach files to this comment that were previously uploaded using the
         * Submission Comment API's files action
         */
        'comment[file_ids]'?: Array<number>;
        /**
         * Whether or not this comment should be sent to the entire group (defaults
         * to false). Ignored if this is not a group assignment or if no text_comment
         * is provided.
         */
        'comment[group_comment]'?: boolean;
        /**
         * Add an audio/video comment to the submission. Media comments can be added
         * via this API, however, note that there is not yet an API to generate or
         * list existing media comments, so this functionality is currently of
         * limited use.
         */
        'comment[media_comment_id]'?: string;
        /**
         * The type of media comment being added.
         */
        'comment[media_comment_type]'?: 'audio' | 'video';
        /**
         * Add a textual comment to the submission.
         */
        'comment[text_comment]'?: string;
        /**
         * Whether this assignment is visible to the owner of the submission
         */
        'include[visibility]'?: string;
        /**
         * Assign a rubric assessment to this assignment submission. The
         * sub-parameters here depend on the rubric for the assignment. The general
         * format is, for each row in the rubric:
         *
         * The points awarded for this row.
         * rubric_assessment[criterion_id][points]
         *
         * Comments to add for this row.
         * rubric_assessment[criterion_id][comments]
         *
         * For example, if the assignment rubric is (in JSON format):
         * !!!javascript
         * [
         * {
         * 'id': 'crit1',
         * 'points': 10,
         * 'description': 'Criterion 1',
         * 'ratings':
         * [
         * { 'description': 'Good', 'points': 10 },
         * { 'description': 'Poor', 'points': 3 }
         * ]
         * },
         * {
         * 'id': 'crit2',
         * 'points': 5,
         * 'description': 'Criterion 2',
         * 'ratings':
         * [
         * { 'description': 'Complete', 'points': 5 },
         * { 'description': 'Incomplete', 'points': 0 }
         * ]
         * }
         * ]
         *
         * Then a possible set of values for rubric_assessment would be:
         * rubric_assessment[crit1][points]=3&rubric_assessment[crit2][points]=5&rubric_assessment[crit2][comments]=Well%20Done.
         */
        rubric_assessment?: unknown;
        /**
         * Sets the "excused" status of an assignment.
         */
        'submission[excuse]'?: boolean;
        /**
         * Sets the late policy status to either "late", "missing", "none", or null.
         */
        'submission[late_policy_status]'?: string;
        /**
         * Assign a score to the submission, updating both the "score" and "grade"
         * fields on the submission record. This parameter can be passed in a few
         * different formats:
         *
         * points:: A floating point or integral value, such as "13.5". The grade
         * will be interpreted directly as the score of the assignment.
         * Values above assignment.points_possible are allowed, for awarding
         * extra credit.
         * percentage:: A floating point value appended with a percent sign, such as
         * "40%". The grade will be interpreted as a percentage score on the
         * assignment, where 100% == assignment.points_possible. Values above 100%
         * are allowed, for awarding extra credit.
         * letter grade:: A letter grade, following the assignment's defined letter
         * grading scheme. For example, "A-". The resulting score will be the high
         * end of the defined range for the letter grade. For instance, if "B" is
         * defined as 86% to 84%, a letter grade of "B" will be worth 86%. The
         * letter grade will be rejected if the assignment does not have a defined
         * letter grading scheme. For more fine-grained control of scores, pass in
         * points or percentage rather than the letter grade.
         * "pass/complete/fail/incomplete":: A string value of "pass" or "complete"
         * will give a score of 100%. "fail" or "incomplete" will give a score of
         * 0.
         *
         * Note that assignments with grading_type of "pass_fail" can only be
         * assigned a score of 0 or assignment.points_possible, nothing inbetween. If
         * a posted_grade in the "points" or "percentage" format is sent, the grade
         * will only be accepted if the grade equals one of those two values.
         */
        'submission[posted_grade]'?: string;
        /**
         * Sets the seconds late if late policy status is "late"
         */
        'submission[seconds_late_override]'?: number;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}';
};

export type GradeOrCommentOnSubmissionCoursesResponses = {
    /**
     * The submission on which has been commented.
     */
    200: Submission;
};

export type GradeOrCommentOnSubmissionCoursesResponse = GradeOrCommentOnSubmissionCoursesResponses[keyof GradeOrCommentOnSubmissionCoursesResponses];

export type UploadFileToSubmissionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/comments/files';
};

export type UploadFileToSubmissionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UploadFileCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/files';
};

export type UploadFileCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkSubmissionAsUnreadCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/read';
};

export type MarkSubmissionAsUnreadCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkSubmissionAsReadCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/read';
};

export type MarkSubmissionAsReadCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteAssignmentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{id}';
};

export type DeleteAssignmentResponses = {
    /**
     * No response was specified
     */
    200: Assignment;
};

export type DeleteAssignmentResponse = DeleteAssignmentResponses[keyof DeleteAssignmentResponses];

export type GetSingleAssignmentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Associations to include with the assignment. The "assignment_visibility" option
         * requires that the Differentiated Assignments course feature be turned on. If
         * "observed_users" is passed, submissions for observed users will also be included.
         */
        include?: Array<'submission' | 'assignment_visibility' | 'overrides' | 'observed_users'>;
        /**
         * Apply assignment overrides to the assignment, defaults to true.
         */
        override_assignment_dates?: boolean;
        /**
         * Split up "needs_grading_count" by sections into the "needs_grading_count_by_section" key, defaults to false
         */
        needs_grading_count_by_section?: boolean;
        /**
         * All dates associated with the assignment, if applicable
         */
        all_dates?: boolean;
    };
    url: '/v1/courses/{course_id}/assignments/{id}';
};

export type GetSingleAssignmentResponses = {
    /**
     * No response was specified
     */
    200: Assignment;
};

export type GetSingleAssignmentResponse = GetSingleAssignmentResponses[keyof GetSingleAssignmentResponses];

export type EditAssignmentData = {
    body?: {
        /**
         * Allowed extensions if submission_types includes "online_upload"
         *
         * Example:
         * allowed_extensions: ["docx","ppt"]
         */
        'assignment[allowed_extensions]'?: Array<string>;
        /**
         * The assignment group id to put the assignment in.
         * Defaults to the top assignment group in the course.
         */
        'assignment[assignment_group_id]'?: number;
        /**
         * List of overrides for the assignment.
         */
        'assignment[assignment_overrides]'?: Array<AssignmentOverride>;
        /**
         * Whether peer reviews will be assigned automatically by Canvas or if
         * teachers must manually assign peer reviews. Does not apply if peer reviews
         * are not enabled.
         */
        'assignment[automatic_peer_reviews]'?: boolean;
        /**
         * The assignment's description, supports HTML.
         */
        'assignment[description]'?: string;
        /**
         * The day/time the assignment is due.
         * Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z.
         */
        'assignment[due_at]'?: string;
        /**
         * Hash of external tool parameters if submission_types is ["external_tool"].
         * See Assignment object definition for format.
         */
        'assignment[external_tool_tag_attributes]'?: string;
        /**
         * If this is a group assignment, teachers have the options to grade
         * students individually. If false, Canvas will apply the assignment's
         * score to each member of the group. If true, the teacher can manually
         * assign scores to each member of the group.
         */
        'assignment[grade_group_students_individually]'?: number;
        /**
         * The grading standard id to set for the course.  If no value is provided for this argument the current grading_standard will be un-set from this course.
         * This will update the grading_type for the course to 'letter_grade' unless it is already 'gpa_scale'.
         */
        'assignment[grading_standard_id]'?: number;
        /**
         * The strategy used for grading the assignment.
         * The assignment defaults to "points" if this field is omitted.
         */
        'assignment[grading_type]'?: 'pass_fail' | 'percent' | 'letter_grade' | 'gpa_scale' | 'points';
        /**
         * If present, the assignment will become a group assignment assigned
         * to the group.
         */
        'assignment[group_category_id]'?: number;
        /**
         * Data used for SIS integrations. Requires admin-level token with the "Manage SIS" permission. JSON string required.
         */
        'assignment[integration_data]'?: string;
        /**
         * Unique ID from third party integrations
         */
        'assignment[integration_id]'?: string;
        /**
         * The day/time the assignment is locked after. Must be after the due date if there is a due date.
         * Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z.
         */
        'assignment[lock_at]'?: string;
        /**
         * Whether this assignment is moderated.
         */
        'assignment[moderated_grading]'?: boolean;
        /**
         * Whether this assignment is muted.
         * A muted assignment does not send change notifications
         * and hides grades from students.
         * Defaults to false.
         */
        'assignment[muted]'?: boolean;
        /**
         * The assignment name.
         */
        'assignment[name]'?: string;
        /**
         * If true, Canvas will send a notification to students in the class
         * notifying them that the content has changed.
         */
        'assignment[notify_of_update]'?: boolean;
        /**
         * Whether this assignment is counted towards a student's final grade.
         */
        'assignment[omit_from_final_grade]'?: boolean;
        /**
         * Whether this assignment is only visible to overrides
         * (Only useful if 'differentiated assignments' account setting is on)
         */
        'assignment[only_visible_to_overrides]'?: boolean;
        /**
         * If submission_types does not include external_tool,discussion_topic,
         * online_quiz, or on_paper, determines whether or not peer reviews
         * will be turned on for the assignment.
         */
        'assignment[peer_reviews]'?: boolean;
        /**
         * The maximum points possible on the assignment.
         */
        'assignment[points_possible]'?: number;
        /**
         * The position of this assignment in the group when displaying
         * assignment lists.
         */
        'assignment[position]'?: number;
        /**
         * Whether this assignment is published.
         * (Only useful if 'draft state' account setting is on)
         * Unpublished assignments are not visible to students.
         */
        'assignment[published]'?: boolean;
        /**
         * List of supported submission types for the assignment.
         * Unless the assignment is allowing online submissions, the array should
         * only have one element.
         *
         * If not allowing online submissions, your options are:
         * "online_quiz"
         * "none"
         * "on_paper"
         * "discussion_topic"
         * "external_tool"
         *
         * If you are allowing online submissions, you can have one or many
         * allowed submission types:
         *
         * "online_upload"
         * "online_text_entry"
         * "online_url"
         * "media_recording" (Only valid when the Kaltura plugin is enabled)
         */
        'assignment[submission_types]'?: Array<'online_quiz' | 'none' | 'on_paper' | 'discussion_topic' | 'external_tool' | 'online_upload' | 'online_text_entry' | 'online_url' | 'media_recording'>;
        /**
         * Only applies when the Turnitin plugin is enabled for a course and
         * the submission_types array includes "online_upload".
         * Toggles Turnitin submissions for the assignment.
         * Will be ignored if Turnitin is not available for the course.
         */
        'assignment[turnitin_enabled]'?: boolean;
        /**
         * Settings to send along to turnitin. See Assignment object definition for
         * format.
         */
        'assignment[turnitin_settings]'?: string;
        /**
         * The day/time the assignment is unlocked. Must be before the due date if there is a due date.
         * Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z.
         */
        'assignment[unlock_at]'?: string;
        /**
         * Only applies when the VeriCite plugin is enabled for a course and
         * the submission_types array includes "online_upload".
         * Toggles VeriCite submissions for the assignment.
         * Will be ignored if VeriCite is not available for the course.
         */
        'assignment[vericite_enabled]'?: boolean;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/assignments/{id}';
};

export type EditAssignmentResponses = {
    /**
     * No response was specified
     */
    200: Assignment;
};

export type EditAssignmentResponse = EditAssignmentResponses[keyof EditAssignmentResponses];

export type ListBlueprintSubscriptionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/blueprint_subscriptions';
};

export type ListBlueprintSubscriptionsResponses = {
    /**
     * No response was specified
     */
    200: Array<BlueprintSubscription>;
};

export type ListBlueprintSubscriptionsResponse = ListBlueprintSubscriptionsResponses[keyof ListBlueprintSubscriptionsResponses];

export type ListBlueprintImportsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        subscription_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/blueprint_subscriptions/{subscription_id}/migrations';
};

export type ListBlueprintImportsResponses = {
    /**
     * No response was specified
     */
    200: Array<BlueprintMigration>;
};

export type ListBlueprintImportsResponse = ListBlueprintImportsResponses[keyof ListBlueprintImportsResponses];

export type ShowBlueprintImportData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        subscription_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/blueprint_subscriptions/{subscription_id}/migrations/{id}';
};

export type ShowBlueprintImportResponses = {
    /**
     * No response was specified
     */
    200: BlueprintMigration;
};

export type ShowBlueprintImportResponse = ShowBlueprintImportResponses[keyof ShowBlueprintImportResponses];

export type GetImportDetailsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        subscription_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/blueprint_subscriptions/{subscription_id}/migrations/{id}/details';
};

export type GetImportDetailsResponses = {
    /**
     * No response was specified
     */
    200: Array<ChangeRecord>;
};

export type GetImportDetailsResponse = GetImportDetailsResponses[keyof GetImportDetailsResponses];

export type GetBlueprintInformationData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        template_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/blueprint_templates/{template_id}';
};

export type GetBlueprintInformationResponses = {
    /**
     * No response was specified
     */
    200: BlueprintTemplate;
};

export type GetBlueprintInformationResponse = GetBlueprintInformationResponses[keyof GetBlueprintInformationResponses];

export type GetAssociatedCourseInformationData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        template_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/blueprint_templates/{template_id}/associated_courses';
};

export type GetAssociatedCourseInformationResponses = {
    /**
     * No response was specified
     */
    200: Array<Course>;
};

export type GetAssociatedCourseInformationResponse = GetAssociatedCourseInformationResponses[keyof GetAssociatedCourseInformationResponses];

export type ListBlueprintMigrationsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        template_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/blueprint_templates/{template_id}/migrations';
};

export type ListBlueprintMigrationsResponses = {
    /**
     * No response was specified
     */
    200: Array<BlueprintMigration>;
};

export type ListBlueprintMigrationsResponse = ListBlueprintMigrationsResponses[keyof ListBlueprintMigrationsResponses];

export type BeginMigrationToPushToAssociatedCoursesData = {
    body?: {
        /**
         * An optional comment to be included in the sync history.
         */
        comment?: string;
        /**
         * Whether course settings should be copied over to associated courses.
         * Defaults to true for newly associated courses.
         */
        copy_settings?: boolean;
        /**
         * Send a notification to the calling user when the sync completes.
         */
        send_notification?: boolean;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        template_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/blueprint_templates/{template_id}/migrations';
};

export type BeginMigrationToPushToAssociatedCoursesResponses = {
    /**
     * No response was specified
     */
    200: BlueprintMigration;
};

export type BeginMigrationToPushToAssociatedCoursesResponse = BeginMigrationToPushToAssociatedCoursesResponses[keyof BeginMigrationToPushToAssociatedCoursesResponses];

export type ShowBlueprintMigrationData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        template_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/blueprint_templates/{template_id}/migrations/{id}';
};

export type ShowBlueprintMigrationResponses = {
    /**
     * No response was specified
     */
    200: BlueprintMigration;
};

export type ShowBlueprintMigrationResponse = ShowBlueprintMigrationResponses[keyof ShowBlueprintMigrationResponses];

export type GetMigrationDetailsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        template_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/blueprint_templates/{template_id}/migrations/{id}/details';
};

export type GetMigrationDetailsResponses = {
    /**
     * No response was specified
     */
    200: Array<ChangeRecord>;
};

export type GetMigrationDetailsResponse = GetMigrationDetailsResponses[keyof GetMigrationDetailsResponses];

export type SetOrRemoveRestrictionsOnBlueprintCourseObjectData = {
    body?: {
        /**
         * The ID of the object.
         */
        content_id?: number;
        /**
         * The type of the object.
         */
        content_type?: 'assignment' | 'attachment' | 'discussion_topic' | 'external_tool' | 'quiz' | 'wiki_page';
        /**
         * Whether to apply restrictions.
         */
        restricted?: boolean;
        /**
         * (Optional) If the object is restricted, this specifies a set of restrictions. If not specified,
         * the course-level restrictions will be used. See {api:CoursesController#update Course API update documentation}
         */
        restrictions?: unknown;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        template_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/blueprint_templates/{template_id}/restrict_item';
};

export type SetOrRemoveRestrictionsOnBlueprintCourseObjectResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetUnsyncedChangesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        template_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/blueprint_templates/{template_id}/unsynced_changes';
};

export type GetUnsyncedChangesResponses = {
    /**
     * No response was specified
     */
    200: Array<ChangeRecord>;
};

export type GetUnsyncedChangesResponse = GetUnsyncedChangesResponses[keyof GetUnsyncedChangesResponses];

export type UpdateAssociatedCoursesData = {
    body?: {
        /**
         * Courses to add as associated courses
         */
        course_ids_to_add?: Array<string>;
        /**
         * Courses to remove as associated courses
         */
        course_ids_to_remove?: Array<string>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        template_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/blueprint_templates/{template_id}/update_associations';
};

export type UpdateAssociatedCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetCourseTimetableData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/calendar_events/timetable';
};

export type GetCourseTimetableResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type SetCourseTimetableData = {
    body?: {
        /**
         * An array of timetable objects for the course section specified by course_section_id.
         * If course_section_id is set to "all", events will be created for the entire course.
         */
        'timetables[course_section_id]'?: Array<Array<{
            [key: string]: unknown;
        }>>;
        /**
         * Time to end each event at (e.g. "9:00 am")
         */
        'timetables[course_section_id][end_time]'?: Array<string>;
        /**
         * A location name to set for each event
         */
        'timetables[course_section_id][location_name]'?: Array<string>;
        /**
         * Time to start each event at (e.g. "9:00 am")
         */
        'timetables[course_section_id][start_time]'?: Array<string>;
        /**
         * A comma-separated list of abbreviated weekdays
         * (Mon-Monday, Tue-Tuesday, Wed-Wednesday, Thu-Thursday, Fri-Friday, Sat-Saturday, Sun-Sunday)
         */
        'timetables[course_section_id][weekdays]'?: Array<string>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/calendar_events/timetable';
};

export type SetCourseTimetableResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateOrUpdateEventsDirectlyForCourseTimetableData = {
    body?: {
        /**
         * Events will be created for the course section specified by course_section_id.
         * If not present, events will be created for the entire course.
         */
        course_section_id?: string;
        /**
         * An array of event objects to use.
         */
        events?: Array<Array<{
            [key: string]: unknown;
        }>>;
        /**
         * A unique identifier that can be used to update the event at a later time
         * If one is not specified, an identifier will be generated based on the start and end times
         */
        'events[code]'?: Array<string>;
        /**
         * End time for the event
         */
        'events[end_at]'?: Array<string>;
        /**
         * Location name for the event
         */
        'events[location_name]'?: Array<string>;
        /**
         * Start time for the event
         */
        'events[start_at]'?: Array<string>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/calendar_events/timetable_events';
};

export type CreateOrUpdateEventsDirectlyForCourseTimetableResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListCollaborationsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/collaborations';
};

export type ListCollaborationsCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<Collaboration>;
};

export type ListCollaborationsCoursesResponse = ListCollaborationsCoursesResponses[keyof ListCollaborationsCoursesResponses];

export type ListConferencesCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/conferences';
};

export type ListConferencesCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<Conference>;
};

export type ListConferencesCoursesResponse = ListConferencesCoursesResponses[keyof ListConferencesCoursesResponses];

export type ListContentExportsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/content_exports';
};

export type ListContentExportsCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<ContentExport>;
};

export type ListContentExportsCoursesResponse = ListContentExportsCoursesResponses[keyof ListContentExportsCoursesResponses];

export type ExportContentCoursesData = {
    body: {
        /**
         * "common_cartridge":: Export the contents of the course in the Common Cartridge (.imscc) format
         * "qti":: Export quizzes from a course in the QTI format
         * "zip":: Export files from a course, group, or user in a zip file
         */
        export_type: 'common_cartridge' | 'qti' | 'zip';
        /**
         * The select parameter allows exporting specific data. The keys are object types like 'files',
         * 'folders', 'pages', etc. The value for each key is a list of object ids. An id can be an
         * integer or a string.
         *
         * Multiple object types can be selected in the same call. However, not all object types are
         * valid for every export_type. Common Cartridge supports all object types. Zip and QTI only
         * support the object types as described below.
         *
         * "folders":: Also supported for zip export_type.
         * "files":: Also supported for zip export_type.
         * "quizzes":: Also supported for qti export_type.
         */
        select?: 'folders' | 'files' | 'attachments' | 'quizzes' | 'assignments' | 'announcements' | 'calendar_events' | 'discussion_topics' | 'modules' | 'module_items' | 'pages' | 'rubrics';
        /**
         * Don't send the notifications about the export to the user. Default: false
         */
        skip_notifications?: boolean;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/content_exports';
};

export type ExportContentCoursesResponses = {
    /**
     * No response was specified
     */
    200: ContentExport;
};

export type ExportContentCoursesResponse = ExportContentCoursesResponses[keyof ExportContentCoursesResponses];

export type ShowContentExportCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/content_exports/{id}';
};

export type ShowContentExportCoursesResponses = {
    /**
     * No response was specified
     */
    200: ContentExport;
};

export type ShowContentExportCoursesResponse = ShowContentExportCoursesResponses[keyof ShowContentExportCoursesResponses];

export type ListLicensesCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/content_licenses';
};

export type ListLicensesCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<License>;
};

export type ListLicensesCoursesResponse = ListLicensesCoursesResponses[keyof ListLicensesCoursesResponses];

export type ListContentMigrationsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/content_migrations';
};

export type ListContentMigrationsCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<ContentMigration>;
};

export type ListContentMigrationsCoursesResponse = ListContentMigrationsCoursesResponses[keyof ListContentMigrationsCoursesResponses];

export type CreateContentMigrationCoursesData = {
    body: {
        /**
         * Move anything scheduled for day 'X' to the specified day. (0-Sunday,
         * 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
         */
        'date_shift_options[day_substitutions][X]'?: number;
        /**
         * The new end date for the source content/course
         */
        'date_shift_options[new_end_date]'?: string;
        /**
         * The new start date for the content/course
         */
        'date_shift_options[new_start_date]'?: string;
        /**
         * The original end date of the source content/course
         */
        'date_shift_options[old_end_date]'?: string;
        /**
         * The original start date of the source content/course
         */
        'date_shift_options[old_start_date]'?: string;
        /**
         * Whether to remove dates in the copied course. Cannot be used
         * in conjunction with *shift_dates*.
         */
        'date_shift_options[remove_dates]'?: boolean;
        /**
         * Whether to shift dates in the copied course
         */
        'date_shift_options[shift_dates]'?: boolean;
        /**
         * The type of the migration. Use the
         * {api:ContentMigrationsController#available_migrators Migrator} endpoint to
         * see all available migrators. Default allowed values:
         * canvas_cartridge_importer, common_cartridge_importer,
         * course_copy_importer, zip_file_importer, qti_converter, moodle_converter
         */
        migration_type: string;
        /**
         * Required if uploading a file. This is the first step in uploading a file
         * to the content migration. See the {file:file_uploads.html File Upload
         * Documentation} for details on the file upload workflow.
         */
        'pre_attachment[name]'?: string;
        /**
         * Other file upload properties, See {file:file_uploads.html File Upload
         * Documentation}
         */
        'pre_attachment[todo]'?: string;
        /**
         * A URL to download the file from. Must not require authentication.
         */
        'settings[file_url]'?: string;
        /**
         * The folder to unzip the .zip file into for a zip_file_import.
         */
        'settings[folder_id]'?: string;
        /**
         * Whether to overwrite quizzes with the same identifiers between content
         * packages.
         */
        'settings[overwrite_quizzes]'?: boolean;
        /**
         * The existing question bank ID to import questions into if not specified in
         * the content package.
         */
        'settings[question_bank_id]'?: number;
        /**
         * The question bank to import questions into if not specified in the content
         * package, if both bank id and name are set, id will take precedence.
         */
        'settings[question_bank_name]'?: string;
        /**
         * The course to copy from for a course copy migration. (required if doing
         * course copy)
         */
        'settings[source_course_id]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/content_migrations';
};

export type CreateContentMigrationCoursesResponses = {
    /**
     * No response was specified
     */
    200: ContentMigration;
};

export type CreateContentMigrationCoursesResponse = CreateContentMigrationCoursesResponses[keyof CreateContentMigrationCoursesResponses];

export type ListMigrationSystemsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/content_migrations/migrators';
};

export type ListMigrationSystemsCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<Migrator>;
};

export type ListMigrationSystemsCoursesResponse = ListMigrationSystemsCoursesResponses[keyof ListMigrationSystemsCoursesResponses];

export type ListMigrationIssuesCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        content_migration_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues';
};

export type ListMigrationIssuesCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<MigrationIssue>;
};

export type ListMigrationIssuesCoursesResponse = ListMigrationIssuesCoursesResponses[keyof ListMigrationIssuesCoursesResponses];

export type GetMigrationIssueCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        content_migration_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues/{id}';
};

export type GetMigrationIssueCoursesResponses = {
    /**
     * No response was specified
     */
    200: MigrationIssue;
};

export type GetMigrationIssueCoursesResponse = GetMigrationIssueCoursesResponses[keyof GetMigrationIssueCoursesResponses];

export type UpdateMigrationIssueCoursesData = {
    body: {
        /**
         * Set the workflow_state of the issue.
         */
        workflow_state: 'active' | 'resolved';
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        content_migration_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues/{id}';
};

export type UpdateMigrationIssueCoursesResponses = {
    /**
     * No response was specified
     */
    200: MigrationIssue;
};

export type UpdateMigrationIssueCoursesResponse = UpdateMigrationIssueCoursesResponses[keyof UpdateMigrationIssueCoursesResponses];

export type GetContentMigrationCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/content_migrations/{id}';
};

export type GetContentMigrationCoursesResponses = {
    /**
     * No response was specified
     */
    200: ContentMigration;
};

export type GetContentMigrationCoursesResponse = GetContentMigrationCoursesResponses[keyof GetContentMigrationCoursesResponses];

export type UpdateContentMigrationCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/content_migrations/{id}';
};

export type UpdateContentMigrationCoursesResponses = {
    /**
     * No response was specified
     */
    200: ContentMigration;
};

export type UpdateContentMigrationCoursesResponse = UpdateContentMigrationCoursesResponses[keyof UpdateContentMigrationCoursesResponses];

export type CopyCourseContentData = {
    body?: {
        /**
         * A list of the course content types to exclude, all areas not listed will
         * be copied.
         */
        except?: Array<'course_settings' | 'assignments' | 'external_tools' | 'files' | 'topics' | 'calendar_events' | 'quizzes' | 'wiki_pages' | 'modules' | 'outcomes'>;
        /**
         * A list of the course content types to copy, all areas not listed will not
         * be copied.
         */
        only?: Array<'course_settings' | 'assignments' | 'external_tools' | 'files' | 'topics' | 'calendar_events' | 'quizzes' | 'wiki_pages' | 'modules' | 'outcomes'>;
        /**
         * ID or SIS-ID of the course to copy the content from
         */
        source_course?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/course_copy';
};

export type CopyCourseContentResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetCourseCopyStatusData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/course_copy/{id}';
};

export type GetCourseCopyStatusResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type BulkUpdateColumnDataData = {
    body: {
        /**
         * Column content. Setting this to an empty string will delete the data object.
         */
        column_data: Array<Array<{
            [key: string]: unknown;
        }>>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/custom_gradebook_column_data';
};

export type BulkUpdateColumnDataResponses = {
    /**
     * No response was specified
     */
    200: Progress;
};

export type BulkUpdateColumnDataResponse = BulkUpdateColumnDataResponses[keyof BulkUpdateColumnDataResponses];

export type ListCustomGradebookColumnsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * Include hidden parameters (defaults to false)
         */
        include_hidden?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/custom_gradebook_columns';
};

export type ListCustomGradebookColumnsResponses = {
    /**
     * No response was specified
     */
    200: Array<CustomColumn>;
};

export type ListCustomGradebookColumnsResponse = ListCustomGradebookColumnsResponses[keyof ListCustomGradebookColumnsResponses];

export type CreateCustomGradebookColumnData = {
    body: {
        /**
         * Hidden columns are not displayed in the gradebook
         */
        'column[hidden]'?: boolean;
        /**
         * The position of the column relative to other custom columns
         */
        'column[position]'?: number;
        /**
         * Set this to prevent the column from being editable in the gradebook ui
         */
        'column[read_only]'?: boolean;
        /**
         * Set this if the column is created by a teacher.  The gradebook only
         * supports one teacher_notes column.
         */
        'column[teacher_notes]'?: boolean;
        /**
         * no description
         */
        'column[title]': string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/custom_gradebook_columns';
};

export type CreateCustomGradebookColumnResponses = {
    /**
     * No response was specified
     */
    200: CustomColumn;
};

export type CreateCustomGradebookColumnResponse = CreateCustomGradebookColumnResponses[keyof CreateCustomGradebookColumnResponses];

export type ReorderCustomColumnsData = {
    body: {
        /**
         * no description
         */
        order: Array<number>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/custom_gradebook_columns/reorder';
};

export type ReorderCustomColumnsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteCustomGradebookColumnData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/custom_gradebook_columns/{id}';
};

export type DeleteCustomGradebookColumnResponses = {
    /**
     * No response was specified
     */
    200: CustomColumn;
};

export type DeleteCustomGradebookColumnResponse = DeleteCustomGradebookColumnResponses[keyof DeleteCustomGradebookColumnResponses];

export type UpdateCustomGradebookColumnData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/custom_gradebook_columns/{id}';
};

export type UpdateCustomGradebookColumnResponses = {
    /**
     * No response was specified
     */
    200: CustomColumn;
};

export type UpdateCustomGradebookColumnResponse = UpdateCustomGradebookColumnResponses[keyof UpdateCustomGradebookColumnResponses];

export type ListEntriesForColumnData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * If true, hidden columns will be included in the
         * result. If false or absent, only visible columns
         * will be returned.
         */
        include_hidden?: boolean;
    };
    url: '/v1/courses/{course_id}/custom_gradebook_columns/{id}/data';
};

export type ListEntriesForColumnResponses = {
    /**
     * No response was specified
     */
    200: Array<ColumnDatum>;
};

export type ListEntriesForColumnResponse = ListEntriesForColumnResponses[keyof ListEntriesForColumnResponses];

export type UpdateColumnDataData = {
    body: {
        /**
         * Column content.  Setting this to blank will delete the datum object.
         */
        'column_data[content]': string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/custom_gradebook_columns/{id}/data/{user_id}';
};

export type UpdateColumnDataResponses = {
    /**
     * No response was specified
     */
    200: ColumnDatum;
};

export type UpdateColumnDataResponse = UpdateColumnDataResponses[keyof UpdateColumnDataResponses];

export type CreateToolFromToolconfigurationCoursesData = {
    body?: {
        /**
         * if account
         */
        account_id?: string;
    };
    path: {
        /**
         * if course
         */
        course_id: string;
        /**
         * no description
         */
        developer_key_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/developer_keys/{developer_key_id}/create_tool';
};

export type CreateToolFromToolconfigurationCoursesResponses = {
    /**
     * No response was specified
     */
    200: ContextExternalTool;
};

export type CreateToolFromToolconfigurationCoursesResponse = CreateToolFromToolconfigurationCoursesResponses[keyof CreateToolFromToolconfigurationCoursesResponses];

export type ListDiscussionTopicsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * If "all_dates" is passed, all dates associated with graded discussions'
         * assignments will be included.
         * if "sections" is passed, includes the course sections that are associated
         * with the topic, if the topic is specific to certain sections of the course.
         * If "sections_user_count" is passed, then:
         * (a) If sections were asked for *and* the topic is specific to certain
         * course sections, includes the number of users in each
         * section. (as part of the section json asked for above)
         * (b) Else, includes at the root level the total number of users in the
         * topic's context (group or course) that the topic applies to.
         * If "overrides" is passed, the overrides for the assignment will be included
         */
        include?: Array<'all_dates' | 'sections' | 'sections_user_count' | 'overrides'>;
        /**
         * Determines the order of the discussion topic list. Defaults to "position".
         */
        order_by?: 'position' | 'recent_activity' | 'title';
        /**
         * Only return discussion topics in the given state(s). Defaults to including
         * all topics. Filtering is done after pagination, so pages
         * may be smaller than requested if topics are filtered.
         * Can pass multiple states as comma separated string.
         */
        scope?: 'locked' | 'unlocked' | 'pinned' | 'unpinned';
        /**
         * Return announcements instead of discussion topics. Defaults to false
         */
        only_announcements?: boolean;
        /**
         * The state of the discussion topic to return. Currently only supports unread state.
         */
        filter_by?: 'all' | 'unread';
        /**
         * The partial title of the discussion topics to match and return.
         */
        search_term?: string;
        /**
         * For students, exclude topics that are locked by module progression.
         * Defaults to false.
         */
        exclude_context_module_locked_topics?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/discussion_topics';
};

export type ListDiscussionTopicsCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<DiscussionTopic>;
};

export type ListDiscussionTopicsCoursesResponse = ListDiscussionTopicsCoursesResponses[keyof ListDiscussionTopicsCoursesResponses];

export type CreateNewDiscussionTopicCoursesData = {
    body?: {
        /**
         * Whether or not users can rate entries in this topic.
         */
        allow_rating?: boolean;
        /**
         * To create an assignment discussion, pass the assignment parameters as a
         * sub-object. See the {api:AssignmentsApiController#create Create an Assignment API}
         * for the available parameters. The name parameter will be ignored, as it's
         * taken from the discussion title. If you want to make a discussion that was
         * an assignment NOT an assignment, pass set_assignment = false as part of
         * the assignment object
         */
        assignment?: unknown;
        /**
         * A application/x-www-form-urlencoded form-field-style attachment.
         * Attachments larger than 1 kilobyte are subject to quota restrictions.
         */
        attachment?: Blob | File;
        /**
         * If a timestamp is given, the topic will not be published until that time.
         */
        delayed_post_at?: string;
        /**
         * The type of discussion. Defaults to side_comment if not value is given. Accepted values are 'side_comment', for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
         */
        discussion_type?: 'side_comment' | 'threaded';
        /**
         * If present, the topic will become a group discussion assigned
         * to the group.
         */
        group_category_id?: number;
        /**
         * If true, this topic is an announcement. It will appear in the
         * announcement's section rather than the discussions section. This requires
         * announcment-posting permissions.
         */
        is_announcement?: boolean;
        /**
         * If a timestamp is given, the topic will be scheduled to lock at the
         * provided timestamp. If the timestamp is in the past, the topic will be
         * locked.
         */
        lock_at?: string;
        /**
         * no description
         */
        message?: string;
        /**
         * If true, only graders will be allowed to rate entries.
         */
        only_graders_can_rate?: boolean;
        /**
         * If true, this topic will be listed in the "Pinned Discussion" section
         */
        pinned?: boolean;
        /**
         * If true, the topic will have an associated podcast feed.
         */
        podcast_enabled?: boolean;
        /**
         * If true, the podcast will include posts from students as well. Implies
         * podcast_enabled.
         */
        podcast_has_student_posts?: boolean;
        /**
         * By default, discussions are sorted chronologically by creation date, you
         * can pass the id of another topic to have this one show up after the other
         * when they are listed.
         */
        position_after?: string;
        /**
         * Whether this topic is published (true) or draft state (false). Only
         * teachers and TAs have the ability to create draft state topics.
         */
        published?: boolean;
        /**
         * If true then a user may not respond to other replies until that user has
         * made an initial reply. Defaults to false.
         */
        require_initial_post?: boolean;
        /**
         * If true, entries will be sorted by rating.
         */
        sort_by_rating?: boolean;
        /**
         * A comma-separated list of sections ids to which the discussion topic
         * should be made specific too.  If it is not desired to make the discussion
         * topic specific to sections, then this parameter may be omitted or set to
         * "all".  Can only be present only on announcements and only those that are
         * for a course (as opposed to a group).
         */
        specific_sections?: string;
        /**
         * no description
         */
        title?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics';
};

export type CreateNewDiscussionTopicCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ReorderPinnedTopicsCoursesData = {
    body: {
        /**
         * The ids of the pinned discussion topics in the desired order.
         * (For example, "order=104,102,103".)
         */
        order: Array<number>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/reorder';
};

export type ReorderPinnedTopicsCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteTopicCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}';
};

export type DeleteTopicCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleTopicCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: {
        /**
         * If "all_dates" is passed, all dates associated with graded discussions'
         * assignments will be included.
         * if "sections" is passed, includes the course sections that are associated
         * with the topic, if the topic is specific to certain sections of the course.
         * If "sections_user_count" is passed, then:
         * (a) If sections were asked for *and* the topic is specific to certain
         * course sections, includes the number of users in each
         * section. (as part of the section json asked for above)
         * (b) Else, includes at the root level the total number of users in the
         * topic's context (group or course) that the topic applies to.
         * If "overrides" is passed, the overrides for the assignment will be included
         */
        include?: Array<'all_dates' | 'sections' | 'sections_user_count' | 'overrides'>;
    };
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}';
};

export type GetSingleTopicCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateTopicCoursesData = {
    body?: {
        /**
         * If true, users will be allowed to rate entries.
         */
        allow_rating?: boolean;
        /**
         * To create an assignment discussion, pass the assignment parameters as a
         * sub-object. See the {api:AssignmentsApiController#create Create an Assignment API}
         * for the available parameters. The name parameter will be ignored, as it's
         * taken from the discussion title. If you want to make a discussion that was
         * an assignment NOT an assignment, pass set_assignment = false as part of
         * the assignment object
         */
        assignment?: unknown;
        /**
         * If a timestamp is given, the topic will not be published until that time.
         */
        delayed_post_at?: string;
        /**
         * The type of discussion. Defaults to side_comment if not value is given. Accepted values are 'side_comment', for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
         */
        discussion_type?: 'side_comment' | 'threaded';
        /**
         * If present, the topic will become a group discussion assigned
         * to the group.
         */
        group_category_id?: number;
        /**
         * If true, this topic is an announcement. It will appear in the
         * announcement's section rather than the discussions section. This requires
         * announcment-posting permissions.
         */
        is_announcement?: boolean;
        /**
         * If a timestamp is given, the topic will be scheduled to lock at the
         * provided timestamp. If the timestamp is in the past, the topic will be
         * locked.
         */
        lock_at?: string;
        /**
         * no description
         */
        message?: string;
        /**
         * If true, only graders will be allowed to rate entries.
         */
        only_graders_can_rate?: boolean;
        /**
         * If true, this topic will be listed in the "Pinned Discussion" section
         */
        pinned?: boolean;
        /**
         * If true, the topic will have an associated podcast feed.
         */
        podcast_enabled?: boolean;
        /**
         * If true, the podcast will include posts from students as well. Implies
         * podcast_enabled.
         */
        podcast_has_student_posts?: boolean;
        /**
         * By default, discussions are sorted chronologically by creation date, you
         * can pass the id of another topic to have this one show up after the other
         * when they are listed.
         */
        position_after?: string;
        /**
         * Whether this topic is published (true) or draft state (false). Only
         * teachers and TAs have the ability to create draft state topics.
         */
        published?: boolean;
        /**
         * If true then a user may not respond to other replies until that user has
         * made an initial reply. Defaults to false.
         */
        require_initial_post?: boolean;
        /**
         * If true, entries will be sorted by rating.
         */
        sort_by_rating?: boolean;
        /**
         * A comma-separated list of sections ids to which the discussion topic
         * should be made specific too.  If it is not desired to make the discussion
         * topic specific to sections, then this parameter may be omitted or set to
         * "all".  Can only be present only on announcements and only those that are
         * for a course (as opposed to a group).
         */
        specific_sections?: string;
        /**
         * no description
         */
        title?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}';
};

export type UpdateTopicCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListTopicEntriesCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries';
};

export type ListTopicEntriesCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type PostEntryCoursesData = {
    body?: {
        /**
         * a application/x-www-form-urlencoded form-field-style
         * attachment. Attachments larger than 1 kilobyte are subject to quota
         * restrictions.
         */
        attachment?: string;
        /**
         * The body of the entry.
         */
        message?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries';
};

export type PostEntryCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type RateEntryCoursesData = {
    body?: {
        /**
         * A rating to set on this entry. Only 0 and 1 are accepted.
         */
        rating?: number;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        entry_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/rating';
};

export type RateEntryCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkEntryAsUnreadCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        entry_id: string;
    };
    query?: {
        /**
         * A boolean value to set the entry's forced_read_state. No change is made if
         * this argument is not specified.
         */
        forced_read_state?: boolean;
    };
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/read';
};

export type MarkEntryAsUnreadCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkEntryAsReadCoursesData = {
    body?: {
        /**
         * A boolean value to set the entry's forced_read_state. No change is made if
         * this argument is not specified.
         */
        forced_read_state?: boolean;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        entry_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/read';
};

export type MarkEntryAsReadCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListEntryRepliesCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        entry_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies';
};

export type ListEntryRepliesCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type PostReplyCoursesData = {
    body?: {
        /**
         * a application/x-www-form-urlencoded form-field-style
         * attachment. Attachments larger than 1 kilobyte are subject to quota
         * restrictions.
         */
        attachment?: string;
        /**
         * The body of the entry.
         */
        message?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        entry_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies';
};

export type PostReplyCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteEntryCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{id}';
};

export type DeleteEntryCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateEntryCoursesData = {
    body?: {
        /**
         * The updated body of the entry.
         */
        message?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{id}';
};

export type UpdateEntryCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListEntriesCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: {
        /**
         * A list of entry ids to retrieve. Entries will be returned in id order,
         * smallest id first.
         */
        ids?: Array<string>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/entry_list';
};

export type ListEntriesCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkTopicAsUnreadCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/read';
};

export type MarkTopicAsUnreadCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkTopicAsReadCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/read';
};

export type MarkTopicAsReadCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkAllEntriesAsUnreadCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: {
        /**
         * A boolean value to set all of the entries' forced_read_state. No change is
         * made if this argument is not specified.
         */
        forced_read_state?: boolean;
    };
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/read_all';
};

export type MarkAllEntriesAsUnreadCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkAllEntriesAsReadCoursesData = {
    body?: {
        /**
         * A boolean value to set all of the entries' forced_read_state. No change
         * is made if this argument is not specified.
         */
        forced_read_state?: boolean;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/read_all';
};

export type MarkAllEntriesAsReadCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UnsubscribeFromTopicCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/subscribed';
};

export type UnsubscribeFromTopicCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type SubscribeToTopicCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/subscribed';
};

export type SubscribeToTopicCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetFullTopicCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/discussion_topics/{topic_id}/view';
};

export type GetFullTopicCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetEffectiveDueDatesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * no description
         */
        assignment_ids?: Array<string>;
    };
    url: '/v1/courses/{course_id}/effective_due_dates';
};

export type GetEffectiveDueDatesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListEnrollmentsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
        /**
         * A list of enrollment types to return. Accepted values are
         * 'StudentEnrollment', 'TeacherEnrollment', 'TaEnrollment',
         * 'DesignerEnrollment', and 'ObserverEnrollment.' If omitted, all enrollment
         * types are returned. This argument is ignored if `role` is given.
         */
        type?: Array<string>;
        /**
         * A list of enrollment roles to return. Accepted values include course-level
         * roles created by the {api:RoleOverridesController#add_role Add Role API}
         * as well as the base enrollment types accepted by the `type` argument above.
         */
        role?: Array<string>;
        /**
         * Filter by enrollment state. If omitted, 'active' and 'invited' enrollments
         * are returned. When querying a user's enrollments (either via user_id
         * argument or via user enrollments endpoint), the following additional
         * synthetic states are supported: "current_and_invited"|"current_and_future"|"current_and_concluded"
         */
        state?: Array<'active' | 'invited' | 'creation_pending' | 'deleted' | 'rejected' | 'completed' | 'inactive'>;
        /**
         * Array of additional information to include on the enrollment or user records.
         * "avatar_url" and "group_ids" will be returned on the user record.
         */
        include?: Array<'avatar_url' | 'group_ids' | 'locked' | 'observed_users' | 'can_be_removed'>;
        /**
         * Filter by user_id (only valid for course or section enrollment
         * queries). If set to the current user's id, this is a way to
         * determine if the user has any enrollments in the course or section,
         * independent of whether the user has permission to view other people
         * on the roster.
         */
        user_id?: string;
        /**
         * Return grades for the given grading_period.  If this parameter is not
         * specified, the returned grades will be for the whole course.
         */
        grading_period_id?: number;
        /**
         * Returns only enrollments for the specified enrollment term. This parameter
         * only applies to the user enrollments path. May pass the ID from the
         * enrollment terms api or the SIS id prepended with 'sis_term_id:'.
         */
        enrollment_term_id?: number;
        /**
         * Returns only enrollments for the specified SIS account ID(s). Does not
         * look into sub_accounts. May pass in array or string.
         */
        sis_account_id?: Array<string>;
        /**
         * Returns only enrollments matching the specified SIS course ID(s).
         * May pass in array or string.
         */
        sis_course_id?: Array<string>;
        /**
         * Returns only section enrollments matching the specified SIS section ID(s).
         * May pass in array or string.
         */
        sis_section_id?: Array<string>;
        /**
         * Returns only enrollments for the specified SIS user ID(s). May pass in
         * array or string.
         */
        sis_user_id?: Array<string>;
    };
    url: '/v1/courses/{course_id}/enrollments';
};

export type ListEnrollmentsCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<Enrollment>;
};

export type ListEnrollmentsCoursesResponse = ListEnrollmentsCoursesResponses[keyof ListEnrollmentsCoursesResponses];

export type EnrollUserCoursesData = {
    body: {
        /**
         * For an observer enrollment, the ID of a student to observe. The
         * caller must have +manage_students+ permission in the course.
         * This is a one-off operation; to automatically observe all a
         * student's enrollments (for example, as a parent), please use
         * the {api:UserObserveesController#create User Observees API}.
         */
        'enrollment[associated_user_id]'?: number;
        /**
         * The ID of the course section to enroll the student in. If the
         * section-specific URL is used, this argument is redundant and will be
         * ignored.
         */
        'enrollment[course_section_id]'?: number;
        /**
         * If set to 'active,' student will be immediately enrolled in the course.
         * Otherwise they will be required to accept a course invitation. Default is
         * 'invited.'.
         *
         * If set to 'inactive', student will be listed in the course roster for
         * teachers, but will not be able to participate in the course until
         * their enrollment is activated.
         */
        'enrollment[enrollment_state]'?: 'active' | 'invited' | 'inactive';
        /**
         * If set, the enrollment will only allow the user to see and interact with
         * users enrolled in the section given by course_section_id.
         * * For teachers and TAs, this includes grading privileges.
         * * Section-limited students will not see any users (including teachers
         * and TAs) not enrolled in their sections.
         * * Users may have other enrollments that grant privileges to
         * multiple sections in the same course.
         */
        'enrollment[limit_privileges_to_course_section]'?: boolean;
        /**
         * If true, a notification will be sent to the enrolled user.
         * Notifications are not sent by default.
         */
        'enrollment[notify]'?: boolean;
        /**
         * Assigns a custom course-level role to the user.
         */
        'enrollment[role]'?: unknown;
        /**
         * Assigns a custom course-level role to the user.
         */
        'enrollment[role_id]'?: number;
        /**
         * If true, marks the enrollment as a self-enrollment, which gives
         * students the ability to drop the course if desired. Defaults to false.
         */
        'enrollment[self_enrolled]'?: boolean;
        /**
         * If the current user is not allowed to manage enrollments in this
         * course, but the course allows self-enrollment, the user can self-
         * enroll as a student in the default section by passing in a valid
         * code. When self-enrolling, the user_id must be 'self'. The
         * enrollment_state will be set to 'active' and all other arguments
         * will be ignored.
         */
        'enrollment[self_enrollment_code]'?: string;
        /**
         * Enroll the user as a student, teacher, TA, observer, or designer. If no
         * value is given, the type will be inferred by enrollment[role] if supplied,
         * otherwise 'StudentEnrollment' will be used.
         */
        'enrollment[type]': 'StudentEnrollment' | 'TeacherEnrollment' | 'TaEnrollment' | 'ObserverEnrollment' | 'DesignerEnrollment';
        /**
         * The ID of the user to be enrolled in the course.
         */
        'enrollment[user_id]': string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/enrollments';
};

export type EnrollUserCoursesResponses = {
    /**
     * No response was specified
     */
    200: Enrollment;
};

export type EnrollUserCoursesResponse = EnrollUserCoursesResponses[keyof EnrollUserCoursesResponses];

export type ConcludeDeactivateOrDeleteEnrollmentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * The action to take on the enrollment.
         * When inactive, a user will still appear in the course roster to admins, but be unable to participate.
         * ("inactivate" and "deactivate" are equivalent tasks)
         */
        task?: 'conclude' | 'delete' | 'inactivate' | 'deactivate';
    };
    url: '/v1/courses/{course_id}/enrollments/{id}';
};

export type ConcludeDeactivateOrDeleteEnrollmentResponses = {
    /**
     * No response was specified
     */
    200: Enrollment;
};

export type ConcludeDeactivateOrDeleteEnrollmentResponse = ConcludeDeactivateOrDeleteEnrollmentResponses[keyof ConcludeDeactivateOrDeleteEnrollmentResponses];

export type AcceptCourseInvitationData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/enrollments/{id}/accept';
};

export type AcceptCourseInvitationResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ReActivateEnrollmentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/enrollments/{id}/reactivate';
};

export type ReActivateEnrollmentResponses = {
    /**
     * No response was specified
     */
    200: Enrollment;
};

export type ReActivateEnrollmentResponse = ReActivateEnrollmentResponses[keyof ReActivateEnrollmentResponses];

export type RejectCourseInvitationData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/enrollments/{id}/reject';
};

export type RejectCourseInvitationResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateEpubExportData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/epub_exports';
};

export type CreateEpubExportResponses = {
    /**
     * No response was specified
     */
    200: EpubExport;
};

export type CreateEpubExportResponse = CreateEpubExportResponses[keyof CreateEpubExportResponses];

export type ShowEpubExportData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/epub_exports/{id}';
};

export type ShowEpubExportResponses = {
    /**
     * No response was specified
     */
    200: EpubExport;
};

export type ShowEpubExportResponse = ShowEpubExportResponses[keyof ShowEpubExportResponses];

export type ListExternalFeedsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/external_feeds';
};

export type ListExternalFeedsCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<ExternalFeed>;
};

export type ListExternalFeedsCoursesResponse = ListExternalFeedsCoursesResponses[keyof ListExternalFeedsCoursesResponses];

export type CreateExternalFeedCoursesData = {
    body: {
        /**
         * If given, only feed entries that contain this string in their title will be imported
         */
        header_match?: boolean;
        /**
         * The url to the external rss or atom feed
         */
        url: string;
        /**
         * Defaults to "full"
         */
        verbosity?: 'full' | 'truncate' | 'link_only';
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/external_feeds';
};

export type CreateExternalFeedCoursesResponses = {
    /**
     * No response was specified
     */
    200: ExternalFeed;
};

export type CreateExternalFeedCoursesResponse = CreateExternalFeedCoursesResponses[keyof CreateExternalFeedCoursesResponses];

export type DeleteExternalFeedCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        external_feed_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/external_feeds/{external_feed_id}';
};

export type DeleteExternalFeedCoursesResponses = {
    /**
     * No response was specified
     */
    200: ExternalFeed;
};

export type DeleteExternalFeedCoursesResponse = DeleteExternalFeedCoursesResponses[keyof DeleteExternalFeedCoursesResponses];

export type ListExternalToolsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The partial name of the tools to match and return.
         */
        search_term?: string;
        /**
         * If true, then only tools that are meant to be selectable are returned
         */
        selectable?: boolean;
        /**
         * If true, then include tools installed in all accounts above the current context
         */
        include_parents?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/external_tools';
};

export type ListExternalToolsCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateExternalToolCoursesData = {
    body: {
        /**
         * The layout type to use when launching the tool. Must be
         * "full_width", "full_width_in_context", "borderless", or "default"
         */
        'account_navigation[display_type]'?: string;
        /**
         * Set this to enable this feature
         */
        'account_navigation[enabled]'?: boolean;
        /**
         * The height of the dialog the tool is launched in
         */
        'account_navigation[selection_height]'?: string;
        /**
         * The width of the dialog the tool is launched in
         */
        'account_navigation[selection_width]'?: string;
        /**
         * The text that will show on the left-tab in the account navigation
         */
        'account_navigation[text]'?: string;
        /**
         * The url of the external tool for account navigation
         */
        'account_navigation[url]'?: string;
        /**
         * Configuration can be passed in as CC xml instead of using query
         * parameters. If this value is "by_url" or "by_xml" then an xml
         * configuration will be expected in either the "config_xml" or "config_url"
         * parameter. Note that the name parameter overrides the tool name provided
         * in the xml
         */
        config_type?: string;
        /**
         * URL where the server can retrieve an XML tool configuration, as specified
         * in the CC xml specification. This is required if "config_type" is set to
         * "by_url"
         */
        config_url?: string;
        /**
         * XML tool configuration, as specified in the CC xml specification. This is
         * required if "config_type" is set to "by_xml"
         */
        config_xml?: string;
        /**
         * The consumer key for the external tool
         */
        consumer_key: string;
        /**
         * Set this to enable this feature
         */
        'course_home_sub_navigation[enabled]'?: boolean;
        /**
         * The url of the icon to show in the right-side course home navigation menu
         */
        'course_home_sub_navigation[icon_url]'?: string;
        /**
         * The text that will show on the right-side course home navigation menu
         */
        'course_home_sub_navigation[text]'?: string;
        /**
         * The url of the external tool for right-side course home navigation menu
         */
        'course_home_sub_navigation[url]'?: string;
        /**
         * Whether the navigation option will show in the course by default or
         * whether the teacher will have to explicitly enable it
         */
        'course_navigation[default]'?: boolean;
        /**
         * The layout type to use when launching the tool. Must be
         * "full_width", "full_width_in_context", "borderless", or "default"
         */
        'course_navigation[display_type]'?: string;
        /**
         * Set this to enable this feature
         */
        'course_navigation[enabled]'?: boolean;
        /**
         * The text that will show on the left-tab in the course navigation
         */
        'course_navigation[text]'?: string;
        /**
         * Who will see the navigation tab. "admins" for course admins, "members" for
         * students, null for everyone
         */
        'course_navigation[visibility]'?: 'admins' | 'members';
        /**
         * Determines how the navigation tab will be opened.
         * "_blank"	Launches the external tool in a new window or tab.
         * "_self"	(Default) Launches the external tool in an iframe inside of Canvas.
         */
        'course_navigation[windowTarget]'?: '_blank' | '_self';
        /**
         * Custom fields that will be sent to the tool consumer; can be used
         * multiple times
         */
        'custom_fields[field_name]'?: string;
        /**
         * A description of the tool
         */
        description?: string;
        /**
         * The domain to match links against. Either "url" or "domain" should be
         * set, not both.
         */
        domain?: string;
        /**
         * Set this to enable this feature
         */
        'editor_button[enabled]'?: boolean;
        /**
         * The url of the icon to show in the WYSIWYG editor
         */
        'editor_button[icon_url]'?: string;
        /**
         * Set this to ContentItemSelectionRequest to tell the tool to use
         * content-item; otherwise, omit
         */
        'editor_button[message_type]'?: string;
        /**
         * The height of the dialog the tool is launched in
         */
        'editor_button[selection_height]'?: string;
        /**
         * The width of the dialog the tool is launched in
         */
        'editor_button[selection_width]'?: string;
        /**
         * The url of the external tool
         */
        'editor_button[url]'?: string;
        /**
         * Set this to enable this feature
         */
        'homework_submission[enabled]'?: boolean;
        /**
         * Set this to ContentItemSelectionRequest to tell the tool to use
         * content-item; otherwise, omit
         */
        'homework_submission[message_type]'?: string;
        /**
         * The text that will show on the homework submission tab
         */
        'homework_submission[text]'?: string;
        /**
         * The url of the external tool
         */
        'homework_submission[url]'?: string;
        /**
         * The url of the icon to show for this tool
         */
        icon_url?: string;
        /**
         * Set this to enable this feature
         */
        'link_selection[enabled]'?: boolean;
        /**
         * Set this to ContentItemSelectionRequest to tell the tool to use
         * content-item; otherwise, omit
         */
        'link_selection[message_type]'?: string;
        /**
         * The text that will show for the link selection text
         */
        'link_selection[text]'?: string;
        /**
         * The url of the external tool
         */
        'link_selection[url]'?: string;
        /**
         * Set this to enable this feature
         */
        'migration_selection[enabled]'?: boolean;
        /**
         * Set this to ContentItemSelectionRequest to tell the tool to use
         * content-item; otherwise, omit
         */
        'migration_selection[message_type]'?: string;
        /**
         * The url of the external tool
         */
        'migration_selection[url]'?: string;
        /**
         * The name of the tool
         */
        name: string;
        /**
         * Default: false, if set to true the tool won't show up in the external tool
         * selection UI in modules and assignments
         */
        not_selectable?: boolean;
        /**
         * Default: false, if set to true LTI query params will not be copied to the
         * post body.
         */
        oauth_compliant?: boolean;
        /**
         * What information to send to the external tool.
         */
        privacy_level: 'anonymous' | 'name_only' | 'public';
        /**
         * Set this to enable this feature
         */
        'resource_selection[enabled]'?: boolean;
        /**
         * The url of the icon to show in the module external tool list
         */
        'resource_selection[icon_url]'?: string;
        /**
         * The height of the dialog the tool is launched in
         */
        'resource_selection[selection_height]'?: string;
        /**
         * The width of the dialog the tool is launched in
         */
        'resource_selection[selection_width]'?: string;
        /**
         * The url of the external tool
         */
        'resource_selection[url]'?: string;
        /**
         * The shared secret with the external tool
         */
        shared_secret: string;
        /**
         * The default text to show for this tool
         */
        text?: string;
        /**
         * Set this to enable this feature
         */
        'tool_configuration[enabled]'?: boolean;
        /**
         * Set this to ContentItemSelectionRequest to tell the tool to use
         * content-item; otherwise, omit
         */
        'tool_configuration[message_type]'?: string;
        /**
         * Set this to default the lis_person_contact_email_primary to prefer
         * provisioned sis_email; otherwise, omit
         */
        'tool_configuration[prefer_sis_email]'?: boolean;
        /**
         * The url of the external tool
         */
        'tool_configuration[url]'?: string;
        /**
         * The url to match links against. Either "url" or "domain" should be set,
         * not both.
         */
        url?: string;
        /**
         * Set this to enable this feature
         */
        'user_navigation[enabled]'?: boolean;
        /**
         * The text that will show on the left-tab in the user navigation
         */
        'user_navigation[text]'?: string;
        /**
         * The url of the external tool for user navigation
         */
        'user_navigation[url]'?: string;
        /**
         * Who will see the navigation tab. "admins" for admins, "public" or
         * "members" for everyone
         */
        'user_navigation[visibility]'?: 'admins' | 'members' | 'public';
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/external_tools';
};

export type CreateExternalToolCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSessionlessLaunchUrlForExternalToolCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The external id of the tool to launch.
         */
        id?: string;
        /**
         * The LTI launch url for the external tool.
         */
        url?: string;
        /**
         * The assignment id for an assignment launch. Required if launch_type is set to "assessment".
         */
        assignment_id?: string;
        /**
         * The assignment id for a module item launch. Required if launch_type is set to "module_item".
         */
        module_item_id?: string;
        /**
         * The type of launch to perform on the external tool. Placement names (eg. "course_navigation")
         * can also be specified to use the custom launch url for that placement; if done, the tool id
         * must be provided.
         */
        launch_type?: 'assessment' | 'module_item';
    };
    url: '/v1/courses/{course_id}/external_tools/sessionless_launch';
};

export type GetSessionlessLaunchUrlForExternalToolCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteExternalToolCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        external_tool_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/external_tools/{external_tool_id}';
};

export type DeleteExternalToolCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleExternalToolCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        external_tool_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/external_tools/{external_tool_id}';
};

export type GetSingleExternalToolCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type EditExternalToolCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        external_tool_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/external_tools/{external_tool_id}';
};

export type EditExternalToolCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListFeaturesCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/features';
};

export type ListFeaturesCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<Feature>;
};

export type ListFeaturesCoursesResponse = ListFeaturesCoursesResponses[keyof ListFeaturesCoursesResponses];

export type ListEnabledFeaturesCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/features/enabled';
};

export type ListEnabledFeaturesCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type RemoveFeatureFlagCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        feature: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/features/flags/{feature}';
};

export type RemoveFeatureFlagCoursesResponses = {
    /**
     * No response was specified
     */
    200: FeatureFlag;
};

export type RemoveFeatureFlagCoursesResponse = RemoveFeatureFlagCoursesResponses[keyof RemoveFeatureFlagCoursesResponses];

export type GetFeatureFlagCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        feature: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/features/flags/{feature}';
};

export type GetFeatureFlagCoursesResponses = {
    /**
     * No response was specified
     */
    200: FeatureFlag;
};

export type GetFeatureFlagCoursesResponse = GetFeatureFlagCoursesResponses[keyof GetFeatureFlagCoursesResponses];

export type SetFeatureFlagCoursesData = {
    body?: {
        /**
         * "off":: The feature is not available for the course, user, or account and sub-accounts.
         * "allowed":: (valid only on accounts) The feature is off in the account, but may be enabled in
         * sub-accounts and courses by setting a feature flag on the sub-account or course.
         * "on":: The feature is turned on unconditionally for the user, course, or account and sub-accounts.
         */
        state?: false | 'allowed' | true;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        feature: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/features/flags/{feature}';
};

export type SetFeatureFlagCoursesResponses = {
    /**
     * No response was specified
     */
    200: FeatureFlag;
};

export type SetFeatureFlagCoursesResponse = SetFeatureFlagCoursesResponses[keyof SetFeatureFlagCoursesResponses];

export type ListFilesCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * Filter results by content-type. You can specify type/subtype pairs (e.g.,
         * 'image/jpeg'), or simply types (e.g., 'image', which will match
         * 'image/gif', 'image/jpeg', etc.).
         */
        content_types?: Array<string>;
        /**
         * The partial name of the files to match and return.
         */
        search_term?: string;
        /**
         * Array of additional information to include.
         *
         * "user":: the user who uploaded the file or last edited its content
         * "usage_rights":: copyright and license information for the file (see UsageRights)
         */
        include?: Array<'user'>;
        /**
         * Array of information to restrict to. Overrides include[]
         *
         * "names":: only returns file name information
         */
        only?: Array<Array<{
            [key: string]: unknown;
        }>>;
        /**
         * Sort results by this field. Defaults to 'name'. Note that `sort=user` implies `include[]=user`.
         */
        sort?: 'name' | 'size' | 'created_at' | 'updated_at' | 'content_type' | 'user';
        /**
         * The sorting order. Defaults to 'asc'.
         */
        order?: 'asc' | 'desc';
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/files';
};

export type ListFilesCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<File>;
};

export type ListFilesCoursesResponse = ListFilesCoursesResponses[keyof ListFilesCoursesResponses];

export type GetQuotaInformationCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/files/quota';
};

export type GetQuotaInformationCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetFileCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Array of additional information to include.
         *
         * "user":: the user who uploaded the file or last edited its content
         * "usage_rights":: copyright and license information for the file (see UsageRights)
         */
        include?: Array<'user'>;
    };
    url: '/v1/courses/{course_id}/files/{id}';
};

export type GetFileCoursesResponses = {
    /**
     * No response was specified
     */
    200: File;
};

export type GetFileCoursesResponse = GetFileCoursesResponses[keyof GetFileCoursesResponses];

export type ListAllFoldersCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/folders';
};

export type ListAllFoldersCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<Folder>;
};

export type ListAllFoldersCoursesResponse = ListAllFoldersCoursesResponses[keyof ListAllFoldersCoursesResponses];

export type CreateFolderCoursesData = {
    body: {
        /**
         * Flag the folder as hidden
         */
        hidden?: boolean;
        /**
         * The datetime to lock the folder at
         */
        lock_at?: string;
        /**
         * Flag the folder as locked
         */
        locked?: boolean;
        /**
         * The name of the folder
         */
        name: string;
        /**
         * The id of the folder to store the file in. If this and parent_folder_path are sent an error will be returned. If neither is given, a default folder will be used.
         */
        parent_folder_id?: string;
        /**
         * The path of the folder to store the new folder in. The path separator is the forward slash `/`, never a back slash. The parent folder will be created if it does not already exist. This parameter only applies to new folders in a context that has folders, such as a user, a course, or a group. If this and parent_folder_id are sent an error will be returned. If neither is given, a default folder will be used.
         */
        parent_folder_path?: string;
        /**
         * Set an explicit sort position for the folder
         */
        position?: number;
        /**
         * The datetime to unlock the folder at
         */
        unlock_at?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/folders';
};

export type CreateFolderCoursesResponses = {
    /**
     * No response was specified
     */
    200: Folder;
};

export type CreateFolderCoursesResponse = CreateFolderCoursesResponses[keyof CreateFolderCoursesResponses];

export type ResolvePathCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/folders/by_path';
};

export type ResolvePathCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<Folder>;
};

export type ResolvePathCoursesResponse = ResolvePathCoursesResponses[keyof ResolvePathCoursesResponses];

export type ResolvePathCoursesFullPathData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/folders/by_path/*full_path';
};

export type ResolvePathCoursesFullPathResponses = {
    /**
     * No response was specified
     */
    200: Array<Folder>;
};

export type ResolvePathCoursesFullPathResponse = ResolvePathCoursesFullPathResponses[keyof ResolvePathCoursesFullPathResponses];

export type GetFolderCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/folders/{id}';
};

export type GetFolderCoursesResponses = {
    /**
     * No response was specified
     */
    200: Folder;
};

export type GetFolderCoursesResponse = GetFolderCoursesResponses[keyof GetFolderCoursesResponses];

export type ShowFrontPageCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/front_page';
};

export type ShowFrontPageCoursesResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type ShowFrontPageCoursesResponse = ShowFrontPageCoursesResponses[keyof ShowFrontPageCoursesResponses];

export type UpdateCreateFrontPageCoursesData = {
    body?: {
        /**
         * The content for the new page.
         */
        'wiki_page[body]'?: string;
        /**
         * Which user roles are allowed to edit this page. Any combination
         * of these roles is allowed (separated by commas).
         *
         * "teachers":: Allows editing by teachers in the course.
         * "students":: Allows editing by students in the course.
         * "members":: For group wikis, allows editing by members of the group.
         * "public":: Allows editing by any user.
         */
        'wiki_page[editing_roles]'?: 'teachers' | 'students' | 'members' | 'public';
        /**
         * Whether participants should be notified when this page changes.
         */
        'wiki_page[notify_of_update]'?: boolean;
        /**
         * Whether the page is published (true) or draft state (false).
         */
        'wiki_page[published]'?: boolean;
        /**
         * The title for the new page. NOTE: changing a page's title will change its
         * url. The updated url will be returned in the result.
         */
        'wiki_page[title]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/front_page';
};

export type UpdateCreateFrontPageCoursesResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type UpdateCreateFrontPageCoursesResponse = UpdateCreateFrontPageCoursesResponses[keyof UpdateCreateFrontPageCoursesResponses];

export type DaysInGradebookHistoryForThisCourseData = {
    body?: never;
    path: {
        /**
         * The id of the contextual course for this API call
         */
        course_id: number;
    };
    query?: never;
    url: '/v1/courses/{course_id}/gradebook_history/days';
};

export type DaysInGradebookHistoryForThisCourseResponses = {
    /**
     * No response was specified
     */
    200: Array<Day>;
};

export type DaysInGradebookHistoryForThisCourseResponse = DaysInGradebookHistoryForThisCourseResponses[keyof DaysInGradebookHistoryForThisCourseResponses];

export type ListUncollatedSubmissionVersionsData = {
    body?: never;
    path: {
        /**
         * The id of the contextual course for this API call
         */
        course_id: number;
    };
    query?: {
        /**
         * The ID of the assignment for which you want to see submissions. If
         * absent, versions of submissions from any assignment in the course are
         * included.
         */
        assignment_id?: number;
        /**
         * The ID of the user for which you want to see submissions. If absent,
         * versions of submissions from any user in the course are included.
         */
        user_id?: number;
        /**
         * Returns submission versions in ascending date order (oldest first). If
         * absent, returns submission versions in descending date order (newest
         * first).
         */
        ascending?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/gradebook_history/feed';
};

export type ListUncollatedSubmissionVersionsResponses = {
    /**
     * No response was specified
     */
    200: Array<SubmissionVersion>;
};

export type ListUncollatedSubmissionVersionsResponse = ListUncollatedSubmissionVersionsResponses[keyof ListUncollatedSubmissionVersionsResponses];

export type DetailsForGivenDateInGradebookHistoryForThisCourseData = {
    body?: never;
    path: {
        /**
         * The id of the contextual course for this API call
         */
        course_id: number;
        /**
         * The date for which you would like to see detailed information
         */
        date: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/gradebook_history/{date}';
};

export type DetailsForGivenDateInGradebookHistoryForThisCourseResponses = {
    /**
     * No response was specified
     */
    200: Array<Grader>;
};

export type DetailsForGivenDateInGradebookHistoryForThisCourseResponse = DetailsForGivenDateInGradebookHistoryForThisCourseResponses[keyof DetailsForGivenDateInGradebookHistoryForThisCourseResponses];

export type ListsSubmissionsData = {
    body?: never;
    path: {
        /**
         * The id of the contextual course for this API call
         */
        course_id: number;
        /**
         * The date for which you would like to see submissions
         */
        date: string;
        /**
         * The ID of the grader for which you want to see submissions
         */
        grader_id: number;
        /**
         * The ID of the assignment for which you want to see submissions
         */
        assignment_id: number;
    };
    query?: never;
    url: '/v1/courses/{course_id}/gradebook_history/{date}/graders/{grader_id}/assignments/{assignment_id}/submissions';
};

export type ListsSubmissionsResponses = {
    /**
     * No response was specified
     */
    200: Array<SubmissionHistory>;
};

export type ListsSubmissionsResponse = ListsSubmissionsResponses[keyof ListsSubmissionsResponses];

export type ListGradingPeriodsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/grading_periods';
};

export type ListGradingPeriodsCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<GradingPeriod>;
};

export type ListGradingPeriodsCoursesResponse = ListGradingPeriodsCoursesResponses[keyof ListGradingPeriodsCoursesResponses];

export type DeleteGradingPeriodCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/grading_periods/{id}';
};

export type DeleteGradingPeriodCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleGradingPeriodData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/grading_periods/{id}';
};

export type GetSingleGradingPeriodResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateSingleGradingPeriodData = {
    body: {
        /**
         * no description
         */
        'grading_periods[end_date]': Array<string>;
        /**
         * The date the grading period starts.
         */
        'grading_periods[start_date]': Array<string>;
        /**
         * A weight value that contributes to the overall weight of a grading period set which is used to calculate how much assignments in this period contribute to the total grade
         */
        'grading_periods[weight]'?: Array<number>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/grading_periods/{id}';
};

export type UpdateSingleGradingPeriodResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListGradingStandardsAvailableInContextCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/grading_standards';
};

export type ListGradingStandardsAvailableInContextCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<GradingStandard>;
};

export type ListGradingStandardsAvailableInContextCoursesResponse = ListGradingStandardsAvailableInContextCoursesResponses[keyof ListGradingStandardsAvailableInContextCoursesResponses];

export type CreateNewGradingStandardCoursesData = {
    body: {
        /**
         * The name for an entry value within a GradingStandard that describes the range of the value
         * e.g. A-
         */
        'grading_scheme_entry[name]': Array<string>;
        /**
         * The value for the name of the entry within a GradingStandard.
         * The entry represents the lower bound of the range for the entry.
         * This range includes the value up to the next entry in the GradingStandard,
         * or 100 if there is no upper bound. The lowest value will have a lower bound range of 0.
         * e.g. 93
         */
        'grading_scheme_entry[value]': Array<number>;
        /**
         * The title for the Grading Standard.
         */
        title: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/grading_standards';
};

export type CreateNewGradingStandardCoursesResponses = {
    /**
     * No response was specified
     */
    200: GradingStandard;
};

export type CreateNewGradingStandardCoursesResponse = CreateNewGradingStandardCoursesResponses[keyof CreateNewGradingStandardCoursesResponses];

export type GetSingleGradingStandardInContextCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        grading_standard_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/grading_standards/{grading_standard_id}';
};

export type GetSingleGradingStandardInContextCoursesResponses = {
    /**
     * No response was specified
     */
    200: GradingStandard;
};

export type GetSingleGradingStandardInContextCoursesResponse = GetSingleGradingStandardInContextCoursesResponses[keyof GetSingleGradingStandardInContextCoursesResponses];

export type ListGroupCategoriesForContextCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/group_categories';
};

export type ListGroupCategoriesForContextCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<GroupCategory>;
};

export type ListGroupCategoriesForContextCoursesResponse = ListGroupCategoriesForContextCoursesResponses[keyof ListGroupCategoriesForContextCoursesResponses];

export type CreateGroupCategoryCoursesData = {
    body: {
        /**
         * Assigns group leaders automatically when generating and allocating students to groups
         * Valid values are:
         * "first":: the first student to be allocated to a group is the leader
         * "random":: a random student from all members is chosen as the leader
         */
        auto_leader?: 'first' | 'random';
        /**
         * Create this number of groups (Course Only).
         */
        create_group_count?: number;
        /**
         * Limit the maximum number of users in each group (Course Only). Requires
         * self signup.
         */
        group_limit?: number;
        /**
         * Name of the group category
         */
        name: string;
        /**
         * Allow students to sign up for a group themselves (Course Only).
         * valid values are:
         * "enabled":: allows students to self sign up for any group in course
         * "restricted":: allows students to self sign up only for groups in the
         * same section null disallows self sign up
         */
        self_signup?: 'enabled' | 'restricted';
        /**
         * The unique SIS identifier.
         */
        sis_group_category_id?: string;
        /**
         * (Deprecated)
         * Create this number of groups, and evenly distribute students
         * among them. not allowed with "enable_self_signup". because
         * the group assignment happens synchronously, it's recommended
         * that you instead use the assign_unassigned_members endpoint.
         * (Course Only)
         */
        split_group_count?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/group_categories';
};

export type CreateGroupCategoryCoursesResponses = {
    /**
     * No response was specified
     */
    200: GroupCategory;
};

export type CreateGroupCategoryCoursesResponse = CreateGroupCategoryCoursesResponses[keyof CreateGroupCategoryCoursesResponses];

export type ListGroupsAvailableInContextCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * Will only include groups that the user belongs to if this is set
         */
        only_own_groups?: boolean;
        /**
         * - "tabs": Include the list of tabs configured for each group.  See the
         * {api:TabsController#index List available tabs API} for more information.
         */
        include?: Array<'tabs'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/groups';
};

export type ListGroupsAvailableInContextCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<Group>;
};

export type ListGroupsAvailableInContextCoursesResponse = ListGroupsAvailableInContextCoursesResponses[keyof ListGroupsAvailableInContextCoursesResponses];

export type ListLiveAssessmentsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/live_assessments';
};

export type ListLiveAssessmentsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateOrFindLiveAssessmentData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/live_assessments';
};

export type CreateOrFindLiveAssessmentResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListLiveAssessmentResultsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assessment_id: string;
    };
    query?: {
        /**
         * If set, restrict results to those for this user
         */
        user_id?: number;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/live_assessments/{assessment_id}/results';
};

export type ListLiveAssessmentResultsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateLiveAssessmentResultsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        assessment_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/live_assessments/{assessment_id}/results';
};

export type CreateLiveAssessmentResultsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetModuleItemSequenceData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The type of asset to find module sequence information for. Use the ModuleItem if it is known
         * (e.g., the user navigated from a module item), since this will avoid ambiguity if the asset
         * appears more than once in the module sequence.
         */
        asset_type?: 'ModuleItem' | 'File' | 'Page' | 'Discussion' | 'Assignment' | 'Quiz' | 'ExternalTool';
        /**
         * The id of the asset (or the url in the case of a Page)
         */
        asset_id?: number;
    };
    url: '/v1/courses/{course_id}/module_item_sequence';
};

export type GetModuleItemSequenceResponses = {
    /**
     * No response was specified
     */
    200: ModuleItemSequence;
};

export type GetModuleItemSequenceResponse = GetModuleItemSequenceResponses[keyof GetModuleItemSequenceResponses];

export type ListModulesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * - "items": Return module items inline if possible.
         * This parameter suggests that Canvas return module items directly
         * in the Module object JSON, to avoid having to make separate API
         * requests for each module when enumerating modules and items. Canvas
         * is free to omit 'items' for any particular module if it deems them
         * too numerous to return inline. Callers must be prepared to use the
         * {api:ContextModuleItemsApiController#index List Module Items API}
         * if items are not returned.
         * - "content_details": Requires include['items']. Returns additional
         * details with module items specific to their associated content items.
         * Includes standard lock information for each item.
         */
        include?: Array<'items' | 'content_details'>;
        /**
         * The partial name of the modules (and module items, if include['items'] is
         * specified) to match and return.
         */
        search_term?: string;
        /**
         * Returns module completion information for the student with this id.
         */
        student_id?: string;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/modules';
};

export type ListModulesResponses = {
    /**
     * No response was specified
     */
    200: Array<Module>;
};

export type ListModulesResponse = ListModulesResponses[keyof ListModulesResponses];

export type CreateModuleData = {
    body: {
        /**
         * The name of the module
         */
        'module[name]': string;
        /**
         * The position of this module in the course (1-based)
         */
        'module[position]'?: number;
        /**
         * IDs of Modules that must be completed before this one is unlocked.
         * Prerequisite modules must precede this module (i.e. have a lower position
         * value), otherwise they will be ignored
         */
        'module[prerequisite_module_ids]'?: Array<string>;
        /**
         * Whether to publish the student's final grade for the course upon
         * completion of this module.
         */
        'module[publish_final_grade]'?: boolean;
        /**
         * Whether module items must be unlocked in order
         */
        'module[require_sequential_progress]'?: boolean;
        /**
         * The date the module will unlock
         */
        'module[unlock_at]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/modules';
};

export type CreateModuleResponses = {
    /**
     * No response was specified
     */
    200: Module;
};

export type CreateModuleResponse = CreateModuleResponses[keyof CreateModuleResponses];

export type DeleteModuleData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/modules/{id}';
};

export type DeleteModuleResponses = {
    /**
     * No response was specified
     */
    200: Module;
};

export type DeleteModuleResponse = DeleteModuleResponses[keyof DeleteModuleResponses];

export type ShowModuleData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * - "items": Return module items inline if possible.
         * This parameter suggests that Canvas return module items directly
         * in the Module object JSON, to avoid having to make separate API
         * requests for each module when enumerating modules and items. Canvas
         * is free to omit 'items' for any particular module if it deems them
         * too numerous to return inline. Callers must be prepared to use the
         * {api:ContextModuleItemsApiController#index List Module Items API}
         * if items are not returned.
         * - "content_details": Requires include['items']. Returns additional
         * details with module items specific to their associated content items.
         * Includes standard lock information for each item.
         */
        include?: Array<'items' | 'content_details'>;
        /**
         * Returns module completion information for the student with this id.
         */
        student_id?: string;
    };
    url: '/v1/courses/{course_id}/modules/{id}';
};

export type ShowModuleResponses = {
    /**
     * No response was specified
     */
    200: Module;
};

export type ShowModuleResponse = ShowModuleResponses[keyof ShowModuleResponses];

export type UpdateModuleData = {
    body?: {
        /**
         * The name of the module
         */
        'module[name]'?: string;
        /**
         * The position of the module in the course (1-based)
         */
        'module[position]'?: number;
        /**
         * IDs of Modules that must be completed before this one is unlocked
         * Prerequisite modules must precede this module (i.e. have a lower position
         * value), otherwise they will be ignored
         */
        'module[prerequisite_module_ids]'?: Array<string>;
        /**
         * Whether to publish the student's final grade for the course upon
         * completion of this module.
         */
        'module[publish_final_grade]'?: boolean;
        /**
         * Whether the module is published and visible to students
         */
        'module[published]'?: boolean;
        /**
         * Whether module items must be unlocked in order
         */
        'module[require_sequential_progress]'?: boolean;
        /**
         * The date the module will unlock
         */
        'module[unlock_at]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/modules/{id}';
};

export type UpdateModuleResponses = {
    /**
     * No response was specified
     */
    200: Module;
};

export type UpdateModuleResponse = UpdateModuleResponses[keyof UpdateModuleResponses];

export type ReLockModuleProgressionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/modules/{id}/relock';
};

export type ReLockModuleProgressionsResponses = {
    /**
     * No response was specified
     */
    200: Module;
};

export type ReLockModuleProgressionsResponse = ReLockModuleProgressionsResponses[keyof ReLockModuleProgressionsResponses];

export type ListModuleItemsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        module_id: string;
    };
    query?: {
        /**
         * If included, will return additional details specific to the content
         * associated with each item. Refer to the {api:Modules:Module%20Item Module
         * Item specification} for more details.
         * Includes standard lock information for each item.
         */
        include?: Array<'content_details'>;
        /**
         * The partial title of the items to match and return.
         */
        search_term?: string;
        /**
         * Returns module completion information for the student with this id.
         */
        student_id?: string;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/modules/{module_id}/items';
};

export type ListModuleItemsResponses = {
    /**
     * No response was specified
     */
    200: Array<ModuleItem>;
};

export type ListModuleItemsResponse = ListModuleItemsResponses[keyof ListModuleItemsResponses];

export type CreateModuleItemData = {
    body: {
        /**
         * Minimum score required to complete. Required for completion_requirement
         * type 'min_score'.
         */
        'module_item[completion_requirement][min_score]'?: number;
        /**
         * Completion requirement for this module item.
         * "must_view": Applies to all item types
         * "must_contribute": Only applies to "Assignment", "Discussion", and "Page" types
         * "must_submit", "min_score": Only apply to "Assignment" and "Quiz" types
         * Inapplicable types will be ignored
         */
        'module_item[completion_requirement][type]'?: 'must_view' | 'must_contribute' | 'must_submit';
        /**
         * The id of the content to link to the module item. Required, except for
         * 'ExternalUrl', 'Page', and 'SubHeader' types.
         */
        'module_item[content_id]': string;
        /**
         * External url that the item points to. [Required for 'ExternalUrl' and
         * 'ExternalTool' types.
         */
        'module_item[external_url]'?: string;
        /**
         * 0-based indent level; module items may be indented to show a hierarchy
         */
        'module_item[indent]'?: number;
        /**
         * Whether the external tool opens in a new tab. Only applies to
         * 'ExternalTool' type.
         */
        'module_item[new_tab]'?: boolean;
        /**
         * Suffix for the linked wiki page (e.g. 'front-page'). Required for 'Page'
         * type.
         */
        'module_item[page_url]'?: string;
        /**
         * The position of this item in the module (1-based).
         */
        'module_item[position]'?: number;
        /**
         * The name of the module item and associated content
         */
        'module_item[title]'?: string;
        /**
         * The type of content linked to the item
         */
        'module_item[type]': 'File' | 'Page' | 'Discussion' | 'Assignment' | 'Quiz' | 'SubHeader' | 'ExternalUrl' | 'ExternalTool';
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        module_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/modules/{module_id}/items';
};

export type CreateModuleItemResponses = {
    /**
     * No response was specified
     */
    200: ModuleItem;
};

export type CreateModuleItemResponse = CreateModuleItemResponses[keyof CreateModuleItemResponses];

export type DeleteModuleItemData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        module_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/modules/{module_id}/items/{id}';
};

export type DeleteModuleItemResponses = {
    /**
     * No response was specified
     */
    200: ModuleItem;
};

export type DeleteModuleItemResponse = DeleteModuleItemResponses[keyof DeleteModuleItemResponses];

export type ShowModuleItemData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        module_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * If included, will return additional details specific to the content
         * associated with this item. Refer to the {api:Modules:Module%20Item Module
         * Item specification} for more details.
         * Includes standard lock information for each item.
         */
        include?: Array<'content_details'>;
        /**
         * Returns module completion information for the student with this id.
         */
        student_id?: string;
    };
    url: '/v1/courses/{course_id}/modules/{module_id}/items/{id}';
};

export type ShowModuleItemResponses = {
    /**
     * No response was specified
     */
    200: ModuleItem;
};

export type ShowModuleItemResponse = ShowModuleItemResponses[keyof ShowModuleItemResponses];

export type UpdateModuleItemData = {
    body?: {
        /**
         * Minimum score required to complete, Required for completion_requirement
         * type 'min_score'.
         */
        'module_item[completion_requirement][min_score]'?: number;
        /**
         * Completion requirement for this module item.
         * "must_view": Applies to all item types
         * "must_contribute": Only applies to "Assignment", "Discussion", and "Page" types
         * "must_submit", "min_score": Only apply to "Assignment" and "Quiz" types
         * Inapplicable types will be ignored
         */
        'module_item[completion_requirement][type]'?: 'must_view' | 'must_contribute' | 'must_submit';
        /**
         * External url that the item points to. Only applies to 'ExternalUrl' type.
         */
        'module_item[external_url]'?: string;
        /**
         * 0-based indent level; module items may be indented to show a hierarchy
         */
        'module_item[indent]'?: number;
        /**
         * Move this item to another module by specifying the target module id here.
         * The target module must be in the same course.
         */
        'module_item[module_id]'?: string;
        /**
         * Whether the external tool opens in a new tab. Only applies to
         * 'ExternalTool' type.
         */
        'module_item[new_tab]'?: boolean;
        /**
         * The position of this item in the module (1-based)
         */
        'module_item[position]'?: number;
        /**
         * Whether the module item is published and visible to students.
         */
        'module_item[published]'?: boolean;
        /**
         * The name of the module item
         */
        'module_item[title]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        module_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/modules/{module_id}/items/{id}';
};

export type UpdateModuleItemResponses = {
    /**
     * No response was specified
     */
    200: ModuleItem;
};

export type UpdateModuleItemResponse = UpdateModuleItemResponses[keyof UpdateModuleItemResponses];

export type MarkModuleItemAsDoneNotDoneData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        module_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/modules/{module_id}/items/{id}/done';
};

export type MarkModuleItemAsDoneNotDoneResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkModuleItemReadData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        module_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/modules/{module_id}/items/{id}/mark_read';
};

export type MarkModuleItemReadResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type SelectMasteryPathData = {
    body?: {
        /**
         * Assignment set chosen, as specified in the mastery_paths portion of the
         * context module item response
         */
        assignment_set_id?: string;
        /**
         * Which student the selection applies to.  If not specified, current user is
         * implied.
         */
        student_id?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        module_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/modules/{module_id}/items/{id}/select_mastery_path';
};

export type SelectMasteryPathResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetAlignedAssignmentsForOutcomeInCourseForParticularStudentData = {
    body?: never;
    path: {
        /**
         * The id of the course
         */
        course_id: number;
    };
    query?: {
        /**
         * The id of the student
         */
        student_id?: number;
    };
    url: '/v1/courses/{course_id}/outcome_alignments';
};

export type GetAlignedAssignmentsForOutcomeInCourseForParticularStudentResponses = {
    /**
     * No response was specified
     */
    200: Array<OutcomeAlignment>;
};

export type GetAlignedAssignmentsForOutcomeInCourseForParticularStudentResponse = GetAlignedAssignmentsForOutcomeInCourseForParticularStudentResponses[keyof GetAlignedAssignmentsForOutcomeInCourseForParticularStudentResponses];

export type GetAllOutcomeLinksForContextCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The detail level of the outcomes. Defaults to "abbrev".
         * Specify "full" for more information.
         */
        outcome_style?: string;
        /**
         * The detail level of the outcome groups. Defaults to "abbrev".
         * Specify "full" for more information.
         */
        outcome_group_style?: string;
    };
    url: '/v1/courses/{course_id}/outcome_group_links';
};

export type GetAllOutcomeLinksForContextCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<OutcomeLink>;
};

export type GetAllOutcomeLinksForContextCoursesResponse = GetAllOutcomeLinksForContextCoursesResponses[keyof GetAllOutcomeLinksForContextCoursesResponses];

export type GetAllOutcomeGroupsForContextCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/outcome_groups';
};

export type GetAllOutcomeGroupsForContextCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<OutcomeGroup>;
};

export type GetAllOutcomeGroupsForContextCoursesResponse = GetAllOutcomeGroupsForContextCoursesResponses[keyof GetAllOutcomeGroupsForContextCoursesResponses];

export type DeleteOutcomeGroupCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/outcome_groups/{id}';
};

export type DeleteOutcomeGroupCoursesResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type DeleteOutcomeGroupCoursesResponse = DeleteOutcomeGroupCoursesResponses[keyof DeleteOutcomeGroupCoursesResponses];

export type ShowOutcomeGroupCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/outcome_groups/{id}';
};

export type ShowOutcomeGroupCoursesResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type ShowOutcomeGroupCoursesResponse = ShowOutcomeGroupCoursesResponses[keyof ShowOutcomeGroupCoursesResponses];

export type UpdateOutcomeGroupCoursesData = {
    body?: {
        /**
         * The new outcome group description.
         */
        description?: string;
        /**
         * The id of the new parent outcome group.
         */
        parent_outcome_group_id?: number;
        /**
         * The new outcome group title.
         */
        title?: string;
        /**
         * A custom GUID for the learning standard.
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/outcome_groups/{id}';
};

export type UpdateOutcomeGroupCoursesResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type UpdateOutcomeGroupCoursesResponse = UpdateOutcomeGroupCoursesResponses[keyof UpdateOutcomeGroupCoursesResponses];

export type ImportOutcomeGroupCoursesData = {
    body: {
        /**
         * If true, perform action asynchronously.  In that case, this endpoint
         * will return a Progress object instead of an OutcomeGroup.
         * Use the {api:ProgressController#show progress endpoint}
         * to query the status of the operation.  The imported outcome group id
         * and url will be returned in the results of the Progress object
         * as "outcome_group_id" and "outcome_group_url"
         */
        async?: boolean;
        /**
         * The ID of the source outcome group.
         */
        source_outcome_group_id: number;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/outcome_groups/{id}/import';
};

export type ImportOutcomeGroupCoursesResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type ImportOutcomeGroupCoursesResponse = ImportOutcomeGroupCoursesResponses[keyof ImportOutcomeGroupCoursesResponses];

export type ListLinkedOutcomesCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * The detail level of the outcomes. Defaults to "abbrev".
         * Specify "full" for more information.
         */
        outcome_style?: string;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/outcome_groups/{id}/outcomes';
};

export type ListLinkedOutcomesCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<OutcomeLink>;
};

export type ListLinkedOutcomesCoursesResponse = ListLinkedOutcomesCoursesResponses[keyof ListLinkedOutcomesCoursesResponses];

export type CreateLinkOutcomeCoursesData = {
    body?: {
        /**
         * The new calculation int.  Only applies if the calculation_method is "decaying_average" or "n_mastery"
         */
        calculation_int?: number;
        /**
         * The new calculation method.  Defaults to "highest"
         */
        calculation_method?: 'decaying_average' | 'n_mastery' | 'latest' | 'highest';
        /**
         * The description of the new outcome.
         */
        description?: string;
        /**
         * A friendly name shown in reports for outcomes with cryptic titles,
         * such as common core standards names.
         */
        display_name?: string;
        /**
         * The mastery threshold for the embedded rubric criterion.
         */
        mastery_points?: number;
        /**
         * The ID of the old outcome group. Only used if outcome_id is present.
         */
        move_from?: number;
        /**
         * The ID of the existing outcome to link.
         */
        outcome_id?: number;
        /**
         * The description of a rating level for the embedded rubric criterion.
         */
        'ratings[description]'?: Array<string>;
        /**
         * The points corresponding to a rating level for the embedded rubric criterion.
         */
        'ratings[points]'?: Array<number>;
        /**
         * The title of the new outcome. Required if outcome_id is absent.
         */
        title?: string;
        /**
         * A custom GUID for the learning standard.
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/outcome_groups/{id}/outcomes';
};

export type CreateLinkOutcomeCoursesResponses = {
    /**
     * No response was specified
     */
    200: OutcomeLink;
};

export type CreateLinkOutcomeCoursesResponse = CreateLinkOutcomeCoursesResponses[keyof CreateLinkOutcomeCoursesResponses];

export type UnlinkOutcomeCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
        /**
         * ID
         */
        outcome_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/outcome_groups/{id}/outcomes/{outcome_id}';
};

export type UnlinkOutcomeCoursesResponses = {
    /**
     * No response was specified
     */
    200: OutcomeLink;
};

export type UnlinkOutcomeCoursesResponse = UnlinkOutcomeCoursesResponses[keyof UnlinkOutcomeCoursesResponses];

export type CreateLinkOutcomeCoursesOutcomeIdData = {
    body?: {
        /**
         * The new calculation int.  Only applies if the calculation_method is "decaying_average" or "n_mastery"
         */
        calculation_int?: number;
        /**
         * The new calculation method.  Defaults to "highest"
         */
        calculation_method?: 'decaying_average' | 'n_mastery' | 'latest' | 'highest';
        /**
         * The description of the new outcome.
         */
        description?: string;
        /**
         * A friendly name shown in reports for outcomes with cryptic titles,
         * such as common core standards names.
         */
        display_name?: string;
        /**
         * The mastery threshold for the embedded rubric criterion.
         */
        mastery_points?: number;
        /**
         * The ID of the old outcome group. Only used if outcome_id is present.
         */
        move_from?: number;
        /**
         * The description of a rating level for the embedded rubric criterion.
         */
        'ratings[description]'?: Array<string>;
        /**
         * The points corresponding to a rating level for the embedded rubric criterion.
         */
        'ratings[points]'?: Array<number>;
        /**
         * The title of the new outcome. Required if outcome_id is absent.
         */
        title?: string;
        /**
         * A custom GUID for the learning standard.
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
        /**
         * The ID of the existing outcome to link.
         */
        outcome_id: number;
    };
    query?: never;
    url: '/v1/courses/{course_id}/outcome_groups/{id}/outcomes/{outcome_id}';
};

export type CreateLinkOutcomeCoursesOutcomeIdResponses = {
    /**
     * No response was specified
     */
    200: OutcomeLink;
};

export type CreateLinkOutcomeCoursesOutcomeIdResponse = CreateLinkOutcomeCoursesOutcomeIdResponses[keyof CreateLinkOutcomeCoursesOutcomeIdResponses];

export type ListSubgroupsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/outcome_groups/{id}/subgroups';
};

export type ListSubgroupsCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<OutcomeGroup>;
};

export type ListSubgroupsCoursesResponse = ListSubgroupsCoursesResponses[keyof ListSubgroupsCoursesResponses];

export type CreateSubgroupCoursesData = {
    body: {
        /**
         * The description of the new outcome group.
         */
        description?: string;
        /**
         * The title of the new outcome group.
         */
        title: string;
        /**
         * A custom GUID for the learning standard
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/outcome_groups/{id}/subgroups';
};

export type CreateSubgroupCoursesResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type CreateSubgroupCoursesResponse = CreateSubgroupCoursesResponses[keyof CreateSubgroupCoursesResponses];

export type ImportOutcomesCoursesData = {
    body?: {
        /**
         * There are two ways to post outcome import data - either via a
         * application/x-www-form-urlencoded form-field-style attachment, or via a non-multipart
         * raw post request.
         *
         * 'attachment' is required for application/x-www-form-urlencoded style posts. Assumed to
         * be outcome data from a file upload form field named 'attachment'.
         *
         * Examples:
         * curl -F attachment=@<filename> -H "Authorization: Bearer <token>" \
         * 'https://<canvas>/api/v1/accounts/<account_id>/outcome_imports?import_type=instructure_csv'
         * curl -F attachment=@<filename> -H "Authorization: Bearer <token>" \
         * 'https://<canvas>/api/v1/courses/<course_id>/outcome_imports?import_type=instructure_csv'
         *
         * If you decide to do a raw post, you can skip the 'attachment' argument,
         * but you will then be required to provide a suitable Content-Type header.
         * You are encouraged to also provide the 'extension' argument.
         *
         * Examples:
         * curl -H 'Content-Type: text/csv' --data-binary @<filename>.csv \
         * -H "Authorization: Bearer <token>" \
         * 'https://<canvas>/api/v1/accounts/<account_id>/outcome_imports?import_type=instructure_csv'
         *
         * curl -H 'Content-Type: text/csv' --data-binary @<filename>.csv \
         * -H "Authorization: Bearer <token>" \
         * 'https://<canvas>/api/v1/courses/<course_id>/outcome_imports?import_type=instructure_csv'
         */
        attachment?: string;
        /**
         * Recommended for raw post request style imports. This field will be used to
         * distinguish between csv and other file format extensions that
         * would usually be provided with the filename in the multipart post request
         * scenario. If not provided, this value will be inferred from the
         * Content-Type, falling back to csv-file format if all else fails.
         */
        extension?: string;
        /**
         * Choose the data format for reading outcome data. With a standard Canvas
         * install, this option can only be 'instructure_csv', and if unprovided,
         * will be assumed to be so. Can be part of the query string.
         */
        import_type?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/outcome_imports';
};

export type ImportOutcomesCoursesResponses = {
    /**
     * No response was specified
     */
    200: OutcomeImport;
};

export type ImportOutcomesCoursesResponse = ImportOutcomesCoursesResponses[keyof ImportOutcomesCoursesResponses];

export type GetOutcomeImportStatusCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/outcome_imports/{id}';
};

export type GetOutcomeImportStatusCoursesResponses = {
    /**
     * No response was specified
     */
    200: OutcomeImport;
};

export type GetOutcomeImportStatusCoursesResponse = GetOutcomeImportStatusCoursesResponses[keyof GetOutcomeImportStatusCoursesResponses];

export type GetOutcomeResultsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * If specified, only the users whose ids are given will be included in the
         * results. SIS ids can be used, prefixed by "sis_user_id:".
         * It is an error to specify an id for a user who is not a student in
         * the context.
         */
        user_ids?: Array<number>;
        /**
         * If specified, only the outcomes whose ids are given will be included in the
         * results. it is an error to specify an id for an outcome which is not linked
         * to the context.
         */
        outcome_ids?: Array<number>;
        /**
         * [String, "alignments"|"outcomes"|"outcomes.alignments"|"outcome_groups"|"outcome_links"|"outcome_paths"|"users"]
         * Specify additional collections to be side loaded with the result.
         * "alignments" includes only the alignments referenced by the returned
         * results.
         * "outcomes.alignments" includes all alignments referenced by outcomes in the
         * context.
         */
        include?: Array<string>;
        /**
         * If true, results that are hidden from the learning mastery gradebook and student rollup
         * scores will be included
         */
        include_hidden?: boolean;
    };
    url: '/v1/courses/{course_id}/outcome_results';
};

export type GetOutcomeResultsResponses = {
    /**
     * Assessment Outcome Results and optional info (enabled via "include" parameter)
     */
    200: OutcomeResultResponse;
};

export type GetOutcomeResultsResponse = GetOutcomeResultsResponses[keyof GetOutcomeResultsResponses];

export type GetOutcomeResultRollupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * If specified, instead of returning one rollup for each user, all the user
         * rollups will be combined into one rollup for the course that will contain
         * the average (or median, see below) rollup score for each outcome.
         */
        aggregate?: 'course';
        /**
         * If aggregate rollups requested, then this value determines what
         * statistic is used for the aggregate. Defaults to "mean" if this value
         * is not specified.
         */
        aggregate_stat?: 'mean' | 'median';
        /**
         * If specified, only the users whose ids are given will be included in the
         * results or used in an aggregate result. it is an error to specify an id
         * for a user who is not a student in the context
         */
        user_ids?: Array<number>;
        /**
         * If specified, only the outcomes whose ids are given will be included in the
         * results. it is an error to specify an id for an outcome which is not linked
         * to the context.
         */
        outcome_ids?: Array<number>;
        /**
         * [String, "courses"|"outcomes"|"outcomes.alignments"|"outcome_groups"|"outcome_links"|"outcome_paths"|"users"]
         * Specify additional collections to be side loaded with the result.
         */
        include?: Array<string>;
        /**
         * Specify additional values to exclude. "missing_user_rollups" excludes
         * rollups for users without results.
         */
        exclude?: Array<'missing_user_rollups'>;
        /**
         * If specified, sorts outcome result rollups. "student" sorting will sort
         * by a user's sortable name. "outcome" sorting will sort by the given outcome's
         * rollup score. The latter requires specifying the "sort_outcome_id" parameter.
         * By default, the sort order is ascending.
         */
        sort_by?: 'student' | 'outcome';
        /**
         * If outcome sorting requested, then this determines which outcome to use
         * for rollup score sorting.
         */
        sort_outcome_id?: number;
        /**
         * If sorting requested, then this allows changing the default sort order of
         * ascending to descending.
         */
        sort_order?: 'asc' | 'desc';
    };
    url: '/v1/courses/{course_id}/outcome_rollups';
};

export type GetOutcomeResultRollupsResponses = {
    /**
     * Assessment Outcome Rollup Results and optional info (enabled via the "include" parameter)
     */
    200: OutcomeRollupResponse;
};

export type GetOutcomeResultRollupsResponse = GetOutcomeResultRollupsResponses[keyof GetOutcomeResultRollupsResponses];

export type ListPagesCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * Sort results by this field.
         */
        sort?: 'title' | 'created_at' | 'updated_at';
        /**
         * The sorting order. Defaults to 'asc'.
         */
        order?: 'asc' | 'desc';
        /**
         * The partial title of the pages to match and return.
         */
        search_term?: string;
        /**
         * If true, include only published paqes. If false, exclude published
         * pages. If not present, do not filter on published status.
         */
        published?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/pages';
};

export type ListPagesCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<Page>;
};

export type ListPagesCoursesResponse = ListPagesCoursesResponses[keyof ListPagesCoursesResponses];

export type CreatePageCoursesData = {
    body: {
        /**
         * The content for the new page.
         */
        'wiki_page[body]'?: string;
        /**
         * Which user roles are allowed to edit this page. Any combination
         * of these roles is allowed (separated by commas).
         *
         * "teachers":: Allows editing by teachers in the course.
         * "students":: Allows editing by students in the course.
         * "members":: For group wikis, allows editing by members of the group.
         * "public":: Allows editing by any user.
         */
        'wiki_page[editing_roles]'?: 'teachers' | 'students' | 'members' | 'public';
        /**
         * Set an unhidden page as the front page (if true)
         */
        'wiki_page[front_page]'?: boolean;
        /**
         * Whether participants should be notified when this page changes.
         */
        'wiki_page[notify_of_update]'?: boolean;
        /**
         * Whether the page is published (true) or draft state (false).
         */
        'wiki_page[published]'?: boolean;
        /**
         * The title for the new page.
         */
        'wiki_page[title]': string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/pages';
};

export type CreatePageCoursesResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type CreatePageCoursesResponse = CreatePageCoursesResponses[keyof CreatePageCoursesResponses];

export type DeletePageCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        url: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/pages/{url}';
};

export type DeletePageCoursesResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type DeletePageCoursesResponse = DeletePageCoursesResponses[keyof DeletePageCoursesResponses];

export type ShowPageCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        url: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/pages/{url}';
};

export type ShowPageCoursesResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type ShowPageCoursesResponse = ShowPageCoursesResponses[keyof ShowPageCoursesResponses];

export type UpdateCreatePageCoursesData = {
    body?: {
        /**
         * The content for the new page.
         */
        'wiki_page[body]'?: string;
        /**
         * Which user roles are allowed to edit this page. Any combination
         * of these roles is allowed (separated by commas).
         *
         * "teachers":: Allows editing by teachers in the course.
         * "students":: Allows editing by students in the course.
         * "members":: For group wikis, allows editing by members of the group.
         * "public":: Allows editing by any user.
         */
        'wiki_page[editing_roles]'?: 'teachers' | 'students' | 'members' | 'public';
        /**
         * Set an unhidden page as the front page (if true)
         */
        'wiki_page[front_page]'?: boolean;
        /**
         * Whether participants should be notified when this page changes.
         */
        'wiki_page[notify_of_update]'?: boolean;
        /**
         * Whether the page is published (true) or draft state (false).
         */
        'wiki_page[published]'?: boolean;
        /**
         * The title for the new page. NOTE: changing a page's title will change its
         * url. The updated url will be returned in the result.
         */
        'wiki_page[title]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        url: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/pages/{url}';
};

export type UpdateCreatePageCoursesResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type UpdateCreatePageCoursesResponse = UpdateCreatePageCoursesResponses[keyof UpdateCreatePageCoursesResponses];

export type DuplicatePageData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        url: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/pages/{url}/duplicate';
};

export type DuplicatePageResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type DuplicatePageResponse = DuplicatePageResponses[keyof DuplicatePageResponses];

export type ListRevisionsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        url: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/pages/{url}/revisions';
};

export type ListRevisionsCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<PageRevision>;
};

export type ListRevisionsCoursesResponse = ListRevisionsCoursesResponses[keyof ListRevisionsCoursesResponses];

export type ShowRevisionCoursesLatestData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        url: string;
    };
    query?: {
        /**
         * If set, exclude page content from results
         */
        summary?: boolean;
    };
    url: '/v1/courses/{course_id}/pages/{url}/revisions/latest';
};

export type ShowRevisionCoursesLatestResponses = {
    /**
     * No response was specified
     */
    200: PageRevision;
};

export type ShowRevisionCoursesLatestResponse = ShowRevisionCoursesLatestResponses[keyof ShowRevisionCoursesLatestResponses];

export type ShowRevisionCoursesRevisionIdData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        url: string;
        /**
         * ID
         */
        revision_id: string;
    };
    query?: {
        /**
         * If set, exclude page content from results
         */
        summary?: boolean;
    };
    url: '/v1/courses/{course_id}/pages/{url}/revisions/{revision_id}';
};

export type ShowRevisionCoursesRevisionIdResponses = {
    /**
     * No response was specified
     */
    200: PageRevision;
};

export type ShowRevisionCoursesRevisionIdResponse = ShowRevisionCoursesRevisionIdResponses[keyof ShowRevisionCoursesRevisionIdResponses];

export type RevertToRevisionCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        url: string;
        /**
         * The revision to revert to (use the
         * {api:WikiPagesApiController#revisions List Revisions API} to see
         * available revisions)
         */
        revision_id: number;
    };
    query?: never;
    url: '/v1/courses/{course_id}/pages/{url}/revisions/{revision_id}';
};

export type RevertToRevisionCoursesResponses = {
    /**
     * No response was specified
     */
    200: PageRevision;
};

export type RevertToRevisionCoursesResponse = RevertToRevisionCoursesResponses[keyof RevertToRevisionCoursesResponses];

export type CoursePermissionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * List of permissions to check against the authenticated user.
         * Permission names are documented in the {api:RoleOverridesController#add_role Create a role} endpoint.
         */
        permissions?: Array<string>;
    };
    url: '/v1/courses/{course_id}/permissions';
};

export type CoursePermissionResponses = {
    /**
     * No response was specified
     */
    200: Array<Permission>;
};

export type CoursePermissionResponse = CoursePermissionResponses[keyof CoursePermissionResponses];

export type ListPotentialMembersCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/potential_collaborators';
};

export type ListPotentialMembersCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type ListPotentialMembersCoursesResponse = ListPotentialMembersCoursesResponses[keyof ListPotentialMembersCoursesResponses];

export type PreviewProcessedHtmlCourseData = {
    body?: {
        /**
         * The html content to process
         */
        html?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/preview_html';
};

export type PreviewProcessedHtmlCourseResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type SetExtensionsForStudentQuizSubmissionsData = {
    body: {
        /**
         * The number of minutes to extend the quiz beyond the quiz's current
         * ending time. This is mutually exclusive to extend_from_now. This is
         * limited to 1440 minutes (24 hours)
         */
        extend_from_end_at?: number;
        /**
         * The number of minutes to extend the quiz from the current time. This is
         * mutually exclusive to extend_from_end_at. This is limited to 1440
         * minutes (24 hours)
         */
        extend_from_now?: number;
        /**
         * Number of times the student is allowed to re-take the quiz over the
         * multiple-attempt limit. This is limited to 1000 attempts or less.
         */
        extra_attempts?: number;
        /**
         * The number of extra minutes to allow for all attempts. This will
         * add to the existing time limit on the submission. This is limited to
         * 10080 minutes (1 week)
         */
        extra_time?: number;
        /**
         * Allow the student to take the quiz even if it's locked for
         * everyone else.
         */
        manually_unlocked?: boolean;
        /**
         * The ID of the user we want to add quiz extensions for.
         */
        user_id: number;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quiz_extensions';
};

export type SetExtensionsForStudentQuizSubmissionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListQuizzesInCourseData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The partial title of the quizzes to match and return.
         */
        search_term?: string;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/quizzes';
};

export type ListQuizzesInCourseResponses = {
    /**
     * No response was specified
     */
    200: Array<Quiz>;
};

export type ListQuizzesInCourseResponse = ListQuizzesInCourseResponses[keyof ListQuizzesInCourseResponses];

export type CreateQuizData = {
    body: {
        /**
         * Restricts access to the quiz with a password.
         * For no access code restriction, set to null.
         * Defaults to null.
         */
        'quiz[access_code]'?: string;
        /**
         * Number of times a student is allowed to take a quiz.
         * Set to -1 for unlimited attempts.
         * Defaults to 1.
         */
        'quiz[allowed_attempts]'?: number;
        /**
         * The assignment group id to put the assignment in. Defaults to the top
         * assignment group in the course. Only valid if the quiz is graded, i.e. if
         * quiz_type is "assignment" or "graded_survey".
         */
        'quiz[assignment_group_id]'?: number;
        /**
         * Only valid if one_question_at_a_time=true
         * If true, questions are locked after answering.
         * Defaults to false.
         */
        'quiz[cant_go_back]'?: boolean;
        /**
         * A description of the quiz.
         */
        'quiz[description]'?: string;
        /**
         * The day/time the quiz is due.
         * Accepts times in ISO 8601 format, e.g. 2011-10-21T18:48Z.
         */
        'quiz[due_at]'?: string;
        /**
         * Only valid if show_correct_answers=true
         * If set, the correct answers will stop being visible once this date has
         * passed. Otherwise, the correct answers will be visible indefinitely.
         */
        'quiz[hide_correct_answers_at]'?: string;
        /**
         * Dictates whether or not quiz results are hidden from students.
         * If null, students can see their results after any attempt.
         * If "always", students can never see their results.
         * If "until_after_last_attempt", students can only see results after their
         * last attempt. (Only valid if allowed_attempts > 1). Defaults to null.
         */
        'quiz[hide_results]'?: 'always' | 'until_after_last_attempt';
        /**
         * Restricts access to the quiz to computers in a specified IP range.
         * Filters can be a comma-separated list of addresses, or an address followed by a mask
         *
         * Examples:
         * "192.168.217.1"
         * "192.168.217.1/24"
         * "192.168.217.1/255.255.255.0"
         *
         * For no IP filter restriction, set to null.
         * Defaults to null.
         */
        'quiz[ip_filter]'?: string;
        /**
         * The day/time the quiz is locked for students.
         * Accepts times in ISO 8601 format, e.g. 2011-10-21T18:48Z.
         */
        'quiz[lock_at]'?: string;
        /**
         * If true, shows quiz to student one question at a time.
         * Defaults to false.
         */
        'quiz[one_question_at_a_time]'?: boolean;
        /**
         * Whether students should be prevented from viewing their quiz results past
         * the first time (right after they turn the quiz in.)
         * Only valid if "hide_results" is not set to "always".
         * Defaults to false.
         */
        'quiz[one_time_results]'?: boolean;
        /**
         * Whether this quiz is only visible to overrides (Only useful if
         * 'differentiated assignments' account setting is on)
         * Defaults to false.
         */
        'quiz[only_visible_to_overrides]'?: boolean;
        /**
         * Whether the quiz should have a draft state of published or unpublished.
         * NOTE: If students have started taking the quiz, or there are any
         * submissions for the quiz, you may not unpublish a quiz and will recieve
         * an error.
         */
        'quiz[published]'?: boolean;
        /**
         * The type of quiz.
         */
        'quiz[quiz_type]'?: 'practice_quiz' | 'assignment' | 'graded_survey' | 'survey';
        /**
         * Required and only valid if allowed_attempts > 1.
         * Scoring policy for a quiz that students can take multiple times.
         * Defaults to "keep_highest".
         */
        'quiz[scoring_policy]'?: 'keep_highest' | 'keep_latest';
        /**
         * Only valid if hide_results=null
         * If false, hides correct answers from students when quiz results are viewed.
         * Defaults to true.
         */
        'quiz[show_correct_answers]'?: boolean;
        /**
         * Only valid if show_correct_answers=true
         * If set, the correct answers will be visible by students only after this
         * date, otherwise the correct answers are visible once the student hands in
         * their quiz submission.
         */
        'quiz[show_correct_answers_at]'?: string;
        /**
         * Only valid if show_correct_answers=true and allowed_attempts > 1
         * If true, hides correct answers from students when quiz results are viewed
         * until they submit the last attempt for the quiz.
         * Defaults to false.
         */
        'quiz[show_correct_answers_last_attempt]'?: boolean;
        /**
         * If true, quiz answers for multiple choice questions will be randomized for
         * each student. Defaults to false.
         */
        'quiz[shuffle_answers]'?: boolean;
        /**
         * Time limit to take this quiz, in minutes. Set to null for no time limit.
         * Defaults to null.
         */
        'quiz[time_limit]'?: number;
        /**
         * The quiz title.
         */
        'quiz[title]': string;
        /**
         * The day/time the quiz is unlocked for students.
         * Accepts times in ISO 8601 format, e.g. 2011-10-21T18:48Z.
         */
        'quiz[unlock_at]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes';
};

export type CreateQuizResponses = {
    /**
     * No response was specified
     */
    200: Quiz;
};

export type CreateQuizResponse = CreateQuizResponses[keyof CreateQuizResponses];

export type RetrieveAssignmentOverriddenDatesForQuizzesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * An array of quiz IDs. If omitted, overrides for all quizzes available to
         * the operating user will be returned.
         */
        'quiz_assignment_overrides[0][quiz_ids]'?: Array<number>;
    };
    url: '/v1/courses/{course_id}/quizzes/assignment_overrides';
};

export type RetrieveAssignmentOverriddenDatesForQuizzesResponses = {
    /**
     * No response was specified
     */
    200: QuizAssignmentOverrideSetContainer;
};

export type RetrieveAssignmentOverriddenDatesForQuizzesResponse = RetrieveAssignmentOverriddenDatesForQuizzesResponses[keyof RetrieveAssignmentOverriddenDatesForQuizzesResponses];

export type DeleteQuizData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{id}';
};

export type DeleteQuizResponses = {
    /**
     * No response was specified
     */
    200: Quiz;
};

export type DeleteQuizResponse = DeleteQuizResponses[keyof DeleteQuizResponses];

export type GetSingleQuizData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{id}';
};

export type GetSingleQuizResponses = {
    /**
     * No response was specified
     */
    200: Quiz;
};

export type GetSingleQuizResponse = GetSingleQuizResponses[keyof GetSingleQuizResponses];

export type EditQuizData = {
    body?: {
        /**
         * If true, notifies users that the quiz has changed.
         * Defaults to true
         */
        'quiz[notify_of_update]'?: boolean;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{id}';
};

export type EditQuizResponses = {
    /**
     * No response was specified
     */
    200: Quiz;
};

export type EditQuizResponse = EditQuizResponses[keyof EditQuizResponses];

export type ReorderQuizItemsData = {
    body: {
        /**
         * The associated item's unique identifier
         */
        'order[id]': Array<number>;
        /**
         * The type of item is either 'question' or 'group'
         */
        'order[type]'?: Array<'question' | 'group'>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{id}/reorder';
};

export type ReorderQuizItemsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type SendMessageToUnsubmittedOrSubmittedUsersForQuizData = {
    body?: {
        /**
         * - Body and recipients to send the message to.
         */
        conversations?: unknown;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{id}/submission_users/message';
};

export type SendMessageToUnsubmittedOrSubmittedUsersForQuizResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ValidateQuizAccessCodeData = {
    body: {
        /**
         * The access code being validated
         */
        access_code: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{id}/validate_access_code';
};

export type ValidateQuizAccessCodeResponses = {
    /**
     * No response was specified
     */
    200: boolean;
};

export type ValidateQuizAccessCodeResponse = ValidateQuizAccessCodeResponses[keyof ValidateQuizAccessCodeResponses];

export type SetExtensionsForStudentQuizData = {
    body: {
        /**
         * The number of minutes to extend the quiz beyond the quiz's current ending time. This is mutually exclusive to extend_from_now. This is limited to 1440 minutes (24 hours)
         */
        'quiz_extensions[extend_from_end_at]'?: Array<number>;
        /**
         * The number of minutes to extend the quiz from the current time. This is
         * mutually exclusive to extend_from_end_at. This is limited to 1440
         * minutes (24 hours)
         */
        'quiz_extensions[extend_from_now]'?: Array<number>;
        /**
         * Number of times the student is allowed to re-take the quiz over the
         * multiple-attempt limit. This is limited to 1000 attempts or less.
         */
        'quiz_extensions[extra_attempts]'?: Array<number>;
        /**
         * The number of extra minutes to allow for all attempts. This will
         * add to the existing time limit on the submission. This is limited to
         * 10080 minutes (1 week)
         */
        'quiz_extensions[extra_time]'?: Array<number>;
        /**
         * Allow the student to take the quiz even if it's locked for
         * everyone else.
         */
        'quiz_extensions[manually_unlocked]'?: Array<boolean>;
        /**
         * The ID of the user we want to add quiz extensions for.
         */
        'quiz_extensions[user_id]': Array<number>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/extensions';
};

export type SetExtensionsForStudentQuizResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateQuestionGroupData = {
    body?: {
        /**
         * The id of the assessment question bank to pull questions from.
         */
        'quiz_groups[assessment_question_bank_id]'?: Array<number>;
        /**
         * The name of the question group.
         */
        'quiz_groups[name]'?: Array<string>;
        /**
         * The number of questions to randomly select for this group.
         */
        'quiz_groups[pick_count]'?: Array<number>;
        /**
         * The number of points to assign to each question in the group.
         */
        'quiz_groups[question_points]'?: Array<number>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/groups';
};

export type CreateQuestionGroupResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteQuestionGroupData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/groups/{id}';
};

export type DeleteQuestionGroupResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleQuizGroupData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/groups/{id}';
};

export type GetSingleQuizGroupResponses = {
    /**
     * No response was specified
     */
    200: QuizGroup;
};

export type GetSingleQuizGroupResponse = GetSingleQuizGroupResponses[keyof GetSingleQuizGroupResponses];

export type UpdateQuestionGroupData = {
    body?: {
        /**
         * The name of the question group.
         */
        'quiz_groups[name]'?: Array<string>;
        /**
         * The number of questions to randomly select for this group.
         */
        'quiz_groups[pick_count]'?: Array<number>;
        /**
         * The number of points to assign to each question in the group.
         */
        'quiz_groups[question_points]'?: Array<number>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/groups/{id}';
};

export type UpdateQuestionGroupResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ReorderQuestionGroupsData = {
    body: {
        /**
         * The associated item's unique identifier
         */
        'order[id]': Array<number>;
        /**
         * The type of item is always 'question' for a group
         */
        'order[type]'?: Array<'question'>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/groups/{id}/reorder';
};

export type ReorderQuestionGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetAvailableQuizIpFiltersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/ip_filters';
};

export type GetAvailableQuizIpFiltersResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListQuestionsInQuizOrSubmissionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
    };
    query?: {
        /**
         * If specified, the endpoint will return the questions that were presented
         * for that submission. This is useful if the quiz has been modified after
         * the submission was created and the latest quiz version's set of questions
         * does not match the submission's.
         * NOTE: you must specify quiz_submission_attempt as well if you specify this
         * parameter.
         */
        quiz_submission_id?: number;
        /**
         * The attempt of the submission you want the questions for.
         */
        quiz_submission_attempt?: number;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/questions';
};

export type ListQuestionsInQuizOrSubmissionResponses = {
    /**
     * No response was specified
     */
    200: Array<QuizQuestion>;
};

export type ListQuestionsInQuizOrSubmissionResponse = ListQuestionsInQuizOrSubmissionResponses[keyof ListQuestionsInQuizOrSubmissionResponses];

export type CreateSingleQuizQuestionData = {
    body?: {
        /**
         * no description
         */
        'question[answers]'?: unknown;
        /**
         * The comment to display if the student answers the question correctly.
         */
        'question[correct_comments]'?: string;
        /**
         * The comment to display if the student answers incorrectly.
         */
        'question[incorrect_comments]'?: string;
        /**
         * The comment to display regardless of how the student answered.
         */
        'question[neutral_comments]'?: string;
        /**
         * The maximum amount of points received for answering this question correctly.
         */
        'question[points_possible]'?: number;
        /**
         * The order in which the question will be displayed in the quiz in relation to other questions.
         */
        'question[position]'?: number;
        /**
         * The name of the question.
         */
        'question[question_name]'?: string;
        /**
         * The text of the question.
         */
        'question[question_text]'?: string;
        /**
         * The type of question. Multiple optional fields depend upon the type of question to be used.
         */
        'question[question_type]'?: 'calculated_question' | 'essay_question' | 'file_upload_question' | 'fill_in_multiple_blanks_question' | 'matching_question' | 'multiple_answers_question' | 'multiple_choice_question' | 'multiple_dropdowns_question' | 'numerical_question' | 'short_answer_question' | 'text_only_question' | 'true_false_question';
        /**
         * The id of the quiz group to assign the question to.
         */
        'question[quiz_group_id]'?: number;
        /**
         * no description
         */
        'question[text_after_answers]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/questions';
};

export type CreateSingleQuizQuestionResponses = {
    /**
     * No response was specified
     */
    200: QuizQuestion;
};

export type CreateSingleQuizQuestionResponse = CreateSingleQuizQuestionResponses[keyof CreateSingleQuizQuestionResponses];

export type DeleteQuizQuestionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * The associated quiz's unique identifier
         */
        quiz_id: number;
        /**
         * The quiz question's unique identifier
         */
        id: number;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/questions/{id}';
};

export type DeleteQuizQuestionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleQuizQuestionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * The quiz question unique identifier.
         */
        id: number;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/questions/{id}';
};

export type GetSingleQuizQuestionResponses = {
    /**
     * No response was specified
     */
    200: QuizQuestion;
};

export type GetSingleQuizQuestionResponse = GetSingleQuizQuestionResponses[keyof GetSingleQuizQuestionResponses];

export type UpdateExistingQuizQuestionData = {
    body?: {
        /**
         * no description
         */
        'question[answers]'?: unknown;
        /**
         * The comment to display if the student answers the question correctly.
         */
        'question[correct_comments]'?: string;
        /**
         * The comment to display if the student answers incorrectly.
         */
        'question[incorrect_comments]'?: string;
        /**
         * The comment to display regardless of how the student answered.
         */
        'question[neutral_comments]'?: string;
        /**
         * The maximum amount of points received for answering this question correctly.
         */
        'question[points_possible]'?: number;
        /**
         * The order in which the question will be displayed in the quiz in relation to other questions.
         */
        'question[position]'?: number;
        /**
         * The name of the question.
         */
        'question[question_name]'?: string;
        /**
         * The text of the question.
         */
        'question[question_text]'?: string;
        /**
         * The type of question. Multiple optional fields depend upon the type of question to be used.
         */
        'question[question_type]'?: 'calculated_question' | 'essay_question' | 'file_upload_question' | 'fill_in_multiple_blanks_question' | 'matching_question' | 'multiple_answers_question' | 'multiple_choice_question' | 'multiple_dropdowns_question' | 'numerical_question' | 'short_answer_question' | 'text_only_question' | 'true_false_question';
        /**
         * The id of the quiz group to assign the question to.
         */
        'question[quiz_group_id]'?: number;
        /**
         * no description
         */
        'question[text_after_answers]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * The associated quiz's unique identifier.
         */
        quiz_id: number;
        /**
         * The quiz question's unique identifier.
         */
        id: number;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/questions/{id}';
};

export type UpdateExistingQuizQuestionResponses = {
    /**
     * No response was specified
     */
    200: QuizQuestion;
};

export type UpdateExistingQuizQuestionResponse = UpdateExistingQuizQuestionResponses[keyof UpdateExistingQuizQuestionResponses];

export type RetrieveAllQuizReportsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
    };
    query?: {
        /**
         * Whether to retrieve reports that consider all the submissions or only
         * the most recent. Defaults to false, ignored for item_analysis reports.
         */
        includes_all_versions?: boolean;
    };
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/reports';
};

export type RetrieveAllQuizReportsResponses = {
    /**
     * No response was specified
     */
    200: Array<QuizReport>;
};

export type RetrieveAllQuizReportsResponse = RetrieveAllQuizReportsResponses[keyof RetrieveAllQuizReportsResponses];

export type CreateQuizReportData = {
    body: {
        /**
         * Whether the output should include documents for the file and/or progress objects associated with this report. (Note: JSON-API only)
         */
        include?: 'file' | 'progress';
        /**
         * Whether the report should consider all submissions or only the most
         * recent. Defaults to false, ignored for item_analysis.
         */
        'quiz_report[includes_all_versions]'?: boolean;
        /**
         * The type of report to be generated.
         */
        'quiz_report[report_type]': 'student_analysis' | 'item_analysis';
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/reports';
};

export type CreateQuizReportResponses = {
    /**
     * No response was specified
     */
    200: QuizReport;
};

export type CreateQuizReportResponse = CreateQuizReportResponses[keyof CreateQuizReportResponses];

export type AbortGenerationOfReportOrRemovePreviouslyGeneratedOneData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/reports/{id}';
};

export type AbortGenerationOfReportOrRemovePreviouslyGeneratedOneResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetQuizReportData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Whether the output should include documents for the file and/or progress
         * objects associated with this report. (Note: JSON-API only)
         */
        include?: 'file' | 'progress';
    };
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/reports/{id}';
};

export type GetQuizReportResponses = {
    /**
     * No response was specified
     */
    200: QuizReport;
};

export type GetQuizReportResponse = GetQuizReportResponses[keyof GetQuizReportResponses];

export type FetchingLatestQuizStatisticsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
    };
    query?: {
        /**
         * Whether the statistics report should include all submissions attempts.
         */
        all_versions?: boolean;
    };
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/statistics';
};

export type FetchingLatestQuizStatisticsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetQuizSubmissionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
    };
    query?: {
        /**
         * Associations to include with the quiz submission.
         */
        include?: Array<'submission' | 'quiz' | 'user'>;
    };
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/submission';
};

export type GetQuizSubmissionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetAllQuizSubmissionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
    };
    query?: {
        /**
         * Associations to include with the quiz submission.
         */
        include?: Array<'submission' | 'quiz' | 'user'>;
    };
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/submissions';
};

export type GetAllQuizSubmissionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateQuizSubmissionStartQuizTakingSessionData = {
    body?: {
        /**
         * Access code for the Quiz, if any.
         */
        access_code?: string;
        /**
         * Whether this should be a preview QuizSubmission and not count towards
         * the user's course record. Teachers only.
         */
        preview?: boolean;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/submissions';
};

export type CreateQuizSubmissionStartQuizTakingSessionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UploadFileQuizSubmissionData = {
    body?: {
        /**
         * The name of the quiz submission file
         */
        name?: string;
        /**
         * How to handle duplicate names
         */
        on_duplicate?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/self/files';
};

export type UploadFileQuizSubmissionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleQuizSubmissionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Associations to include with the quiz submission.
         */
        include?: Array<'submission' | 'quiz' | 'user'>;
    };
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}';
};

export type GetSingleQuizSubmissionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateStudentQuestionScoresAndCommentsData = {
    body: {
        /**
         * The attempt number of the quiz submission that should be updated. This
         * attempt MUST be already completed.
         */
        'quiz_submissions[attempt]': Array<number>;
        /**
         * Amount of positive or negative points to fudge the total score by.
         */
        'quiz_submissions[fudge_points]'?: Array<number>;
        /**
         * A set of scores and comments for each question answered by the student.
         * The keys are the question IDs, and the values are hashes of `score` and
         * `comment` entries. See {Appendix: Manual Scoring} for more on this
         * parameter.
         */
        'quiz_submissions[questions]'?: Array<QuizSubmission>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}';
};

export type UpdateStudentQuestionScoresAndCommentsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CompleteQuizSubmissionTurnItInData = {
    body: {
        /**
         * Access code for the Quiz, if any.
         */
        access_code?: string;
        /**
         * The attempt number of the quiz submission that should be completed. Note
         * that this must be the latest attempt index, as earlier attempts can not
         * be modified.
         */
        attempt: number;
        /**
         * The unique validation token you received when this Quiz Submission was
         * created.
         */
        validation_token: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}/complete';
};

export type CompleteQuizSubmissionTurnItInResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type RetrieveCapturedEventsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * The specific submission attempt to look up the events for. If unspecified,
         * the latest attempt will be used.
         */
        attempt?: number;
    };
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}/events';
};

export type RetrieveCapturedEventsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type SubmitCapturedEventsData = {
    body: {
        /**
         * The submission events to be recorded
         */
        quiz_submission_events: Array<Array<{
            [key: string]: unknown;
        }>>;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}/events';
};

export type SubmitCapturedEventsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetCurrentQuizSubmissionTimesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        quiz_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}/time';
};

export type GetCurrentQuizSubmissionTimesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListRecentlyLoggedInStudentsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/recent_students';
};

export type ListRecentlyLoggedInStudentsResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type ListRecentlyLoggedInStudentsResponse = ListRecentlyLoggedInStudentsResponses[keyof ListRecentlyLoggedInStudentsResponses];

export type ResetCourseData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/reset_content';
};

export type ResetCourseResponses = {
    /**
     * No response was specified
     */
    200: Course;
};

export type ResetCourseResponse = ResetCourseResponses[keyof ResetCourseResponses];

export type RedirectToRootOutcomeGroupForContextCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/root_outcome_group';
};

export type RedirectToRootOutcomeGroupForContextCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListRubricsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/rubrics';
};

export type ListRubricsCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleRubricCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * If included, the type of associated rubric assessments to return. If not included, assessments will be omitted.
         */
        include?: 'assessments' | 'graded_assessments' | 'peer_assessments';
        /**
         * Applicable only if assessments are being returned. If included, returns either all criteria data associated with the assessment, or just the comments. If not included, both data and comments are omitted.
         */
        style?: 'full' | 'comments_only';
    };
    url: '/v1/courses/{course_id}/rubrics/{id}';
};

export type GetSingleRubricCoursesResponses = {
    /**
     * No response was specified
     */
    200: Rubric;
};

export type GetSingleRubricCoursesResponse = GetSingleRubricCoursesResponses[keyof GetSingleRubricCoursesResponses];

export type ListUsersInCourseSearchUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
        /**
         * The partial name or full ID of the users to match and return in the results list.
         */
        search_term?: string;
        /**
         * When set, only return users where the user is enrolled as this type.
         * "student_view" implies include[]=test_student.
         * This argument is ignored if enrollment_role is given.
         */
        enrollment_type?: Array<'teacher' | 'student' | 'student_view' | 'ta' | 'observer' | 'designer'>;
        /**
         * Deprecated
         * When set, only return users enrolled with the specified course-level role.  This can be
         * a role created with the {api:RoleOverridesController#add_role Add Role API} or a
         * base role type of 'StudentEnrollment', 'TeacherEnrollment', 'TaEnrollment',
         * 'ObserverEnrollment', or 'DesignerEnrollment'.
         */
        enrollment_role?: string;
        /**
         * When set, only return courses where the user is enrolled with the specified
         * course-level role.  This can be a role created with the
         * {api:RoleOverridesController#add_role Add Role API} or a built_in role id with type
         * 'StudentEnrollment', 'TeacherEnrollment', 'TaEnrollment', 'ObserverEnrollment',
         * or 'DesignerEnrollment'.
         */
        enrollment_role_id?: number;
        /**
         * - "email": Optional user email.
         * - "enrollments":
         * Optionally include with each Course the user's current and invited
         * enrollments. If the user is enrolled as a student, and the account has
         * permission to manage or view all grades, each enrollment will include a
         * 'grades' key with 'current_score', 'final_score', 'current_grade' and
         * 'final_grade' values.
         * - "locked": Optionally include whether an enrollment is locked.
         * - "avatar_url": Optionally include avatar_url.
         * - "bio": Optionally include each user's bio.
         * - "test_student": Optionally include the course's Test Student,
         * if present. Default is to not include Test Student.
         * - "custom_links": Optionally include plugin-supplied custom links for each student,
         * such as analytics information
         * - "current_grading_period_scores": if enrollments is included as
         * well as this directive, the scores returned in the enrollment
         * will be for the current grading period if there is one. A
         * 'grading_period_id' value will also be included with the
         * scores. if grading_period_id is nil there is no current grading
         * period and the score is a total score.
         */
        include?: Array<'email' | 'enrollments' | 'locked' | 'avatar_url' | 'test_student' | 'bio' | 'custom_links' | 'current_grading_period_scores'>;
        /**
         * If this parameter is given and it corresponds to a user in the course,
         * the +page+ parameter will be ignored and the page containing the specified user
         * will be returned instead.
         */
        user_id?: string;
        /**
         * If included, the course users set will only include users with IDs
         * specified by the param. Note: this will not work in conjunction
         * with the "user_id" argument but multiple user_ids can be included.
         */
        user_ids?: Array<number>;
        /**
         * When set, only return users where the enrollment workflow state is of one of the given types.
         * "active" and "invited" enrollments are returned by default.
         */
        enrollment_state?: Array<'active' | 'invited' | 'rejected' | 'completed' | 'inactive'>;
    };
    url: '/v1/courses/{course_id}/search_users';
};

export type ListUsersInCourseSearchUsersResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type ListUsersInCourseSearchUsersResponse = ListUsersInCourseSearchUsersResponses[keyof ListUsersInCourseSearchUsersResponses];

export type ListCourseSectionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * - "students": Associations to include with the group. Note: this is only
         * available if you have permission to view users or grades in the course
         * - "avatar_url": Include the avatar URLs for students returned.
         * - "enrollments": If 'students' is also included, return the section
         * enrollment for each student
         * - "total_students": Returns the total amount of active and invited students
         * for the course section
         * - "passback_status": Include the grade passback status.
         */
        include?: Array<'students' | 'avatar_url' | 'enrollments' | 'total_students' | 'passback_status'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/sections';
};

export type ListCourseSectionsResponses = {
    /**
     * No response was specified
     */
    200: Array<Section>;
};

export type ListCourseSectionsResponse = ListCourseSectionsResponses[keyof ListCourseSectionsResponses];

export type CreateCourseSectionData = {
    body?: {
        /**
         * Section end date in ISO8601 format. e.g. 2011-01-01T01:00Z
         */
        'course_section[end_at]'?: string;
        /**
         * The integration_id of the section. Must have manage_sis permission to set. This is ignored if caller does not have permission to set.
         */
        'course_section[integration_id]'?: string;
        /**
         * The name of the section
         */
        'course_section[name]'?: string;
        /**
         * Set to true to restrict user enrollments to the start and end dates of the section.
         */
        'course_section[restrict_enrollments_to_section_dates]'?: boolean;
        /**
         * The sis ID of the section. Must have manage_sis permission to set. This is ignored if caller does not have permission to set.
         */
        'course_section[sis_section_id]'?: string;
        /**
         * Section start date in ISO8601 format, e.g. 2011-01-01T01:00Z
         */
        'course_section[start_at]'?: string;
        /**
         * When true, will first try to re-activate a deleted section with matching sis_section_id if possible.
         */
        enable_sis_reactivation?: boolean;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/sections';
};

export type CreateCourseSectionResponses = {
    /**
     * No response was specified
     */
    200: Section;
};

export type CreateCourseSectionResponse = CreateCourseSectionResponses[keyof CreateCourseSectionResponses];

export type GetSectionInformationCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * - "students": Associations to include with the group. Note: this is only
         * available if you have permission to view users or grades in the course
         * - "avatar_url": Include the avatar URLs for students returned.
         * - "enrollments": If 'students' is also included, return the section
         * enrollment for each student
         * - "total_students": Returns the total amount of active and invited students
         * for the course section
         * - "passback_status": Include the grade passback status.
         */
        include?: Array<'students' | 'avatar_url' | 'enrollments' | 'total_students' | 'passback_status'>;
    };
    url: '/v1/courses/{course_id}/sections/{id}';
};

export type GetSectionInformationCoursesResponses = {
    /**
     * No response was specified
     */
    200: Section;
};

export type GetSectionInformationCoursesResponse = GetSectionInformationCoursesResponses[keyof GetSectionInformationCoursesResponses];

export type GetCourseSettingsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/settings';
};

export type GetCourseSettingsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateCourseSettingsData = {
    body?: {
        /**
         * Let students edit or delete their own discussion posts
         */
        allow_student_discussion_editing?: boolean;
        /**
         * Let students create discussion topics
         */
        allow_student_discussion_topics?: boolean;
        /**
         * Let students attach files to discussions
         */
        allow_student_forum_attachments?: boolean;
        /**
         * Let students organize their own groups
         */
        allow_student_organized_groups?: boolean;
        /**
         * Hide grade distribution graphs from students
         */
        hide_distribution_graphs?: boolean;
        /**
         * Hide totals in student grades summary
         */
        hide_final_grades?: boolean;
        /**
         * Limit the number of announcements on the home page if enabled via show_announcements_on_home_page
         */
        home_page_announcement_limit?: number;
        /**
         * Disable comments on announcements
         */
        lock_all_announcements?: boolean;
        /**
         * Restrict students from viewing courses before start date
         */
        restrict_student_future_view?: boolean;
        /**
         * Restrict students from viewing courses after end date
         */
        restrict_student_past_view?: boolean;
        /**
         * Show the most recent announcements on the Course home page (if a Wiki, defaults to five announcements, configurable via home_page_announcement_limit)
         */
        show_announcements_on_home_page?: boolean;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/settings';
};

export type UpdateCourseSettingsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListStudentsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/students';
};

export type ListStudentsResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type ListStudentsResponse = ListStudentsResponses[keyof ListStudentsResponses];

export type ListSubmissionsForMultipleAssignmentsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * List of student ids to return submissions for. If this argument is
         * omitted, return submissions for the calling user. Students may only list
         * their own submissions. Observers may only list those of associated
         * students. The special id "all" will return submissions for all students
         * in the course/section as appropriate.
         */
        'student_ids[]'?: Array<string>;
        /**
         * List of assignments to return submissions for. If none are given,
         * submissions for all assignments are returned.
         */
        assignment_ids?: Array<string>;
        /**
         * If this argument is present, the response will be grouped by student,
         * rather than a flat array of submissions.
         */
        grouped?: boolean;
        /**
         * If this argument is set to true, the response will only include
         * submissions for assignments that have the post_to_sis flag set to true and
         * user enrollments that were added through sis.
         */
        post_to_sis?: boolean;
        /**
         * If this argument is set, the response will only include submissions that
         * were submitted after the specified date_time. This will exclude
         * submissions that do not have a submitted_at which will exclude unsubmitted
         * submissions.
         * The value must be formatted as ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         */
        submitted_since?: string;
        /**
         * If this argument is set, the response will only include submissions that
         * were graded after the specified date_time. This will exclude
         * submissions that have not been graded.
         * The value must be formatted as ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         */
        graded_since?: string;
        /**
         * The id of the grading period in which submissions are being requested
         * (Requires grading periods to exist on the account)
         */
        grading_period_id?: number;
        /**
         * The current status of the submission
         */
        workflow_state?: 'submitted' | 'unsubmitted' | 'graded' | 'pending_review';
        /**
         * The current state of the enrollments. If omitted will include all
         * enrollments that are not deleted.
         */
        enrollment_state?: 'active' | 'concluded';
        /**
         * If omitted it is set to true. When set to false it will ignore the effective
         * state of the student enrollments and use the workflow_state for the
         * enrollments. The argument is ignored unless enrollment_state argument is
         * also passed.
         */
        state_based_on_date?: boolean;
        /**
         * The order submissions will be returned in.  Defaults to "id".  Doesn't
         * affect results for "grouped" mode.
         */
        order?: 'id' | 'graded_at';
        /**
         * Determines whether ordered results are returned in ascending or descending
         * order.  Defaults to "ascending".  Doesn't affect results for "grouped" mode.
         */
        order_direction?: 'ascending' | 'descending';
        /**
         * Associations to include with the group. `total_scores` requires the
         * `grouped` argument.
         */
        'include[]'?: Array<'submission_history' | 'submission_comments' | 'rubric_assessment' | 'assignment' | 'total_scores' | 'visibility' | 'course' | 'user'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/students/submissions';
};

export type ListSubmissionsForMultipleAssignmentsCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<Submission>;
};

export type ListSubmissionsForMultipleAssignmentsCoursesResponse = ListSubmissionsForMultipleAssignmentsCoursesResponses[keyof ListSubmissionsForMultipleAssignmentsCoursesResponses];

export type GradeOrCommentOnMultipleSubmissionsCoursesSubmissionsData = {
    body?: {
        /**
         * Specifies which assignment to grade.  This argument is not necessary when
         * using the assignment-specific endpoints.
         */
        'grade_data[student_id][assignment_id]'?: number;
        /**
         * See documentation for the excuse argument in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][excuse]'?: boolean;
        /**
         * See documentation for the comment[] arguments in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][file_ids]'?: Array<number>;
        /**
         * no description
         */
        'grade_data[student_id][group_comment]'?: boolean;
        /**
         * no description
         */
        'grade_data[student_id][media_comment_id]'?: string;
        /**
         * no description
         */
        'grade_data[student_id][media_comment_type]'?: 'audio' | 'video';
        /**
         * See documentation for the posted_grade argument in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][posted_grade]'?: string;
        /**
         * See documentation for the rubric_assessment argument in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][rubric_assessment]'?: unknown;
        /**
         * no description
         */
        'grade_data[student_id][text_comment]'?: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/submissions/update_grades';
};

export type GradeOrCommentOnMultipleSubmissionsCoursesSubmissionsResponses = {
    /**
     * No response was specified
     */
    200: Progress;
};

export type GradeOrCommentOnMultipleSubmissionsCoursesSubmissionsResponse = GradeOrCommentOnMultipleSubmissionsCoursesSubmissionsResponses[keyof GradeOrCommentOnMultipleSubmissionsCoursesSubmissionsResponses];

export type ListAvailableTabsForCourseOrGroupCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * "external":: Optionally include external tool tabs in the returned list of tabs (Only has effect for courses, not groups)
         */
        include?: Array<'external'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/courses/{course_id}/tabs';
};

export type ListAvailableTabsForCourseOrGroupCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateTabForCourseData = {
    body?: {
        /**
         * no description
         */
        hidden?: boolean;
        /**
         * The new position of the tab, 1-based
         */
        position?: number;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        tab_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/tabs/{tab_id}';
};

export type UpdateTabForCourseResponses = {
    /**
     * No response was specified
     */
    200: Tab;
};

export type UpdateTabForCourseResponse = UpdateTabForCourseResponses[keyof UpdateTabForCourseResponses];

export type CourseTodoItemsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/todo';
};

export type CourseTodoItemsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type RemoveUsageRightsCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query: {
        /**
         * List of ids of files to remove associated usage rights from.
         */
        file_ids: Array<string>;
        /**
         * List of ids of folders. Usage rights will be removed from all files in these folders.
         */
        folder_ids?: Array<string>;
    };
    url: '/v1/courses/{course_id}/usage_rights';
};

export type RemoveUsageRightsCoursesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type SetUsageRightsCoursesData = {
    body: {
        /**
         * List of ids of files to set usage rights for.
         */
        file_ids: Array<string>;
        /**
         * List of ids of folders to search for files to set usage rights for.
         * Note that new files uploaded to these folders do not automatically inherit these rights.
         */
        folder_ids?: Array<string>;
        /**
         * Whether the file(s) or folder(s) should be published on save, provided that usage rights have been specified (set to `true` to publish on save).
         */
        publish?: boolean;
        /**
         * The legal copyright line for the files
         */
        'usage_rights[legal_copyright]'?: string;
        /**
         * The license that applies to the files. See the {api:UsageRightsController#licenses List licenses endpoint} for the supported license types.
         */
        'usage_rights[license]'?: string;
        /**
         * The intellectual property justification for using the files in Canvas
         */
        'usage_rights[use_justification]': 'own_copyright' | 'used_by_permission' | 'fair_use' | 'public_domain' | 'creative_commons';
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/usage_rights';
};

export type SetUsageRightsCoursesResponses = {
    /**
     * No response was specified
     */
    200: UsageRights;
};

export type SetUsageRightsCoursesResponse = SetUsageRightsCoursesResponses[keyof SetUsageRightsCoursesResponses];

export type ListUsersInCourseUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: number;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
        /**
         * The partial name or full ID of the users to match and return in the results list.
         */
        search_term?: string;
        /**
         * When set, only return users where the user is enrolled as this type.
         * "student_view" implies include[]=test_student.
         * This argument is ignored if enrollment_role is given.
         */
        'enrollment_type[]'?: Array<'teacher' | 'student' | 'student_view' | 'ta' | 'observer' | 'designer'>;
        /**
         * Deprecated
         * When set, only return users enrolled with the specified course-level role.  This can be
         * a role created with the {api:RoleOverridesController#add_role Add Role API} or a
         * base role type of 'StudentEnrollment', 'TeacherEnrollment', 'TaEnrollment',
         * 'ObserverEnrollment', or 'DesignerEnrollment'.
         */
        enrollment_role?: string;
        /**
         * When set, only return courses where the user is enrolled with the specified
         * course-level role.  This can be a role created with the
         * {api:RoleOverridesController#add_role Add Role API} or a built_in role id with type
         * 'StudentEnrollment', 'TeacherEnrollment', 'TaEnrollment', 'ObserverEnrollment',
         * or 'DesignerEnrollment'.
         */
        enrollment_role_id?: number;
        /**
         * - "enrollments":
         * Optionally include with each Course the user's current and invited
         * enrollments. If the user is enrolled as a student, and the account has
         * permission to manage or view all grades, each enrollment will include a
         * 'grades' key with 'current_score', 'final_score', 'current_grade' and
         * 'final_grade' values.
         * - "locked": Optionally include whether an enrollment is locked.
         * - "avatar_url": Optionally include avatar_url.
         * - "bio": Optionally include each user's bio.
         * - "test_student": Optionally include the course's Test Student,
         * if present. Default is to not include Test Student.
         * - "custom_links": Optionally include plugin-supplied custom links for each student,
         * such as analytics information
         * - "current_grading_period_scores": if enrollments is included as
         * well as this directive, the scores returned in the enrollment
         * will be for the current grading period if there is one. A
         * 'grading_period_id' value will also be included with the
         * scores. if grading_period_id is nil there is no current grading
         * period and the score is a total score.
         */
        'include[]'?: Array<'email' | 'enrollments' | 'locked' | 'avatar_url' | 'test_student' | 'bio' | 'custom_links' | 'current_grading_period_scores' | 'sections'>;
        /**
         * If this parameter is given and it corresponds to a user in the course,
         * the +page+ parameter will be ignored and the page containing the specified user
         * will be returned instead.
         */
        user_id?: string;
        /**
         * If included, the course users set will only include users with IDs
         * specified by the param. Note: this will not work in conjunction
         * with the "user_id" argument but multiple user_ids can be included.
         */
        'user_ids[]'?: Array<number>;
        /**
         * When set, only return users where the enrollment workflow state is of one of the given types.
         * "active" and "invited" enrollments are returned by default.
         */
        'enrollment_state[]'?: Array<'active' | 'invited' | 'rejected' | 'completed' | 'inactive'>;
    };
    url: '/v1/courses/{course_id}/users';
};

export type ListUsersInCourseUsersResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type ListUsersInCourseUsersResponse = ListUsersInCourseUsersResponses[keyof ListUsersInCourseUsersResponses];

export type GetSingleUserData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/users/{id}';
};

export type GetSingleUserResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type GetSingleUserResponse = GetSingleUserResponses[keyof GetSingleUserResponses];

export type AddsLastAttendedDateToStudentEnrollmentInCourseData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/courses/{course_id}/users/{user_id}/last_attended';
};

export type AddsLastAttendedDateToStudentEnrollmentInCourseResponses = {
    /**
     * No response was specified
     */
    200: Enrollment;
};

export type AddsLastAttendedDateToStudentEnrollmentInCourseResponse = AddsLastAttendedDateToStudentEnrollmentInCourseResponses[keyof AddsLastAttendedDateToStudentEnrollmentInCourseResponses];

export type DeleteConcludeCourseData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query: {
        /**
         * The action to take on the course.
         */
        event: 'delete' | 'conclude';
    };
    url: '/v1/courses/{id}';
};

export type DeleteConcludeCourseResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleCourseCoursesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * - "all_courses": Also search recently deleted courses.
         * - "permissions": Include permissions the current user has
         * for the course.
         * - "observed_users": include observed users in the enrollments
         * - "course_image": Optional course image data for when there is a course image
         * and the course image feature flag has been enabled
         */
        include?: Array<'needs_grading_count' | 'syllabus_body' | 'public_description' | 'total_scores' | 'current_grading_period_scores' | 'term' | 'account' | 'course_progress' | 'sections' | 'storage_quota_used_mb' | 'total_students' | 'passback_status' | 'favorites' | 'teachers' | 'observed_users' | 'all_courses' | 'permissions' | 'course_image'>;
    };
    url: '/v1/courses/{id}';
};

export type GetSingleCourseCoursesResponses = {
    /**
     * No response was specified
     */
    200: Course;
};

export type GetSingleCourseCoursesResponse = GetSingleCourseCoursesResponses[keyof GetSingleCourseCoursesResponses];

export type UpdateCourseData = {
    body?: {
        /**
         * The unique ID of the account to move the course to.
         */
        'course[account_id]'?: number;
        /**
         * If true, students can attach files to forum posts.
         */
        'course[allow_student_forum_attachments]'?: boolean;
        /**
         * If true, students will be able to modify the course wiki.
         */
        'course[allow_student_wiki_edits]'?: boolean;
        /**
         * If true, course members will be able to comment on wiki pages.
         */
        'course[allow_wiki_comments]'?: boolean;
        /**
         * Set to true to weight final grade based on assignment groups percentages.
         */
        'course[apply_assignment_group_weights]'?: boolean;
        /**
         * Sets the course as a blueprint course. NOTE: The Blueprint Courses feature is in beta
         */
        'course[blueprint]'?: boolean;
        /**
         * Sets a default set to apply to blueprint course objects when restricted,
         * unless _use_blueprint_restrictions_by_object_type_ is enabled.
         * See the {api:Blueprint_Courses:BlueprintRestriction Blueprint Restriction} documentation
         */
        'course[blueprint_restrictions]'?: unknown;
        /**
         * Allows setting multiple {api:Blueprint_Courses:BlueprintRestriction Blueprint Restriction}
         * to apply to blueprint course objects of the matching type when restricted.
         * The possible object types are "assignment", "attachment", "discussion_topic", "quiz" and "wiki_page".
         * Example usage:
         * course[blueprint_restrictions_by_object_type][assignment][content]=1
         */
        'course[blueprint_restrictions_by_object_type]'?: unknown;
        /**
         * The course code for the course.
         */
        'course[course_code]'?: string;
        /**
         * Optional. Specifies the format of the course. (Should be either 'on_campus' or 'online')
         */
        'course[course_format]'?: string;
        /**
         * The type of page that users will see when they first visit the course
         * * 'feed' Recent Activity Dashboard
         * * 'wiki' Wiki Front Page
         * * 'modules' Course Modules/Sections Page
         * * 'assignments' Course Assignments List
         * * 'syllabus' Course Syllabus Page
         * other types may be added in the future
         */
        'course[default_view]'?: 'feed' | 'wiki' | 'modules' | 'syllabus' | 'assignments';
        /**
         * Course end date in ISO8601 format. e.g. 2011-01-01T01:00Z
         */
        'course[end_at]'?: string;
        /**
         * The action to take on each course.
         * * 'claim' makes a course no longer visible to students. This action is also called "unpublish" on the web site.
         * A course cannot be unpublished if students have received graded submissions.
         * * 'offer' makes a course visible to students. This action is also called "publish" on the web site.
         * * 'conclude' prevents future enrollments and makes a course read-only for all participants. The course still appears
         * in prior-enrollment lists.
         * * 'delete' completely removes the course from the web site (including course menus and prior-enrollment lists).
         * All enrollments are deleted. Course content may be physically deleted at a future date.
         * * 'undelete' attempts to recover a course that has been deleted. (Recovery is not guaranteed; please conclude
         * rather than delete a course if there is any possibility the course will be used again.) The recovered course
         * will be unpublished. Deleted enrollments will not be recovered.
         */
        'course[event]'?: 'claim' | 'offer' | 'conclude' | 'delete' | 'undelete';
        /**
         * The grading standard id to set for the course.  If no value is provided for this argument the current grading_standard will be un-set from this course.
         */
        'course[grading_standard_id]'?: number;
        /**
         * If this option is set to true, the totals in student grades summary will
         * be hidden.
         */
        'course[hide_final_grades]'?: boolean;
        /**
         * This is a file ID corresponding to an image file in the course that will
         * be used as the course image.
         * This will clear the course's image_url setting if set.  If you attempt
         * to provide image_url and image_id in a request it will fail.
         */
        'course[image_id]'?: number;
        /**
         * This is a URL to an image to be used as the course image.
         * This will clear the course's image_id setting if set.  If you attempt
         * to provide image_url and image_id in a request it will fail.
         */
        'course[image_url]'?: string;
        /**
         * The unique Integration identifier.
         */
        'course[integration_id]'?: string;
        /**
         * Set to true if course is public to both authenticated and unauthenticated users.
         */
        'course[is_public]'?: boolean;
        /**
         * Set to true if course is public only to authenticated users.
         */
        'course[is_public_to_auth_users]'?: boolean;
        /**
         * The name of the licensing. Should be one of the following abbreviations
         * (a descriptive name is included in parenthesis for reference):
         * - 'private' (Private Copyrighted)
         * - 'cc_by_nc_nd' (CC Attribution Non-Commercial No Derivatives)
         * - 'cc_by_nc_sa' (CC Attribution Non-Commercial Share Alike)
         * - 'cc_by_nc' (CC Attribution Non-Commercial)
         * - 'cc_by_nd' (CC Attribution No Derivatives)
         * - 'cc_by_sa' (CC Attribution Share Alike)
         * - 'cc_by' (CC Attribution)
         * - 'public_domain' (Public Domain).
         */
        'course[license]'?: string;
        /**
         * The name of the course. If omitted, the course will be named "Unnamed
         * Course."
         */
        'course[name]'?: string;
        /**
         * Set to true if the course is open enrollment.
         */
        'course[open_enrollment]'?: boolean;
        /**
         * A publicly visible description of the course.
         */
        'course[public_description]'?: string;
        /**
         * Set to true to make the course syllabus public.
         */
        'course[public_syllabus]'?: boolean;
        /**
         * Set to true to make the course syllabus to public for authenticated users.
         */
        'course[public_syllabus_to_auth]'?: boolean;
        /**
         * If this option is set to true, the course image url and course image
         * ID are both set to nil
         */
        'course[remove_image]'?: boolean;
        /**
         * Set to true to restrict user enrollments to the start and end dates of the
         * course.
         */
        'course[restrict_enrollments_to_course_dates]'?: boolean;
        /**
         * Set to true if the course is self enrollment.
         */
        'course[self_enrollment]'?: boolean;
        /**
         * The unique SIS identifier.
         */
        'course[sis_course_id]'?: string;
        /**
         * Course start date in ISO8601 format, e.g. 2011-01-01T01:00Z
         */
        'course[start_at]'?: string;
        /**
         * Set the storage quota for the course, in megabytes. The caller must have
         * the "Manage storage quotas" account permission.
         */
        'course[storage_quota_mb]'?: number;
        /**
         * The syllabus body for the course
         */
        'course[syllabus_body]'?: string;
        /**
         * The unique ID of the term to create to course in.
         */
        'course[term_id]'?: number;
        /**
         * The time zone for the course. Allowed time zones are
         * {http://www.iana.org/time-zones IANA time zones} or friendlier
         * {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
         */
        'course[time_zone]'?: string;
        /**
         * When enabled, the _blueprint_restrictions_ parameter will be ignored in favor of
         * the _blueprint_restrictions_by_object_type_ parameter
         */
        'course[use_blueprint_restrictions_by_object_type]'?: boolean;
        /**
         * If this option is set to true, the course will be available to students
         * immediately.
         */
        offer?: boolean;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{id}';
};

export type UpdateCourseResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetLatePolicyData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{id}/late_policy';
};

export type GetLatePolicyResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type PatchLatePolicyData = {
    body?: {
        /**
         * How many percentage points to deduct per the late submission interval.
         */
        'late_policy[late_submission_deduction]'?: number;
        /**
         * Whether to enable the late submission deduction late policy.
         */
        'late_policy[late_submission_deduction_enabled]'?: boolean;
        /**
         * The interval for late policies.
         */
        'late_policy[late_submission_interval]'?: string;
        /**
         * The minimum grade a submissions can have in percentage points.
         */
        'late_policy[late_submission_minimum_percent]'?: number;
        /**
         * Whether to enable the late submission minimum percent for a late policy.
         */
        'late_policy[late_submission_minimum_percent_enabled]'?: boolean;
        /**
         * How many percentage points to deduct from a missing submission.
         */
        'late_policy[missing_submission_deduction]'?: number;
        /**
         * Whether to enable the missing submission deduction late policy.
         */
        'late_policy[missing_submission_deduction_enabled]'?: boolean;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{id}/late_policy';
};

export type PatchLatePolicyResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateLatePolicyData = {
    body?: {
        /**
         * How many percentage points to deduct per the late submission interval.
         */
        'late_policy[late_submission_deduction]'?: number;
        /**
         * Whether to enable the late submission deduction late policy.
         */
        'late_policy[late_submission_deduction_enabled]'?: boolean;
        /**
         * The interval for late policies.
         */
        'late_policy[late_submission_interval]'?: string;
        /**
         * The minimum grade a submissions can have in percentage points.
         */
        'late_policy[late_submission_minimum_percent]'?: number;
        /**
         * Whether to enable the late submission minimum percent for a late policy.
         */
        'late_policy[late_submission_minimum_percent_enabled]'?: boolean;
        /**
         * How many percentage points to deduct from a missing submission.
         */
        'late_policy[missing_submission_deduction]'?: number;
        /**
         * Whether to enable the missing submission deduction late policy.
         */
        'late_policy[missing_submission_deduction_enabled]'?: boolean;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/courses/{id}/late_policy';
};

export type CreateLatePolicyResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListCoursesWithTheirLatestEpubExportData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/epub_exports';
};

export type ListCoursesWithTheirLatestEpubExportResponses = {
    /**
     * No response was specified
     */
    200: Array<CourseEpubExport>;
};

export type ListCoursesWithTheirLatestEpubExportResponse = ListCoursesWithTheirLatestEpubExportResponses[keyof ListCoursesWithTheirLatestEpubExportResponses];

export type CreateErrorReportData = {
    body: {
        /**
         * The long version of the story from the user one what they experienced
         */
        'error[comments]'?: string;
        /**
         * Email address for the reporting user
         */
        'error[email]'?: string;
        /**
         * A collection of metadata about the users' environment.  If not provided,
         * canvas will collect it based on information found in the request.
         * (Doesn't have to be HTTPENV info, could be anything JSON object that can be
         * serialized as a hash, a mobile app might include relevant metadata for
         * itself)
         */
        'error[http_env]'?: unknown;
        /**
         * The summary of the problem
         */
        'error[subject]': string;
        /**
         * URL from which the report was issued
         */
        'error[url]'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/error_reports';
};

export type CreateErrorReportResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteFileData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * This action is irreversible.
         * If replace is set to true the file contents will be replaced with a
         * generic "file has been removed" file. This also destroys any previews
         * that have been generated for the file.
         * Must have manage files and become other users permissions
         */
        replace?: boolean;
    };
    url: '/v1/files/{id}';
};

export type DeleteFileResponses = {
    /**
     * No response was specified
     */
    200: File;
};

export type DeleteFileResponse = DeleteFileResponses[keyof DeleteFileResponses];

export type GetFileFilesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Array of additional information to include.
         *
         * "user":: the user who uploaded the file or last edited its content
         * "usage_rights":: copyright and license information for the file (see UsageRights)
         */
        include?: Array<'user'>;
    };
    url: '/v1/files/{id}';
};

export type GetFileFilesResponses = {
    /**
     * No response was specified
     */
    200: File;
};

export type GetFileFilesResponse = GetFileFilesResponses[keyof GetFileFilesResponses];

export type UpdateFileData = {
    body?: {
        /**
         * Flag the file as hidden
         */
        hidden?: boolean;
        /**
         * The datetime to lock the file at
         */
        lock_at?: string;
        /**
         * Flag the file as locked
         */
        locked?: boolean;
        /**
         * The new display name of the file
         */
        name?: string;
        /**
         * If the file is moved to a folder containing a file with the same name,
         * or renamed to a name matching an existing file, the API call will fail
         * unless this parameter is supplied.
         *
         * "overwrite":: Replace the existing file with the same name
         * "rename":: Add a qualifier to make the new filename unique
         */
        on_duplicate?: 'overwrite' | 'rename';
        /**
         * The id of the folder to move this file into.
         * The new folder must be in the same context as the original parent folder.
         * If the file is in a context without folders this does not apply.
         */
        parent_folder_id?: string;
        /**
         * The datetime to unlock the file at
         */
        unlock_at?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/files/{id}';
};

export type UpdateFileResponses = {
    /**
     * No response was specified
     */
    200: File;
};

export type UpdateFileResponse = UpdateFileResponses[keyof UpdateFileResponses];

export type GetPublicInlinePreviewUrlData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * The id of the submission the file is associated with.  Provide this argument to gain access to a file
         * that has been submitted to an assignment (Canvas will verify that the file belongs to the submission
         * and the calling user has rights to view the submission).
         */
        submission_id?: number;
    };
    url: '/v1/files/{id}/public_url';
};

export type GetPublicInlinePreviewUrlResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CopyFileData = {
    body: {
        /**
         * What to do if a file with the same name already exists at the destination.
         * If such a file exists and this parameter is not given, the call will fail.
         *
         * "overwrite":: Replace an existing file with the same name
         * "rename":: Add a qualifier to make the new filename unique
         */
        on_duplicate?: 'overwrite' | 'rename';
        /**
         * The id of the source file
         */
        source_file_id: string;
    };
    path: {
        /**
         * ID
         */
        dest_folder_id: string;
    };
    query?: never;
    url: '/v1/folders/{dest_folder_id}/copy_file';
};

export type CopyFileResponses = {
    /**
     * No response was specified
     */
    200: File;
};

export type CopyFileResponse = CopyFileResponses[keyof CopyFileResponses];

export type CopyFolderData = {
    body: {
        /**
         * The id of the source folder
         */
        source_folder_id: string;
    };
    path: {
        /**
         * ID
         */
        dest_folder_id: string;
    };
    query?: never;
    url: '/v1/folders/{dest_folder_id}/copy_folder';
};

export type CopyFolderResponses = {
    /**
     * No response was specified
     */
    200: Folder;
};

export type CopyFolderResponse = CopyFolderResponses[keyof CopyFolderResponses];

export type UploadFileToFolderData = {
    body?: never;
    path: {
        /**
         * ID
         */
        folder_id: string;
    };
    query?: never;
    url: '/v1/folders/{folder_id}/files';
};

export type UploadFileToFolderResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateFolderFoldersData = {
    body: {
        /**
         * Flag the folder as hidden
         */
        hidden?: boolean;
        /**
         * The datetime to lock the folder at
         */
        lock_at?: string;
        /**
         * Flag the folder as locked
         */
        locked?: boolean;
        /**
         * The name of the folder
         */
        name: string;
        /**
         * The id of the folder to store the file in. If this and parent_folder_path are sent an error will be returned. If neither is given, a default folder will be used.
         */
        parent_folder_id?: string;
        /**
         * The path of the folder to store the new folder in. The path separator is the forward slash `/`, never a back slash. The parent folder will be created if it does not already exist. This parameter only applies to new folders in a context that has folders, such as a user, a course, or a group. If this and parent_folder_id are sent an error will be returned. If neither is given, a default folder will be used.
         */
        parent_folder_path?: string;
        /**
         * Set an explicit sort position for the folder
         */
        position?: number;
        /**
         * The datetime to unlock the folder at
         */
        unlock_at?: string;
    };
    path: {
        /**
         * ID
         */
        folder_id: string;
    };
    query?: never;
    url: '/v1/folders/{folder_id}/folders';
};

export type CreateFolderFoldersResponses = {
    /**
     * No response was specified
     */
    200: Folder;
};

export type CreateFolderFoldersResponse = CreateFolderFoldersResponses[keyof CreateFolderFoldersResponses];

export type DeleteFolderData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Set to 'true' to allow deleting a non-empty folder
         */
        force?: boolean;
    };
    url: '/v1/folders/{id}';
};

export type DeleteFolderResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetFolderFoldersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/folders/{id}';
};

export type GetFolderFoldersResponses = {
    /**
     * No response was specified
     */
    200: Folder;
};

export type GetFolderFoldersResponse = GetFolderFoldersResponses[keyof GetFolderFoldersResponses];

export type UpdateFolderData = {
    body?: {
        /**
         * Flag the folder as hidden
         */
        hidden?: boolean;
        /**
         * The datetime to lock the folder at
         */
        lock_at?: string;
        /**
         * Flag the folder as locked
         */
        locked?: boolean;
        /**
         * The new name of the folder
         */
        name?: string;
        /**
         * The id of the folder to move this folder into. The new folder must be in the same context as the original parent folder.
         */
        parent_folder_id?: string;
        /**
         * Set an explicit sort position for the folder
         */
        position?: number;
        /**
         * The datetime to unlock the folder at
         */
        unlock_at?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/folders/{id}';
};

export type UpdateFolderResponses = {
    /**
     * No response was specified
     */
    200: Folder;
};

export type UpdateFolderResponse = UpdateFolderResponses[keyof UpdateFolderResponses];

export type ListFilesFoldersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Filter results by content-type. You can specify type/subtype pairs (e.g.,
         * 'image/jpeg'), or simply types (e.g., 'image', which will match
         * 'image/gif', 'image/jpeg', etc.).
         */
        content_types?: Array<string>;
        /**
         * The partial name of the files to match and return.
         */
        search_term?: string;
        /**
         * Array of additional information to include.
         *
         * "user":: the user who uploaded the file or last edited its content
         * "usage_rights":: copyright and license information for the file (see UsageRights)
         */
        include?: Array<'user'>;
        /**
         * Array of information to restrict to. Overrides include[]
         *
         * "names":: only returns file name information
         */
        only?: Array<Array<{
            [key: string]: unknown;
        }>>;
        /**
         * Sort results by this field. Defaults to 'name'. Note that `sort=user` implies `include[]=user`.
         */
        sort?: 'name' | 'size' | 'created_at' | 'updated_at' | 'content_type' | 'user';
        /**
         * The sorting order. Defaults to 'asc'.
         */
        order?: 'asc' | 'desc';
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/folders/{id}/files';
};

export type ListFilesFoldersResponses = {
    /**
     * No response was specified
     */
    200: Array<File>;
};

export type ListFilesFoldersResponse = ListFilesFoldersResponses[keyof ListFilesFoldersResponses];

export type ListFoldersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/folders/{id}/folders';
};

export type ListFoldersResponses = {
    /**
     * No response was specified
     */
    200: Array<Folder>;
};

export type ListFoldersResponse = ListFoldersResponses[keyof ListFoldersResponses];

export type DeleteOutcomeGroupGlobalData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/global/outcome_groups/{id}';
};

export type DeleteOutcomeGroupGlobalResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type DeleteOutcomeGroupGlobalResponse = DeleteOutcomeGroupGlobalResponses[keyof DeleteOutcomeGroupGlobalResponses];

export type ShowOutcomeGroupGlobalData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/global/outcome_groups/{id}';
};

export type ShowOutcomeGroupGlobalResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type ShowOutcomeGroupGlobalResponse = ShowOutcomeGroupGlobalResponses[keyof ShowOutcomeGroupGlobalResponses];

export type UpdateOutcomeGroupGlobalData = {
    body?: {
        /**
         * The new outcome group description.
         */
        description?: string;
        /**
         * The id of the new parent outcome group.
         */
        parent_outcome_group_id?: number;
        /**
         * The new outcome group title.
         */
        title?: string;
        /**
         * A custom GUID for the learning standard.
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/global/outcome_groups/{id}';
};

export type UpdateOutcomeGroupGlobalResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type UpdateOutcomeGroupGlobalResponse = UpdateOutcomeGroupGlobalResponses[keyof UpdateOutcomeGroupGlobalResponses];

export type ImportOutcomeGroupGlobalData = {
    body: {
        /**
         * If true, perform action asynchronously.  In that case, this endpoint
         * will return a Progress object instead of an OutcomeGroup.
         * Use the {api:ProgressController#show progress endpoint}
         * to query the status of the operation.  The imported outcome group id
         * and url will be returned in the results of the Progress object
         * as "outcome_group_id" and "outcome_group_url"
         */
        async?: boolean;
        /**
         * The ID of the source outcome group.
         */
        source_outcome_group_id: number;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/global/outcome_groups/{id}/import';
};

export type ImportOutcomeGroupGlobalResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type ImportOutcomeGroupGlobalResponse = ImportOutcomeGroupGlobalResponses[keyof ImportOutcomeGroupGlobalResponses];

export type ListLinkedOutcomesGlobalData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * The detail level of the outcomes. Defaults to "abbrev".
         * Specify "full" for more information.
         */
        outcome_style?: string;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/global/outcome_groups/{id}/outcomes';
};

export type ListLinkedOutcomesGlobalResponses = {
    /**
     * No response was specified
     */
    200: Array<OutcomeLink>;
};

export type ListLinkedOutcomesGlobalResponse = ListLinkedOutcomesGlobalResponses[keyof ListLinkedOutcomesGlobalResponses];

export type CreateLinkOutcomeGlobalData = {
    body?: {
        /**
         * The new calculation int.  Only applies if the calculation_method is "decaying_average" or "n_mastery"
         */
        calculation_int?: number;
        /**
         * The new calculation method.  Defaults to "highest"
         */
        calculation_method?: 'decaying_average' | 'n_mastery' | 'latest' | 'highest';
        /**
         * The description of the new outcome.
         */
        description?: string;
        /**
         * A friendly name shown in reports for outcomes with cryptic titles,
         * such as common core standards names.
         */
        display_name?: string;
        /**
         * The mastery threshold for the embedded rubric criterion.
         */
        mastery_points?: number;
        /**
         * The ID of the old outcome group. Only used if outcome_id is present.
         */
        move_from?: number;
        /**
         * The ID of the existing outcome to link.
         */
        outcome_id?: number;
        /**
         * The description of a rating level for the embedded rubric criterion.
         */
        'ratings[description]'?: Array<string>;
        /**
         * The points corresponding to a rating level for the embedded rubric criterion.
         */
        'ratings[points]'?: Array<number>;
        /**
         * The title of the new outcome. Required if outcome_id is absent.
         */
        title?: string;
        /**
         * A custom GUID for the learning standard.
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/global/outcome_groups/{id}/outcomes';
};

export type CreateLinkOutcomeGlobalResponses = {
    /**
     * No response was specified
     */
    200: OutcomeLink;
};

export type CreateLinkOutcomeGlobalResponse = CreateLinkOutcomeGlobalResponses[keyof CreateLinkOutcomeGlobalResponses];

export type UnlinkOutcomeGlobalData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
        /**
         * ID
         */
        outcome_id: string;
    };
    query?: never;
    url: '/v1/global/outcome_groups/{id}/outcomes/{outcome_id}';
};

export type UnlinkOutcomeGlobalResponses = {
    /**
     * No response was specified
     */
    200: OutcomeLink;
};

export type UnlinkOutcomeGlobalResponse = UnlinkOutcomeGlobalResponses[keyof UnlinkOutcomeGlobalResponses];

export type CreateLinkOutcomeGlobalOutcomeIdData = {
    body?: {
        /**
         * The new calculation int.  Only applies if the calculation_method is "decaying_average" or "n_mastery"
         */
        calculation_int?: number;
        /**
         * The new calculation method.  Defaults to "highest"
         */
        calculation_method?: 'decaying_average' | 'n_mastery' | 'latest' | 'highest';
        /**
         * The description of the new outcome.
         */
        description?: string;
        /**
         * A friendly name shown in reports for outcomes with cryptic titles,
         * such as common core standards names.
         */
        display_name?: string;
        /**
         * The mastery threshold for the embedded rubric criterion.
         */
        mastery_points?: number;
        /**
         * The ID of the old outcome group. Only used if outcome_id is present.
         */
        move_from?: number;
        /**
         * The description of a rating level for the embedded rubric criterion.
         */
        'ratings[description]'?: Array<string>;
        /**
         * The points corresponding to a rating level for the embedded rubric criterion.
         */
        'ratings[points]'?: Array<number>;
        /**
         * The title of the new outcome. Required if outcome_id is absent.
         */
        title?: string;
        /**
         * A custom GUID for the learning standard.
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
        /**
         * The ID of the existing outcome to link.
         */
        outcome_id: number;
    };
    query?: never;
    url: '/v1/global/outcome_groups/{id}/outcomes/{outcome_id}';
};

export type CreateLinkOutcomeGlobalOutcomeIdResponses = {
    /**
     * No response was specified
     */
    200: OutcomeLink;
};

export type CreateLinkOutcomeGlobalOutcomeIdResponse = CreateLinkOutcomeGlobalOutcomeIdResponses[keyof CreateLinkOutcomeGlobalOutcomeIdResponses];

export type ListSubgroupsGlobalData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/global/outcome_groups/{id}/subgroups';
};

export type ListSubgroupsGlobalResponses = {
    /**
     * No response was specified
     */
    200: Array<OutcomeGroup>;
};

export type ListSubgroupsGlobalResponse = ListSubgroupsGlobalResponses[keyof ListSubgroupsGlobalResponses];

export type CreateSubgroupGlobalData = {
    body: {
        /**
         * The description of the new outcome group.
         */
        description?: string;
        /**
         * The title of the new outcome group.
         */
        title: string;
        /**
         * A custom GUID for the learning standard
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/global/outcome_groups/{id}/subgroups';
};

export type CreateSubgroupGlobalResponses = {
    /**
     * No response was specified
     */
    200: OutcomeGroup;
};

export type CreateSubgroupGlobalResponse = CreateSubgroupGlobalResponses[keyof CreateSubgroupGlobalResponses];

export type RedirectToRootOutcomeGroupForContextGlobalData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/global/root_outcome_group';
};

export type RedirectToRootOutcomeGroupForContextGlobalResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteGroupCategoryData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_category_id: string;
    };
    query?: never;
    url: '/v1/group_categories/{group_category_id}';
};

export type DeleteGroupCategoryResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleGroupCategoryData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_category_id: string;
    };
    query?: never;
    url: '/v1/group_categories/{group_category_id}';
};

export type GetSingleGroupCategoryResponses = {
    /**
     * No response was specified
     */
    200: GroupCategory;
};

export type GetSingleGroupCategoryResponse = GetSingleGroupCategoryResponses[keyof GetSingleGroupCategoryResponses];

export type UpdateGroupCategoryData = {
    body?: {
        /**
         * Assigns group leaders automatically when generating and allocating students to groups
         * Valid values are:
         * "first":: the first student to be allocated to a group is the leader
         * "random":: a random student from all members is chosen as the leader
         */
        auto_leader?: 'first' | 'random';
        /**
         * Create this number of groups (Course Only).
         */
        create_group_count?: number;
        /**
         * Limit the maximum number of users in each group (Course Only). Requires
         * self signup.
         */
        group_limit?: number;
        /**
         * Name of the group category
         */
        name?: string;
        /**
         * Allow students to sign up for a group themselves (Course Only).
         * Valid values are:
         * "enabled":: allows students to self sign up for any group in course
         * "restricted":: allows students to self sign up only for groups in the
         * same section null disallows self sign up
         */
        self_signup?: 'enabled' | 'restricted';
        /**
         * The unique SIS identifier.
         */
        sis_group_category_id?: string;
        /**
         * (Deprecated)
         * Create this number of groups, and evenly distribute students
         * among them. not allowed with "enable_self_signup". because
         * the group assignment happens synchronously, it's recommended
         * that you instead use the assign_unassigned_members endpoint.
         * (Course Only)
         */
        split_group_count?: string;
    };
    path: {
        /**
         * ID
         */
        group_category_id: string;
    };
    query?: never;
    url: '/v1/group_categories/{group_category_id}';
};

export type UpdateGroupCategoryResponses = {
    /**
     * No response was specified
     */
    200: GroupCategory;
};

export type UpdateGroupCategoryResponse = UpdateGroupCategoryResponses[keyof UpdateGroupCategoryResponses];

export type AssignUnassignedMembersData = {
    body?: {
        /**
         * The assigning is done asynchronously by default. If you would like to
         * override this and have the assigning done synchronously, set this value
         * to true.
         */
        sync?: boolean;
    };
    path: {
        /**
         * ID
         */
        group_category_id: string;
    };
    query?: never;
    url: '/v1/group_categories/{group_category_id}/assign_unassigned_members';
};

export type AssignUnassignedMembersResponses = {
    /**
     * No response was specified
     */
    200: GroupMembership;
};

export type AssignUnassignedMembersResponse = AssignUnassignedMembersResponses[keyof AssignUnassignedMembersResponses];

export type CreateGroupGroupCategoriesData = {
    body?: {
        /**
         * A description of the group
         */
        description?: string;
        /**
         * whether the group is public (applies only to community groups)
         */
        is_public?: boolean;
        /**
         * no description
         */
        join_level?: 'parent_context_auto_join' | 'parent_context_request' | 'invitation_only';
        /**
         * The name of the group
         */
        name?: string;
        /**
         * The sis ID of the group. Must have manage_sis permission to set.
         */
        sis_group_id?: string;
        /**
         * The allowed file storage for the group, in megabytes. This parameter is
         * ignored if the caller does not have the manage_storage_quotas permission.
         */
        storage_quota_mb?: number;
    };
    path: {
        /**
         * ID
         */
        group_category_id: string;
    };
    query?: never;
    url: '/v1/group_categories/{group_category_id}/groups';
};

export type CreateGroupGroupCategoriesResponses = {
    /**
     * No response was specified
     */
    200: Group;
};

export type CreateGroupGroupCategoriesResponse = CreateGroupGroupCategoriesResponses[keyof CreateGroupGroupCategoriesResponses];

export type ListUsersInGroupCategoryData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_category_id: string;
    };
    query?: {
        /**
         * The partial name or full ID of the users to match and return in the results
         * list. Must be at least 3 characters.
         */
        search_term?: string;
        /**
         * Set this value to true if you wish only to search unassigned users in the
         * group category.
         */
        unassigned?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/group_categories/{group_category_id}/users';
};

export type ListUsersInGroupCategoryResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type ListUsersInGroupCategoryResponse = ListUsersInGroupCategoryResponses[keyof ListUsersInGroupCategoryResponses];

export type CreateGroupGroupsData = {
    body?: {
        /**
         * A description of the group
         */
        description?: string;
        /**
         * whether the group is public (applies only to community groups)
         */
        is_public?: boolean;
        /**
         * no description
         */
        join_level?: 'parent_context_auto_join' | 'parent_context_request' | 'invitation_only';
        /**
         * The name of the group
         */
        name?: string;
        /**
         * The sis ID of the group. Must have manage_sis permission to set.
         */
        sis_group_id?: string;
        /**
         * The allowed file storage for the group, in megabytes. This parameter is
         * ignored if the caller does not have the manage_storage_quotas permission.
         */
        storage_quota_mb?: number;
    };
    path?: never;
    query?: never;
    url: '/v1/groups';
};

export type CreateGroupGroupsResponses = {
    /**
     * No response was specified
     */
    200: Group;
};

export type CreateGroupGroupsResponse = CreateGroupGroupsResponses[keyof CreateGroupGroupsResponses];

export type DeleteGroupData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}';
};

export type DeleteGroupResponses = {
    /**
     * No response was specified
     */
    200: Group;
};

export type DeleteGroupResponse = DeleteGroupResponses[keyof DeleteGroupResponses];

export type GetSingleGroupData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * - "permissions": Include permissions the current user has
         * for the group.
         * - "tabs": Include the list of tabs configured for each group.  See the
         * {api:TabsController#index List available tabs API} for more information.
         */
        include?: Array<'permissions' | 'tabs'>;
    };
    url: '/v1/groups/{group_id}';
};

export type GetSingleGroupResponses = {
    /**
     * No response was specified
     */
    200: Group;
};

export type GetSingleGroupResponse = GetSingleGroupResponses[keyof GetSingleGroupResponses];

export type EditGroupData = {
    body?: {
        /**
         * The id of the attachment previously uploaded to the group that you would
         * like to use as the avatar image for this group.
         */
        avatar_id?: number;
        /**
         * A description of the group
         */
        description?: string;
        /**
         * Whether the group is public (applies only to community groups). Currently
         * you cannot set a group back to private once it has been made public.
         */
        is_public?: boolean;
        /**
         * no description
         */
        join_level?: 'parent_context_auto_join' | 'parent_context_request' | 'invitation_only';
        /**
         * An array of user ids for users you would like in the group.
         * Users not in the group will be sent invitations. Existing group
         * members who aren't in the list will be removed from the group.
         */
        members?: Array<string>;
        /**
         * The name of the group
         */
        name?: string;
        /**
         * The sis ID of the group. Must have manage_sis permission to set.
         */
        sis_group_id?: string;
        /**
         * The allowed file storage for the group, in megabytes. This parameter is
         * ignored if the caller does not have the manage_storage_quotas permission.
         */
        storage_quota_mb?: number;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}';
};

export type EditGroupResponses = {
    /**
     * No response was specified
     */
    200: Group;
};

export type EditGroupResponse = EditGroupResponses[keyof EditGroupResponses];

export type GroupActivityStreamData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/activity_stream';
};

export type GroupActivityStreamResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GroupActivityStreamSummaryData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/activity_stream/summary';
};

export type GroupActivityStreamSummaryResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type RedirectToAssignmentOverrideForGroupData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/assignments/{assignment_id}/override';
};

export type RedirectToAssignmentOverrideForGroupResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListCollaborationsGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/collaborations';
};

export type ListCollaborationsGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<Collaboration>;
};

export type ListCollaborationsGroupsResponse = ListCollaborationsGroupsResponses[keyof ListCollaborationsGroupsResponses];

export type ListConferencesGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/conferences';
};

export type ListConferencesGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<Conference>;
};

export type ListConferencesGroupsResponse = ListConferencesGroupsResponses[keyof ListConferencesGroupsResponses];

export type ListContentExportsGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/content_exports';
};

export type ListContentExportsGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<ContentExport>;
};

export type ListContentExportsGroupsResponse = ListContentExportsGroupsResponses[keyof ListContentExportsGroupsResponses];

export type ExportContentGroupsData = {
    body: {
        /**
         * "common_cartridge":: Export the contents of the course in the Common Cartridge (.imscc) format
         * "qti":: Export quizzes from a course in the QTI format
         * "zip":: Export files from a course, group, or user in a zip file
         */
        export_type: 'common_cartridge' | 'qti' | 'zip';
        /**
         * The select parameter allows exporting specific data. The keys are object types like 'files',
         * 'folders', 'pages', etc. The value for each key is a list of object ids. An id can be an
         * integer or a string.
         *
         * Multiple object types can be selected in the same call. However, not all object types are
         * valid for every export_type. Common Cartridge supports all object types. Zip and QTI only
         * support the object types as described below.
         *
         * "folders":: Also supported for zip export_type.
         * "files":: Also supported for zip export_type.
         * "quizzes":: Also supported for qti export_type.
         */
        select?: 'folders' | 'files' | 'attachments' | 'quizzes' | 'assignments' | 'announcements' | 'calendar_events' | 'discussion_topics' | 'modules' | 'module_items' | 'pages' | 'rubrics';
        /**
         * Don't send the notifications about the export to the user. Default: false
         */
        skip_notifications?: boolean;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/content_exports';
};

export type ExportContentGroupsResponses = {
    /**
     * No response was specified
     */
    200: ContentExport;
};

export type ExportContentGroupsResponse = ExportContentGroupsResponses[keyof ExportContentGroupsResponses];

export type ShowContentExportGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/content_exports/{id}';
};

export type ShowContentExportGroupsResponses = {
    /**
     * No response was specified
     */
    200: ContentExport;
};

export type ShowContentExportGroupsResponse = ShowContentExportGroupsResponses[keyof ShowContentExportGroupsResponses];

export type ListLicensesGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/content_licenses';
};

export type ListLicensesGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<License>;
};

export type ListLicensesGroupsResponse = ListLicensesGroupsResponses[keyof ListLicensesGroupsResponses];

export type ListContentMigrationsGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/content_migrations';
};

export type ListContentMigrationsGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<ContentMigration>;
};

export type ListContentMigrationsGroupsResponse = ListContentMigrationsGroupsResponses[keyof ListContentMigrationsGroupsResponses];

export type CreateContentMigrationGroupsData = {
    body: {
        /**
         * Move anything scheduled for day 'X' to the specified day. (0-Sunday,
         * 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
         */
        'date_shift_options[day_substitutions][X]'?: number;
        /**
         * The new end date for the source content/course
         */
        'date_shift_options[new_end_date]'?: string;
        /**
         * The new start date for the content/course
         */
        'date_shift_options[new_start_date]'?: string;
        /**
         * The original end date of the source content/course
         */
        'date_shift_options[old_end_date]'?: string;
        /**
         * The original start date of the source content/course
         */
        'date_shift_options[old_start_date]'?: string;
        /**
         * Whether to remove dates in the copied course. Cannot be used
         * in conjunction with *shift_dates*.
         */
        'date_shift_options[remove_dates]'?: boolean;
        /**
         * Whether to shift dates in the copied course
         */
        'date_shift_options[shift_dates]'?: boolean;
        /**
         * The type of the migration. Use the
         * {api:ContentMigrationsController#available_migrators Migrator} endpoint to
         * see all available migrators. Default allowed values:
         * canvas_cartridge_importer, common_cartridge_importer,
         * course_copy_importer, zip_file_importer, qti_converter, moodle_converter
         */
        migration_type: string;
        /**
         * Required if uploading a file. This is the first step in uploading a file
         * to the content migration. See the {file:file_uploads.html File Upload
         * Documentation} for details on the file upload workflow.
         */
        'pre_attachment[name]'?: string;
        /**
         * Other file upload properties, See {file:file_uploads.html File Upload
         * Documentation}
         */
        'pre_attachment[todo]'?: string;
        /**
         * A URL to download the file from. Must not require authentication.
         */
        'settings[file_url]'?: string;
        /**
         * The folder to unzip the .zip file into for a zip_file_import.
         */
        'settings[folder_id]'?: string;
        /**
         * Whether to overwrite quizzes with the same identifiers between content
         * packages.
         */
        'settings[overwrite_quizzes]'?: boolean;
        /**
         * The existing question bank ID to import questions into if not specified in
         * the content package.
         */
        'settings[question_bank_id]'?: number;
        /**
         * The question bank to import questions into if not specified in the content
         * package, if both bank id and name are set, id will take precedence.
         */
        'settings[question_bank_name]'?: string;
        /**
         * The course to copy from for a course copy migration. (required if doing
         * course copy)
         */
        'settings[source_course_id]'?: string;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/content_migrations';
};

export type CreateContentMigrationGroupsResponses = {
    /**
     * No response was specified
     */
    200: ContentMigration;
};

export type CreateContentMigrationGroupsResponse = CreateContentMigrationGroupsResponses[keyof CreateContentMigrationGroupsResponses];

export type ListMigrationSystemsGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/content_migrations/migrators';
};

export type ListMigrationSystemsGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<Migrator>;
};

export type ListMigrationSystemsGroupsResponse = ListMigrationSystemsGroupsResponses[keyof ListMigrationSystemsGroupsResponses];

export type ListMigrationIssuesGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        content_migration_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/content_migrations/{content_migration_id}/migration_issues';
};

export type ListMigrationIssuesGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<MigrationIssue>;
};

export type ListMigrationIssuesGroupsResponse = ListMigrationIssuesGroupsResponses[keyof ListMigrationIssuesGroupsResponses];

export type GetMigrationIssueGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        content_migration_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/content_migrations/{content_migration_id}/migration_issues/{id}';
};

export type GetMigrationIssueGroupsResponses = {
    /**
     * No response was specified
     */
    200: MigrationIssue;
};

export type GetMigrationIssueGroupsResponse = GetMigrationIssueGroupsResponses[keyof GetMigrationIssueGroupsResponses];

export type UpdateMigrationIssueGroupsData = {
    body: {
        /**
         * Set the workflow_state of the issue.
         */
        workflow_state: 'active' | 'resolved';
    };
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        content_migration_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/content_migrations/{content_migration_id}/migration_issues/{id}';
};

export type UpdateMigrationIssueGroupsResponses = {
    /**
     * No response was specified
     */
    200: MigrationIssue;
};

export type UpdateMigrationIssueGroupsResponse = UpdateMigrationIssueGroupsResponses[keyof UpdateMigrationIssueGroupsResponses];

export type GetContentMigrationGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/content_migrations/{id}';
};

export type GetContentMigrationGroupsResponses = {
    /**
     * No response was specified
     */
    200: ContentMigration;
};

export type GetContentMigrationGroupsResponse = GetContentMigrationGroupsResponses[keyof GetContentMigrationGroupsResponses];

export type UpdateContentMigrationGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/content_migrations/{id}';
};

export type UpdateContentMigrationGroupsResponses = {
    /**
     * No response was specified
     */
    200: ContentMigration;
};

export type UpdateContentMigrationGroupsResponse = UpdateContentMigrationGroupsResponses[keyof UpdateContentMigrationGroupsResponses];

export type ListDiscussionTopicsGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * If "all_dates" is passed, all dates associated with graded discussions'
         * assignments will be included.
         * if "sections" is passed, includes the course sections that are associated
         * with the topic, if the topic is specific to certain sections of the course.
         * If "sections_user_count" is passed, then:
         * (a) If sections were asked for *and* the topic is specific to certain
         * course sections, includes the number of users in each
         * section. (as part of the section json asked for above)
         * (b) Else, includes at the root level the total number of users in the
         * topic's context (group or course) that the topic applies to.
         * If "overrides" is passed, the overrides for the assignment will be included
         */
        include?: Array<'all_dates' | 'sections' | 'sections_user_count' | 'overrides'>;
        /**
         * Determines the order of the discussion topic list. Defaults to "position".
         */
        order_by?: 'position' | 'recent_activity' | 'title';
        /**
         * Only return discussion topics in the given state(s). Defaults to including
         * all topics. Filtering is done after pagination, so pages
         * may be smaller than requested if topics are filtered.
         * Can pass multiple states as comma separated string.
         */
        scope?: 'locked' | 'unlocked' | 'pinned' | 'unpinned';
        /**
         * Return announcements instead of discussion topics. Defaults to false
         */
        only_announcements?: boolean;
        /**
         * The state of the discussion topic to return. Currently only supports unread state.
         */
        filter_by?: 'all' | 'unread';
        /**
         * The partial title of the discussion topics to match and return.
         */
        search_term?: string;
        /**
         * For students, exclude topics that are locked by module progression.
         * Defaults to false.
         */
        exclude_context_module_locked_topics?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/discussion_topics';
};

export type ListDiscussionTopicsGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<DiscussionTopic>;
};

export type ListDiscussionTopicsGroupsResponse = ListDiscussionTopicsGroupsResponses[keyof ListDiscussionTopicsGroupsResponses];

export type CreateNewDiscussionTopicGroupsData = {
    body?: {
        /**
         * Whether or not users can rate entries in this topic.
         */
        allow_rating?: boolean;
        /**
         * To create an assignment discussion, pass the assignment parameters as a
         * sub-object. See the {api:AssignmentsApiController#create Create an Assignment API}
         * for the available parameters. The name parameter will be ignored, as it's
         * taken from the discussion title. If you want to make a discussion that was
         * an assignment NOT an assignment, pass set_assignment = false as part of
         * the assignment object
         */
        assignment?: unknown;
        /**
         * A application/x-www-form-urlencoded form-field-style attachment.
         * Attachments larger than 1 kilobyte are subject to quota restrictions.
         */
        attachment?: Blob | File;
        /**
         * If a timestamp is given, the topic will not be published until that time.
         */
        delayed_post_at?: string;
        /**
         * The type of discussion. Defaults to side_comment if not value is given. Accepted values are 'side_comment', for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
         */
        discussion_type?: 'side_comment' | 'threaded';
        /**
         * If present, the topic will become a group discussion assigned
         * to the group.
         */
        group_category_id?: number;
        /**
         * If true, this topic is an announcement. It will appear in the
         * announcement's section rather than the discussions section. This requires
         * announcment-posting permissions.
         */
        is_announcement?: boolean;
        /**
         * If a timestamp is given, the topic will be scheduled to lock at the
         * provided timestamp. If the timestamp is in the past, the topic will be
         * locked.
         */
        lock_at?: string;
        /**
         * no description
         */
        message?: string;
        /**
         * If true, only graders will be allowed to rate entries.
         */
        only_graders_can_rate?: boolean;
        /**
         * If true, this topic will be listed in the "Pinned Discussion" section
         */
        pinned?: boolean;
        /**
         * If true, the topic will have an associated podcast feed.
         */
        podcast_enabled?: boolean;
        /**
         * If true, the podcast will include posts from students as well. Implies
         * podcast_enabled.
         */
        podcast_has_student_posts?: boolean;
        /**
         * By default, discussions are sorted chronologically by creation date, you
         * can pass the id of another topic to have this one show up after the other
         * when they are listed.
         */
        position_after?: string;
        /**
         * Whether this topic is published (true) or draft state (false). Only
         * teachers and TAs have the ability to create draft state topics.
         */
        published?: boolean;
        /**
         * If true then a user may not respond to other replies until that user has
         * made an initial reply. Defaults to false.
         */
        require_initial_post?: boolean;
        /**
         * If true, entries will be sorted by rating.
         */
        sort_by_rating?: boolean;
        /**
         * A comma-separated list of sections ids to which the discussion topic
         * should be made specific too.  If it is not desired to make the discussion
         * topic specific to sections, then this parameter may be omitted or set to
         * "all".  Can only be present only on announcements and only those that are
         * for a course (as opposed to a group).
         */
        specific_sections?: string;
        /**
         * no description
         */
        title?: string;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics';
};

export type CreateNewDiscussionTopicGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ReorderPinnedTopicsGroupsData = {
    body: {
        /**
         * The ids of the pinned discussion topics in the desired order.
         * (For example, "order=104,102,103".)
         */
        order: Array<number>;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/reorder';
};

export type ReorderPinnedTopicsGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteTopicGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}';
};

export type DeleteTopicGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleTopicGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: {
        /**
         * If "all_dates" is passed, all dates associated with graded discussions'
         * assignments will be included.
         * if "sections" is passed, includes the course sections that are associated
         * with the topic, if the topic is specific to certain sections of the course.
         * If "sections_user_count" is passed, then:
         * (a) If sections were asked for *and* the topic is specific to certain
         * course sections, includes the number of users in each
         * section. (as part of the section json asked for above)
         * (b) Else, includes at the root level the total number of users in the
         * topic's context (group or course) that the topic applies to.
         * If "overrides" is passed, the overrides for the assignment will be included
         */
        include?: Array<'all_dates' | 'sections' | 'sections_user_count' | 'overrides'>;
    };
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}';
};

export type GetSingleTopicGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateTopicGroupsData = {
    body?: {
        /**
         * If true, users will be allowed to rate entries.
         */
        allow_rating?: boolean;
        /**
         * To create an assignment discussion, pass the assignment parameters as a
         * sub-object. See the {api:AssignmentsApiController#create Create an Assignment API}
         * for the available parameters. The name parameter will be ignored, as it's
         * taken from the discussion title. If you want to make a discussion that was
         * an assignment NOT an assignment, pass set_assignment = false as part of
         * the assignment object
         */
        assignment?: unknown;
        /**
         * If a timestamp is given, the topic will not be published until that time.
         */
        delayed_post_at?: string;
        /**
         * The type of discussion. Defaults to side_comment if not value is given. Accepted values are 'side_comment', for discussions that only allow one level of nested comments, and 'threaded' for fully threaded discussions.
         */
        discussion_type?: 'side_comment' | 'threaded';
        /**
         * If present, the topic will become a group discussion assigned
         * to the group.
         */
        group_category_id?: number;
        /**
         * If true, this topic is an announcement. It will appear in the
         * announcement's section rather than the discussions section. This requires
         * announcment-posting permissions.
         */
        is_announcement?: boolean;
        /**
         * If a timestamp is given, the topic will be scheduled to lock at the
         * provided timestamp. If the timestamp is in the past, the topic will be
         * locked.
         */
        lock_at?: string;
        /**
         * no description
         */
        message?: string;
        /**
         * If true, only graders will be allowed to rate entries.
         */
        only_graders_can_rate?: boolean;
        /**
         * If true, this topic will be listed in the "Pinned Discussion" section
         */
        pinned?: boolean;
        /**
         * If true, the topic will have an associated podcast feed.
         */
        podcast_enabled?: boolean;
        /**
         * If true, the podcast will include posts from students as well. Implies
         * podcast_enabled.
         */
        podcast_has_student_posts?: boolean;
        /**
         * By default, discussions are sorted chronologically by creation date, you
         * can pass the id of another topic to have this one show up after the other
         * when they are listed.
         */
        position_after?: string;
        /**
         * Whether this topic is published (true) or draft state (false). Only
         * teachers and TAs have the ability to create draft state topics.
         */
        published?: boolean;
        /**
         * If true then a user may not respond to other replies until that user has
         * made an initial reply. Defaults to false.
         */
        require_initial_post?: boolean;
        /**
         * If true, entries will be sorted by rating.
         */
        sort_by_rating?: boolean;
        /**
         * A comma-separated list of sections ids to which the discussion topic
         * should be made specific too.  If it is not desired to make the discussion
         * topic specific to sections, then this parameter may be omitted or set to
         * "all".  Can only be present only on announcements and only those that are
         * for a course (as opposed to a group).
         */
        specific_sections?: string;
        /**
         * no description
         */
        title?: string;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}';
};

export type UpdateTopicGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListTopicEntriesGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries';
};

export type ListTopicEntriesGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type PostEntryGroupsData = {
    body?: {
        /**
         * a application/x-www-form-urlencoded form-field-style
         * attachment. Attachments larger than 1 kilobyte are subject to quota
         * restrictions.
         */
        attachment?: string;
        /**
         * The body of the entry.
         */
        message?: string;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries';
};

export type PostEntryGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type RateEntryGroupsData = {
    body?: {
        /**
         * A rating to set on this entry. Only 0 and 1 are accepted.
         */
        rating?: number;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        entry_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/rating';
};

export type RateEntryGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkEntryAsUnreadGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        entry_id: string;
    };
    query?: {
        /**
         * A boolean value to set the entry's forced_read_state. No change is made if
         * this argument is not specified.
         */
        forced_read_state?: boolean;
    };
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/read';
};

export type MarkEntryAsUnreadGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkEntryAsReadGroupsData = {
    body?: {
        /**
         * A boolean value to set the entry's forced_read_state. No change is made if
         * this argument is not specified.
         */
        forced_read_state?: boolean;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        entry_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/read';
};

export type MarkEntryAsReadGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListEntryRepliesGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        entry_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies';
};

export type ListEntryRepliesGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type PostReplyGroupsData = {
    body?: {
        /**
         * a application/x-www-form-urlencoded form-field-style
         * attachment. Attachments larger than 1 kilobyte are subject to quota
         * restrictions.
         */
        attachment?: string;
        /**
         * The body of the entry.
         */
        message?: string;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        entry_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies';
};

export type PostReplyGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteEntryGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{id}';
};

export type DeleteEntryGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateEntryGroupsData = {
    body?: {
        /**
         * The updated body of the entry.
         */
        message?: string;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{id}';
};

export type UpdateEntryGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListEntriesGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: {
        /**
         * A list of entry ids to retrieve. Entries will be returned in id order,
         * smallest id first.
         */
        ids?: Array<string>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/entry_list';
};

export type ListEntriesGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkTopicAsUnreadGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/read';
};

export type MarkTopicAsUnreadGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkTopicAsReadGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/read';
};

export type MarkTopicAsReadGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkAllEntriesAsUnreadGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: {
        /**
         * A boolean value to set all of the entries' forced_read_state. No change is
         * made if this argument is not specified.
         */
        forced_read_state?: boolean;
    };
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/read_all';
};

export type MarkAllEntriesAsUnreadGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkAllEntriesAsReadGroupsData = {
    body?: {
        /**
         * A boolean value to set all of the entries' forced_read_state. No change
         * is made if this argument is not specified.
         */
        forced_read_state?: boolean;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/read_all';
};

export type MarkAllEntriesAsReadGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UnsubscribeFromTopicGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/subscribed';
};

export type UnsubscribeFromTopicGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type SubscribeToTopicGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/subscribed';
};

export type SubscribeToTopicGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetFullTopicGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        topic_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/discussion_topics/{topic_id}/view';
};

export type GetFullTopicGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListExternalFeedsGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/external_feeds';
};

export type ListExternalFeedsGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<ExternalFeed>;
};

export type ListExternalFeedsGroupsResponse = ListExternalFeedsGroupsResponses[keyof ListExternalFeedsGroupsResponses];

export type CreateExternalFeedGroupsData = {
    body: {
        /**
         * If given, only feed entries that contain this string in their title will be imported
         */
        header_match?: boolean;
        /**
         * The url to the external rss or atom feed
         */
        url: string;
        /**
         * Defaults to "full"
         */
        verbosity?: 'full' | 'truncate' | 'link_only';
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/external_feeds';
};

export type CreateExternalFeedGroupsResponses = {
    /**
     * No response was specified
     */
    200: ExternalFeed;
};

export type CreateExternalFeedGroupsResponse = CreateExternalFeedGroupsResponses[keyof CreateExternalFeedGroupsResponses];

export type DeleteExternalFeedGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        external_feed_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/external_feeds/{external_feed_id}';
};

export type DeleteExternalFeedGroupsResponses = {
    /**
     * No response was specified
     */
    200: ExternalFeed;
};

export type DeleteExternalFeedGroupsResponse = DeleteExternalFeedGroupsResponses[keyof DeleteExternalFeedGroupsResponses];

export type ListExternalToolsGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * The partial name of the tools to match and return.
         */
        search_term?: string;
        /**
         * If true, then only tools that are meant to be selectable are returned
         */
        selectable?: boolean;
        /**
         * If true, then include tools installed in all accounts above the current context
         */
        include_parents?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/external_tools';
};

export type ListExternalToolsGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UploadFileToGroupData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/files';
};

export type UploadFileToGroupResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetQuotaInformationGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/files/quota';
};

export type GetQuotaInformationGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetFileGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Array of additional information to include.
         *
         * "user":: the user who uploaded the file or last edited its content
         * "usage_rights":: copyright and license information for the file (see UsageRights)
         */
        include?: Array<'user'>;
    };
    url: '/v1/groups/{group_id}/files/{id}';
};

export type GetFileGroupsResponses = {
    /**
     * No response was specified
     */
    200: File;
};

export type GetFileGroupsResponse = GetFileGroupsResponses[keyof GetFileGroupsResponses];

export type ListAllFoldersGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/folders';
};

export type ListAllFoldersGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<Folder>;
};

export type ListAllFoldersGroupsResponse = ListAllFoldersGroupsResponses[keyof ListAllFoldersGroupsResponses];

export type CreateFolderGroupsData = {
    body: {
        /**
         * Flag the folder as hidden
         */
        hidden?: boolean;
        /**
         * The datetime to lock the folder at
         */
        lock_at?: string;
        /**
         * Flag the folder as locked
         */
        locked?: boolean;
        /**
         * The name of the folder
         */
        name: string;
        /**
         * The id of the folder to store the file in. If this and parent_folder_path are sent an error will be returned. If neither is given, a default folder will be used.
         */
        parent_folder_id?: string;
        /**
         * The path of the folder to store the new folder in. The path separator is the forward slash `/`, never a back slash. The parent folder will be created if it does not already exist. This parameter only applies to new folders in a context that has folders, such as a user, a course, or a group. If this and parent_folder_id are sent an error will be returned. If neither is given, a default folder will be used.
         */
        parent_folder_path?: string;
        /**
         * Set an explicit sort position for the folder
         */
        position?: number;
        /**
         * The datetime to unlock the folder at
         */
        unlock_at?: string;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/folders';
};

export type CreateFolderGroupsResponses = {
    /**
     * No response was specified
     */
    200: Folder;
};

export type CreateFolderGroupsResponse = CreateFolderGroupsResponses[keyof CreateFolderGroupsResponses];

export type ResolvePathGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/folders/by_path';
};

export type ResolvePathGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<Folder>;
};

export type ResolvePathGroupsResponse = ResolvePathGroupsResponses[keyof ResolvePathGroupsResponses];

export type ResolvePathGroupsFullPathData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/folders/by_path/*full_path';
};

export type ResolvePathGroupsFullPathResponses = {
    /**
     * No response was specified
     */
    200: Array<Folder>;
};

export type ResolvePathGroupsFullPathResponse = ResolvePathGroupsFullPathResponses[keyof ResolvePathGroupsFullPathResponses];

export type GetFolderGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/folders/{id}';
};

export type GetFolderGroupsResponses = {
    /**
     * No response was specified
     */
    200: Folder;
};

export type GetFolderGroupsResponse = GetFolderGroupsResponses[keyof GetFolderGroupsResponses];

export type ShowFrontPageGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/front_page';
};

export type ShowFrontPageGroupsResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type ShowFrontPageGroupsResponse = ShowFrontPageGroupsResponses[keyof ShowFrontPageGroupsResponses];

export type UpdateCreateFrontPageGroupsData = {
    body?: {
        /**
         * The content for the new page.
         */
        'wiki_page[body]'?: string;
        /**
         * Which user roles are allowed to edit this page. Any combination
         * of these roles is allowed (separated by commas).
         *
         * "teachers":: Allows editing by teachers in the course.
         * "students":: Allows editing by students in the course.
         * "members":: For group wikis, allows editing by members of the group.
         * "public":: Allows editing by any user.
         */
        'wiki_page[editing_roles]'?: 'teachers' | 'students' | 'members' | 'public';
        /**
         * Whether participants should be notified when this page changes.
         */
        'wiki_page[notify_of_update]'?: boolean;
        /**
         * Whether the page is published (true) or draft state (false).
         */
        'wiki_page[published]'?: boolean;
        /**
         * The title for the new page. NOTE: changing a page's title will change its
         * url. The updated url will be returned in the result.
         */
        'wiki_page[title]'?: string;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/front_page';
};

export type UpdateCreateFrontPageGroupsResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type UpdateCreateFrontPageGroupsResponse = UpdateCreateFrontPageGroupsResponses[keyof UpdateCreateFrontPageGroupsResponses];

export type InviteOthersToGroupData = {
    body: {
        /**
         * An array of email addresses to be sent invitations.
         */
        invitees: Array<string>;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/invite';
};

export type InviteOthersToGroupResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListGroupMembershipsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * Only list memberships with the given workflow_states. By default it will
         * return all memberships.
         */
        filter_states?: Array<'accepted' | 'invited' | 'requested'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/memberships';
};

export type ListGroupMembershipsResponses = {
    /**
     * No response was specified
     */
    200: Array<GroupMembership>;
};

export type ListGroupMembershipsResponse = ListGroupMembershipsResponses[keyof ListGroupMembershipsResponses];

export type CreateMembershipData = {
    body?: {
        /**
         * no description
         */
        user_id?: string;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/memberships';
};

export type CreateMembershipResponses = {
    /**
     * No response was specified
     */
    200: GroupMembership;
};

export type CreateMembershipResponse = CreateMembershipResponses[keyof CreateMembershipResponses];

export type LeaveGroupMembershipsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        membership_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/memberships/{membership_id}';
};

export type LeaveGroupMembershipsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleGroupMembershipMembershipsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        membership_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/memberships/{membership_id}';
};

export type GetSingleGroupMembershipMembershipsResponses = {
    /**
     * No response was specified
     */
    200: GroupMembership;
};

export type GetSingleGroupMembershipMembershipsResponse = GetSingleGroupMembershipMembershipsResponses[keyof GetSingleGroupMembershipMembershipsResponses];

export type UpdateMembershipMembershipsData = {
    body?: {
        /**
         * no description
         */
        moderator?: string;
        /**
         * Currently, the only allowed value is "accepted"
         */
        workflow_state?: 'accepted';
    };
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        membership_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/memberships/{membership_id}';
};

export type UpdateMembershipMembershipsResponses = {
    /**
     * No response was specified
     */
    200: GroupMembership;
};

export type UpdateMembershipMembershipsResponse = UpdateMembershipMembershipsResponses[keyof UpdateMembershipMembershipsResponses];

export type ListPagesGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * Sort results by this field.
         */
        sort?: 'title' | 'created_at' | 'updated_at';
        /**
         * The sorting order. Defaults to 'asc'.
         */
        order?: 'asc' | 'desc';
        /**
         * The partial title of the pages to match and return.
         */
        search_term?: string;
        /**
         * If true, include only published paqes. If false, exclude published
         * pages. If not present, do not filter on published status.
         */
        published?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/pages';
};

export type ListPagesGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<Page>;
};

export type ListPagesGroupsResponse = ListPagesGroupsResponses[keyof ListPagesGroupsResponses];

export type CreatePageGroupsData = {
    body: {
        /**
         * The content for the new page.
         */
        'wiki_page[body]'?: string;
        /**
         * Which user roles are allowed to edit this page. Any combination
         * of these roles is allowed (separated by commas).
         *
         * "teachers":: Allows editing by teachers in the course.
         * "students":: Allows editing by students in the course.
         * "members":: For group wikis, allows editing by members of the group.
         * "public":: Allows editing by any user.
         */
        'wiki_page[editing_roles]'?: 'teachers' | 'students' | 'members' | 'public';
        /**
         * Set an unhidden page as the front page (if true)
         */
        'wiki_page[front_page]'?: boolean;
        /**
         * Whether participants should be notified when this page changes.
         */
        'wiki_page[notify_of_update]'?: boolean;
        /**
         * Whether the page is published (true) or draft state (false).
         */
        'wiki_page[published]'?: boolean;
        /**
         * The title for the new page.
         */
        'wiki_page[title]': string;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/pages';
};

export type CreatePageGroupsResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type CreatePageGroupsResponse = CreatePageGroupsResponses[keyof CreatePageGroupsResponses];

export type DeletePageGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        url: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/pages/{url}';
};

export type DeletePageGroupsResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type DeletePageGroupsResponse = DeletePageGroupsResponses[keyof DeletePageGroupsResponses];

export type ShowPageGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        url: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/pages/{url}';
};

export type ShowPageGroupsResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type ShowPageGroupsResponse = ShowPageGroupsResponses[keyof ShowPageGroupsResponses];

export type UpdateCreatePageGroupsData = {
    body?: {
        /**
         * The content for the new page.
         */
        'wiki_page[body]'?: string;
        /**
         * Which user roles are allowed to edit this page. Any combination
         * of these roles is allowed (separated by commas).
         *
         * "teachers":: Allows editing by teachers in the course.
         * "students":: Allows editing by students in the course.
         * "members":: For group wikis, allows editing by members of the group.
         * "public":: Allows editing by any user.
         */
        'wiki_page[editing_roles]'?: 'teachers' | 'students' | 'members' | 'public';
        /**
         * Set an unhidden page as the front page (if true)
         */
        'wiki_page[front_page]'?: boolean;
        /**
         * Whether participants should be notified when this page changes.
         */
        'wiki_page[notify_of_update]'?: boolean;
        /**
         * Whether the page is published (true) or draft state (false).
         */
        'wiki_page[published]'?: boolean;
        /**
         * The title for the new page. NOTE: changing a page's title will change its
         * url. The updated url will be returned in the result.
         */
        'wiki_page[title]'?: string;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        url: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/pages/{url}';
};

export type UpdateCreatePageGroupsResponses = {
    /**
     * No response was specified
     */
    200: Page;
};

export type UpdateCreatePageGroupsResponse = UpdateCreatePageGroupsResponses[keyof UpdateCreatePageGroupsResponses];

export type ListRevisionsGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        url: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/pages/{url}/revisions';
};

export type ListRevisionsGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<PageRevision>;
};

export type ListRevisionsGroupsResponse = ListRevisionsGroupsResponses[keyof ListRevisionsGroupsResponses];

export type ShowRevisionGroupsLatestData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        url: string;
    };
    query?: {
        /**
         * If set, exclude page content from results
         */
        summary?: boolean;
    };
    url: '/v1/groups/{group_id}/pages/{url}/revisions/latest';
};

export type ShowRevisionGroupsLatestResponses = {
    /**
     * No response was specified
     */
    200: PageRevision;
};

export type ShowRevisionGroupsLatestResponse = ShowRevisionGroupsLatestResponses[keyof ShowRevisionGroupsLatestResponses];

export type ShowRevisionGroupsRevisionIdData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        url: string;
        /**
         * ID
         */
        revision_id: string;
    };
    query?: {
        /**
         * If set, exclude page content from results
         */
        summary?: boolean;
    };
    url: '/v1/groups/{group_id}/pages/{url}/revisions/{revision_id}';
};

export type ShowRevisionGroupsRevisionIdResponses = {
    /**
     * No response was specified
     */
    200: PageRevision;
};

export type ShowRevisionGroupsRevisionIdResponse = ShowRevisionGroupsRevisionIdResponses[keyof ShowRevisionGroupsRevisionIdResponses];

export type RevertToRevisionGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        url: string;
        /**
         * The revision to revert to (use the
         * {api:WikiPagesApiController#revisions List Revisions API} to see
         * available revisions)
         */
        revision_id: number;
    };
    query?: never;
    url: '/v1/groups/{group_id}/pages/{url}/revisions/{revision_id}';
};

export type RevertToRevisionGroupsResponses = {
    /**
     * No response was specified
     */
    200: PageRevision;
};

export type RevertToRevisionGroupsResponse = RevertToRevisionGroupsResponses[keyof RevertToRevisionGroupsResponses];

export type GroupPermissionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * List of permissions to check against the authenticated user.
         * Permission names are documented in the {api:RoleOverridesController#add_role Create a role} endpoint.
         */
        permissions?: Array<string>;
    };
    url: '/v1/groups/{group_id}/permissions';
};

export type GroupPermissionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListPotentialMembersGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/potential_collaborators';
};

export type ListPotentialMembersGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type ListPotentialMembersGroupsResponse = ListPotentialMembersGroupsResponses[keyof ListPotentialMembersGroupsResponses];

export type PreviewProcessedHtmlGroupData = {
    body?: {
        /**
         * The html content to process
         */
        html?: string;
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/preview_html';
};

export type PreviewProcessedHtmlGroupResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListAvailableTabsForCourseOrGroupGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * "external":: Optionally include external tool tabs in the returned list of tabs (Only has effect for courses, not groups)
         */
        include?: Array<'external'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/tabs';
};

export type ListAvailableTabsForCourseOrGroupGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type RemoveUsageRightsGroupsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query: {
        /**
         * List of ids of files to remove associated usage rights from.
         */
        file_ids: Array<string>;
        /**
         * List of ids of folders. Usage rights will be removed from all files in these folders.
         */
        folder_ids?: Array<string>;
    };
    url: '/v1/groups/{group_id}/usage_rights';
};

export type RemoveUsageRightsGroupsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type SetUsageRightsGroupsData = {
    body: {
        /**
         * List of ids of files to set usage rights for.
         */
        file_ids: Array<string>;
        /**
         * List of ids of folders to search for files to set usage rights for.
         * Note that new files uploaded to these folders do not automatically inherit these rights.
         */
        folder_ids?: Array<string>;
        /**
         * Whether the file(s) or folder(s) should be published on save, provided that usage rights have been specified (set to `true` to publish on save).
         */
        publish?: boolean;
        /**
         * The legal copyright line for the files
         */
        'usage_rights[legal_copyright]'?: string;
        /**
         * The license that applies to the files. See the {api:UsageRightsController#licenses List licenses endpoint} for the supported license types.
         */
        'usage_rights[license]'?: string;
        /**
         * The intellectual property justification for using the files in Canvas
         */
        'usage_rights[use_justification]': 'own_copyright' | 'used_by_permission' | 'fair_use' | 'public_domain' | 'creative_commons';
    };
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/usage_rights';
};

export type SetUsageRightsGroupsResponses = {
    /**
     * No response was specified
     */
    200: UsageRights;
};

export type SetUsageRightsGroupsResponse = SetUsageRightsGroupsResponses[keyof SetUsageRightsGroupsResponses];

export type ListGroupSusersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
    };
    query?: {
        /**
         * The partial name or full ID of the users to match and return in the
         * results list. Must be at least 3 characters.
         */
        search_term?: string;
        /**
         * - "avatar_url": Include users' avatar_urls.
         */
        include?: Array<'avatar_url'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/groups/{group_id}/users';
};

export type ListGroupSusersResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type ListGroupSusersResponse = ListGroupSusersResponses[keyof ListGroupSusersResponses];

export type LeaveGroupUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/users/{user_id}';
};

export type LeaveGroupUsersResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSingleGroupMembershipUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/users/{user_id}';
};

export type GetSingleGroupMembershipUsersResponses = {
    /**
     * No response was specified
     */
    200: GroupMembership;
};

export type GetSingleGroupMembershipUsersResponse = GetSingleGroupMembershipUsersResponses[keyof GetSingleGroupMembershipUsersResponses];

export type UpdateMembershipUsersData = {
    body?: {
        /**
         * no description
         */
        moderator?: string;
        /**
         * Currently, the only allowed value is "accepted"
         */
        workflow_state?: 'accepted';
    };
    path: {
        /**
         * ID
         */
        group_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/groups/{group_id}/users/{user_id}';
};

export type UpdateMembershipUsersResponses = {
    /**
     * No response was specified
     */
    200: GroupMembership;
};

export type UpdateMembershipUsersResponse = UpdateMembershipUsersResponses[keyof UpdateMembershipUsersResponses];

export type CreateJwtData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/jwts';
};

export type CreateJwtResponses = {
    /**
     * No response was specified
     */
    200: Jwt;
};

export type CreateJwtResponse = CreateJwtResponses[keyof CreateJwtResponses];

export type RefreshJwtData = {
    body: {
        /**
         * An existing JWT token to be refreshed. The new token will have
         * the same context and workflows as the existing token.
         */
        jwt: string;
    };
    path?: never;
    query?: never;
    url: '/v1/jwts/refresh';
};

export type RefreshJwtResponses = {
    /**
     * No response was specified
     */
    200: Jwt;
};

export type RefreshJwtResponse = RefreshJwtResponses[keyof RefreshJwtResponses];

export type ShowOutcomeData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/outcomes/{id}';
};

export type ShowOutcomeResponses = {
    /**
     * No response was specified
     */
    200: Outcome;
};

export type ShowOutcomeResponse = ShowOutcomeResponses[keyof ShowOutcomeResponses];

export type UpdateOutcomeData = {
    body?: {
        /**
         * The new calculation int.  Only applies if the calculation_method is "decaying_average" or "n_mastery"
         */
        calculation_int?: number;
        /**
         * The new calculation method.
         */
        calculation_method?: 'decaying_average' | 'n_mastery' | 'latest' | 'highest';
        /**
         * The new outcome description.
         */
        description?: string;
        /**
         * A friendly name shown in reports for outcomes with cryptic titles,
         * such as common core standards names.
         */
        display_name?: string;
        /**
         * The new mastery threshold for the embedded rubric criterion.
         */
        mastery_points?: number;
        /**
         * The description of a new rating level for the embedded rubric criterion.
         */
        'ratings[description]'?: Array<string>;
        /**
         * The points corresponding to a new rating level for the embedded rubric
         * criterion.
         */
        'ratings[points]'?: Array<number>;
        /**
         * The new outcome title.
         */
        title?: string;
        /**
         * A custom GUID for the learning standard.
         */
        vendor_guid?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/outcomes/{id}';
};

export type UpdateOutcomeResponses = {
    /**
     * No response was specified
     */
    200: Outcome;
};

export type UpdateOutcomeResponse = UpdateOutcomeResponses[keyof UpdateOutcomeResponses];

export type ListPlannerItemsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Only return items starting from the given date.
         * The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         */
        start_date?: string;
        /**
         * Only return items up to the given date.
         * The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         */
        end_date?: string;
        /**
         * List of context codes of courses and/or groups whose items you want to see.
         * If not specified, defaults to all contexts associated to the current user.
         * Note that concluded courses will be ignored unless specified in the includes[]
         * parameter. The format of this field is the context type, followed by an underscore,
         * followed by the context id. For example: course_42, group_123
         */
        context_codes?: Array<string>;
        /**
         * Only return items that have new or unread activity
         */
        filter?: 'new_activity';
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/planner/items';
};

export type ListPlannerItemsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListPlannerOverridesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/planner/overrides';
};

export type ListPlannerOverridesResponses = {
    /**
     * No response was specified
     */
    200: Array<PlannerOverride>;
};

export type ListPlannerOverridesResponse = ListPlannerOverridesResponses[keyof ListPlannerOverridesResponses];

export type CreatePlannerOverrideData = {
    body?: {
        /**
         * If this is true, the item will not show in the opportunities list
         */
        dismissed?: boolean;
        /**
         * If this is true, the item will show in the planner as completed
         */
        marked_complete?: boolean;
        /**
         * ID of the item that you are overriding in the planner
         */
        plannable_id?: number;
        /**
         * Type of the item that you are overriding in the planner
         */
        plannable_type?: 'announcement' | 'assignment' | 'discussion_topic' | 'quiz' | 'wiki_page' | 'planner_note';
    };
    path?: never;
    query?: never;
    url: '/v1/planner/overrides';
};

export type CreatePlannerOverrideResponses = {
    /**
     * No response was specified
     */
    200: PlannerOverride;
};

export type CreatePlannerOverrideResponse = CreatePlannerOverrideResponses[keyof CreatePlannerOverrideResponses];

export type DeletePlannerOverrideData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/planner/overrides/{id}';
};

export type DeletePlannerOverrideResponses = {
    /**
     * No response was specified
     */
    200: PlannerOverride;
};

export type DeletePlannerOverrideResponse = DeletePlannerOverrideResponses[keyof DeletePlannerOverrideResponses];

export type ShowPlannerOverrideData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/planner/overrides/{id}';
};

export type ShowPlannerOverrideResponses = {
    /**
     * No response was specified
     */
    200: PlannerOverride;
};

export type ShowPlannerOverrideResponse = ShowPlannerOverrideResponses[keyof ShowPlannerOverrideResponses];

export type UpdatePlannerOverrideData = {
    body?: {
        /**
         * determines whether the planner item shows in the opportunities list
         */
        dismissed?: string;
        /**
         * determines whether the planner item is marked as completed
         */
        marked_complete?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/planner/overrides/{id}';
};

export type UpdatePlannerOverrideResponses = {
    /**
     * No response was specified
     */
    200: PlannerOverride;
};

export type UpdatePlannerOverrideResponse = UpdatePlannerOverrideResponses[keyof UpdatePlannerOverrideResponses];

export type ListPlannerNotesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Only return notes with todo dates since the start_date (inclusive).
         * No default. The value should be formatted as: yyyy-mm-dd or
         * ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         */
        start_date?: string;
        /**
         * Only return notes with todo dates before the end_date (inclusive).
         * No default. The value should be formatted as: yyyy-mm-dd or
         * ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         * If end_date and start_date are both specified and equivalent,
         * then only notes with todo dates on that day are returned.
         */
        end_date?: string;
        /**
         * List of context codes of courses whose notes you want to see.
         * If not specified, defaults to all contexts that the user belongs to.
         * The format of this field is the context type, followed by an
         * underscore, followed by the context id. For example: course_42
         * Including a code matching the user's own context code (e.g. user_1)
         * will include notes that are not associated with any particular course.
         */
        context_codes?: Array<string>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/planner_notes';
};

export type ListPlannerNotesResponses = {
    /**
     * No response was specified
     */
    200: Array<PlannerNote>;
};

export type ListPlannerNotesResponse = ListPlannerNotesResponses[keyof ListPlannerNotesResponses];

export type CreatePlannerNoteData = {
    body?: {
        /**
         * The ID of the course to associate with the planner note. The caller must be able to view the course in order to
         * associate it with a planner note.
         */
        course_id?: number;
        /**
         * Text of the planner note.
         */
        details?: string;
        /**
         * The id of a learning object to link to this planner note. Must be used in conjunction with linked_object_type
         * and course_id. The object must be in the same course as specified by course_id. If the title argument is not
         * provided, the planner note will use the learning object's title as its title. Only one planner note may be
         * linked to a specific learning object.
         */
        linked_object_id?: number;
        /**
         * The type of a learning object to link to this planner note. Must be used in conjunction wtih linked_object_id
         * and course_id. Valid linked_object_type values are:
         * 'announcement', 'assignment', 'discussion_topic', 'wiki_page', 'quiz'
         */
        linked_object_type?: string;
        /**
         * The title of the planner note.
         */
        title?: string;
        /**
         * The date where this planner note should appear in the planner.
         * The value should be formatted as: yyyy-mm-dd.
         */
        todo_date?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/planner_notes';
};

export type CreatePlannerNoteResponses = {
    /**
     * No response was specified
     */
    200: PlannerNote;
};

export type CreatePlannerNoteResponse = CreatePlannerNoteResponses[keyof CreatePlannerNoteResponses];

export type DeletePlannerNoteData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/planner_notes/{id}';
};

export type DeletePlannerNoteResponses = {
    /**
     * No response was specified
     */
    200: PlannerNote;
};

export type DeletePlannerNoteResponse = DeletePlannerNoteResponses[keyof DeletePlannerNoteResponses];

export type ShowPlannernoteData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/planner_notes/{id}';
};

export type ShowPlannernoteResponses = {
    /**
     * No response was specified
     */
    200: PlannerNote;
};

export type ShowPlannernoteResponse = ShowPlannernoteResponses[keyof ShowPlannernoteResponses];

export type UpdatePlannernoteData = {
    body?: {
        /**
         * The ID of the course to associate with the planner note. The caller must be able to view the course in order to
         * associate it with a planner note. Use a null or empty value to remove a planner note from a course. Note that if
         * the planner note is linked to a learning object, its course_id cannot be changed.
         */
        course_id?: number;
        /**
         * Text of the planner note.
         */
        details?: string;
        /**
         * The title of the planner note.
         */
        title?: string;
        /**
         * The date where this planner note should appear in the planner.
         * The value should be formatted as: yyyy-mm-dd.
         */
        todo_date?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/planner_notes/{id}';
};

export type UpdatePlannernoteResponses = {
    /**
     * No response was specified
     */
    200: PlannerNote;
};

export type UpdatePlannernoteResponse = UpdatePlannernoteResponses[keyof UpdatePlannernoteResponses];

export type ListClosedPollSessionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/poll_sessions/closed';
};

export type ListClosedPollSessionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListOpenedPollSessionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/poll_sessions/opened';
};

export type ListOpenedPollSessionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListPollsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/polls';
};

export type ListPollsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateSinglePollData = {
    body: {
        /**
         * A brief description or instructions for the poll.
         */
        'polls[description]'?: Array<string>;
        /**
         * The title of the poll.
         */
        'polls[question]': Array<string>;
    };
    path?: never;
    query?: never;
    url: '/v1/polls';
};

export type CreateSinglePollResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeletePollData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/polls/{id}';
};

export type DeletePollResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSinglePollData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/polls/{id}';
};

export type GetSinglePollResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateSinglePollData = {
    body: {
        /**
         * A brief description or instructions for the poll.
         */
        'polls[description]'?: Array<string>;
        /**
         * The title of the poll.
         */
        'polls[question]': Array<string>;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/polls/{id}';
};

export type UpdateSinglePollResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListPollChoicesInPollData = {
    body?: never;
    path: {
        /**
         * ID
         */
        poll_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/polls/{poll_id}/poll_choices';
};

export type ListPollChoicesInPollResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateSinglePollChoiceData = {
    body: {
        /**
         * Whether this poll choice is considered correct or not. Defaults to false.
         */
        'poll_choices[is_correct]'?: Array<boolean>;
        /**
         * The order this poll choice should be returned in the context it's sibling poll choices.
         */
        'poll_choices[position]'?: Array<number>;
        /**
         * The descriptive text of the poll choice.
         */
        'poll_choices[text]': Array<string>;
    };
    path: {
        /**
         * ID
         */
        poll_id: string;
    };
    query?: never;
    url: '/v1/polls/{poll_id}/poll_choices';
};

export type CreateSinglePollChoiceResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeletePollChoiceData = {
    body?: never;
    path: {
        /**
         * ID
         */
        poll_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/polls/{poll_id}/poll_choices/{id}';
};

export type DeletePollChoiceResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSinglePollChoiceData = {
    body?: never;
    path: {
        /**
         * ID
         */
        poll_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/polls/{poll_id}/poll_choices/{id}';
};

export type GetSinglePollChoiceResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateSinglePollChoiceData = {
    body: {
        /**
         * Whether this poll choice is considered correct or not.  Defaults to false.
         */
        'poll_choices[is_correct]'?: Array<boolean>;
        /**
         * The order this poll choice should be returned in the context it's sibling poll choices.
         */
        'poll_choices[position]'?: Array<number>;
        /**
         * The descriptive text of the poll choice.
         */
        'poll_choices[text]': Array<string>;
    };
    path: {
        /**
         * ID
         */
        poll_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/polls/{poll_id}/poll_choices/{id}';
};

export type UpdateSinglePollChoiceResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListPollSessionsForPollData = {
    body?: never;
    path: {
        /**
         * ID
         */
        poll_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/polls/{poll_id}/poll_sessions';
};

export type ListPollSessionsForPollResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateSinglePollSessionData = {
    body: {
        /**
         * The id of the course this session is associated with.
         */
        'poll_sessions[course_id]': Array<number>;
        /**
         * The id of the course section this session is associated with.
         */
        'poll_sessions[course_section_id]'?: Array<number>;
        /**
         * Whether or not results are viewable by students.
         */
        'poll_sessions[has_public_results]'?: Array<boolean>;
    };
    path: {
        /**
         * ID
         */
        poll_id: string;
    };
    query?: never;
    url: '/v1/polls/{poll_id}/poll_sessions';
};

export type CreateSinglePollSessionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeletePollSessionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        poll_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/polls/{poll_id}/poll_sessions/{id}';
};

export type DeletePollSessionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetResultsForSinglePollSessionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        poll_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/polls/{poll_id}/poll_sessions/{id}';
};

export type GetResultsForSinglePollSessionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateSinglePollSessionData = {
    body?: {
        /**
         * The id of the course this session is associated with.
         */
        'poll_sessions[course_id]'?: Array<number>;
        /**
         * The id of the course section this session is associated with.
         */
        'poll_sessions[course_section_id]'?: Array<number>;
        /**
         * Whether or not results are viewable by students.
         */
        'poll_sessions[has_public_results]'?: Array<boolean>;
    };
    path: {
        /**
         * ID
         */
        poll_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/polls/{poll_id}/poll_sessions/{id}';
};

export type UpdateSinglePollSessionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CloseOpenedPollSessionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        poll_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/polls/{poll_id}/poll_sessions/{id}/close';
};

export type CloseOpenedPollSessionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type OpenPollSessionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        poll_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/polls/{poll_id}/poll_sessions/{id}/open';
};

export type OpenPollSessionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type CreateSinglePollSubmissionData = {
    body: {
        /**
         * The chosen poll choice for this submission.
         */
        'poll_submissions[poll_choice_id]': Array<number>;
    };
    path: {
        /**
         * ID
         */
        poll_id: string;
        /**
         * ID
         */
        poll_session_id: string;
    };
    query?: never;
    url: '/v1/polls/{poll_id}/poll_sessions/{poll_session_id}/poll_submissions';
};

export type CreateSinglePollSubmissionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetSinglePollSubmissionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        poll_id: string;
        /**
         * ID
         */
        poll_session_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/polls/{poll_id}/poll_sessions/{poll_session_id}/poll_submissions/{id}';
};

export type GetSinglePollSubmissionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type QueryProgressData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/progress/{id}';
};

export type QueryProgressResponses = {
    /**
     * No response was specified
     */
    200: Progress;
};

export type QueryProgressResponse = QueryProgressResponses[keyof QueryProgressResponses];

export type GetAllQuizSubmissionQuestionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        quiz_submission_id: string;
    };
    query?: {
        /**
         * Associations to include with the quiz submission question.
         */
        include?: Array<'quiz_question'>;
    };
    url: '/v1/quiz_submissions/{quiz_submission_id}/questions';
};

export type GetAllQuizSubmissionQuestionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type AnsweringQuestionsData = {
    body: {
        /**
         * Access code for the Quiz, if any.
         */
        access_code?: string;
        /**
         * The attempt number of the quiz submission being taken. Note that this
         * must be the latest attempt index, as questions for earlier attempts can
         * not be modified.
         */
        attempt: number;
        quiz_questions?: Array<QuizQuestion>;
        /**
         * The unique validation token you received when the Quiz Submission was
         * created.
         */
        validation_token: string;
    };
    path: {
        /**
         * ID
         */
        quiz_submission_id: string;
    };
    query?: never;
    url: '/v1/quiz_submissions/{quiz_submission_id}/questions';
};

export type AnsweringQuestionsResponses = {
    /**
     * No response was specified
     */
    200: Array<QuizSubmissionQuestion>;
};

export type AnsweringQuestionsResponse = AnsweringQuestionsResponses[keyof AnsweringQuestionsResponses];

export type FlaggingQuestionData = {
    body: {
        /**
         * Access code for the Quiz, if any.
         */
        access_code?: string;
        /**
         * The attempt number of the quiz submission being taken. Note that this
         * must be the latest attempt index, as questions for earlier attempts can
         * not be modified.
         */
        attempt: number;
        /**
         * The unique validation token you received when the Quiz Submission was
         * created.
         */
        validation_token: string;
    };
    path: {
        /**
         * ID
         */
        quiz_submission_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/quiz_submissions/{quiz_submission_id}/questions/{id}/flag';
};

export type FlaggingQuestionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UnflaggingQuestionData = {
    body: {
        /**
         * Access code for the Quiz, if any.
         */
        access_code?: string;
        /**
         * The attempt number of the quiz submission being taken. Note that this
         * must be the latest attempt index, as questions for earlier attempts can
         * not be modified.
         */
        attempt: number;
        /**
         * The unique validation token you received when the Quiz Submission was
         * created.
         */
        validation_token: string;
    };
    path: {
        /**
         * ID
         */
        quiz_submission_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/quiz_submissions/{quiz_submission_id}/questions/{id}/unflag';
};

export type UnflaggingQuestionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListAllCoursesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Search terms used for matching users/courses/groups (e.g. "bob smith"). If
         * multiple terms are given (separated via whitespace), only results matching
         * all terms will be returned.
         */
        search?: string;
        /**
         * Only return courses with public content. Defaults to false.
         */
        public_only?: boolean;
        /**
         * Only return courses that allow self enrollment. Defaults to false.
         */
        open_enrollment_only?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/search/all_courses';
};

export type ListAllCoursesResponses = {
    /**
     * Returns a list of courses.
     */
    200: Array<Course>;
};

export type ListAllCoursesResponse = ListAllCoursesResponses[keyof ListAllCoursesResponses];

export type FindRecipientsSearchData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Search terms used for matching users/courses/groups (e.g. "bob smith"). If
         * multiple terms are given (separated via whitespace), only results matching
         * all terms will be returned.
         */
        search?: string;
        /**
         * Limit the search to a particular course/group (e.g. "course_3" or "group_4").
         */
        context?: string;
        /**
         * Array of ids to exclude from the search. These may be user ids or
         * course/group ids prefixed with "course_" or "group_" respectively,
         * e.g. exclude[]=1&exclude[]=2&exclude[]=course_3
         */
        exclude?: Array<string>;
        /**
         * Limit the search just to users or contexts (groups/courses).
         */
        type?: 'user' | 'context';
        /**
         * Search for a specific user id. This ignores the other above parameters,
         * and will never return more than one result.
         */
        user_id?: number;
        /**
         * When searching by user_id, only users that could be normally messaged by
         * this user will be returned. This parameter allows you to specify a
         * conversation that will be referenced for a shared context -- if both the
         * current user and the searched user are in the conversation, the user will
         * be returned. This is used to start new side conversations.
         */
        from_conversation_id?: number;
        /**
         * Array of permission strings to be checked for each matched context (e.g.
         * "send_messages"). This argument determines which permissions may be
         * returned in the response; it won't prevent contexts from being returned if
         * they don't grant the permission(s).
         */
        permissions?: Array<string>;
    };
    url: '/v1/search/recipients';
};

export type FindRecipientsSearchResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type RedirectToAssignmentOverrideForSectionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_section_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: never;
    url: '/v1/sections/{course_section_id}/assignments/{assignment_id}/override';
};

export type RedirectToAssignmentOverrideForSectionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteSectionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/sections/{id}';
};

export type DeleteSectionResponses = {
    /**
     * No response was specified
     */
    200: Section;
};

export type DeleteSectionResponse = DeleteSectionResponses[keyof DeleteSectionResponses];

export type GetSectionInformationSectionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * - "students": Associations to include with the group. Note: this is only
         * available if you have permission to view users or grades in the course
         * - "avatar_url": Include the avatar URLs for students returned.
         * - "enrollments": If 'students' is also included, return the section
         * enrollment for each student
         * - "total_students": Returns the total amount of active and invited students
         * for the course section
         * - "passback_status": Include the grade passback status.
         */
        include?: Array<'students' | 'avatar_url' | 'enrollments' | 'total_students' | 'passback_status'>;
    };
    url: '/v1/sections/{id}';
};

export type GetSectionInformationSectionsResponses = {
    /**
     * No response was specified
     */
    200: Section;
};

export type GetSectionInformationSectionsResponse = GetSectionInformationSectionsResponses[keyof GetSectionInformationSectionsResponses];

export type EditSectionData = {
    body?: {
        /**
         * Section end date in ISO8601 format. e.g. 2011-01-01T01:00Z
         */
        'course_section[end_at]'?: string;
        /**
         * The integration_id of the section. Must have manage_sis permission to set.
         */
        'course_section[integration_id]'?: string;
        /**
         * The name of the section
         */
        'course_section[name]'?: string;
        /**
         * Set to true to restrict user enrollments to the start and end dates of the section.
         */
        'course_section[restrict_enrollments_to_section_dates]'?: boolean;
        /**
         * The sis ID of the section. Must have manage_sis permission to set.
         */
        'course_section[sis_section_id]'?: string;
        /**
         * Section start date in ISO8601 format, e.g. 2011-01-01T01:00Z
         */
        'course_section[start_at]'?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/sections/{id}';
};

export type EditSectionResponses = {
    /**
     * No response was specified
     */
    200: Section;
};

export type EditSectionResponse = EditSectionResponses[keyof EditSectionResponses];

export type DeCrossListSectionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/sections/{id}/crosslist';
};

export type DeCrossListSectionResponses = {
    /**
     * No response was specified
     */
    200: Section;
};

export type DeCrossListSectionResponse = DeCrossListSectionResponses[keyof DeCrossListSectionResponses];

export type CrossListSectionData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
        /**
         * ID
         */
        new_course_id: string;
    };
    query?: never;
    url: '/v1/sections/{id}/crosslist/{new_course_id}';
};

export type CrossListSectionResponses = {
    /**
     * No response was specified
     */
    200: Section;
};

export type CrossListSectionResponse = CrossListSectionResponses[keyof CrossListSectionResponses];

export type GetAllPeerReviewsSectionsPeerReviewsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * Associations to include with the peer review.
         */
        include?: Array<'submission_comments' | 'user'>;
    };
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/peer_reviews';
};

export type GetAllPeerReviewsSectionsPeerReviewsResponses = {
    /**
     * No response was specified
     */
    200: Array<PeerReview>;
};

export type GetAllPeerReviewsSectionsPeerReviewsResponse = GetAllPeerReviewsSectionsPeerReviewsResponses[keyof GetAllPeerReviewsSectionsPeerReviewsResponses];

export type SubmissionSummarySectionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * If this argument is true, the response will take into account student groups.
         */
        grouped?: boolean;
    };
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/submission_summary';
};

export type SubmissionSummarySectionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListAssignmentSubmissionsSectionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: {
        /**
         * Associations to include with the group.  "group" will add group_id and group_name.
         */
        include?: Array<'submission_history' | 'submission_comments' | 'rubric_assessment' | 'assignment' | 'visibility' | 'course' | 'user' | 'group'>;
        /**
         * If this argument is true, the response will be grouped by student groups.
         */
        grouped?: boolean;
        /**
         * The numeric value leading to the next paginated page. This needs to be parsed from the response header (Link field).
         */
        page?: number;
        /**
         * The number of items to return.
         */
        per_page?: number;
    };
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/submissions';
};

export type ListAssignmentSubmissionsSectionsResponses = {
    /**
     * No response was specified
     */
    200: Array<Submission>;
};

export type ListAssignmentSubmissionsSectionsResponse = ListAssignmentSubmissionsSectionsResponses[keyof ListAssignmentSubmissionsSectionsResponses];

export type SubmitAssignmentSectionsData = {
    body: {
        /**
         * Include a textual comment with the submission.
         */
        'comment[text_comment]'?: string;
        /**
         * Submit the assignment as an HTML document snippet. Note this HTML snippet
         * will be sanitized using the same ruleset as a submission made from the
         * Canvas web UI. The sanitized HTML will be returned in the response as the
         * submission body. Requires a submission_type of "online_text_entry".
         */
        'submission[body]'?: string;
        /**
         * Submit the assignment as a set of one or more previously uploaded files
         * residing in the submitting user's files section (or the group's files
         * section, for group assignments).
         *
         * To upload a new file to submit, see the submissions {api:SubmissionsApiController#create_file Upload a file API}.
         *
         * Requires a submission_type of "online_upload".
         */
        'submission[file_ids]'?: Array<number>;
        /**
         * The media comment id to submit. Media comment ids can be submitted via
         * this API, however, note that there is not yet an API to generate or list
         * existing media comments, so this functionality is currently of limited use.
         *
         * Requires a submission_type of "media_recording".
         */
        'submission[media_comment_id]'?: string;
        /**
         * The type of media comment being submitted.
         */
        'submission[media_comment_type]'?: 'audio' | 'video';
        /**
         * The type of submission being made. The assignment submission_types must
         * include this submission type as an allowed option, or the submission will be rejected with a 400 error.
         *
         * The submission_type given determines which of the following parameters is
         * used. For instance, to submit a URL, submission [submission_type] must be
         * set to "online_url", otherwise the submission [url] parameter will be
         * ignored.
         */
        'submission[submission_type]': 'online_text_entry' | 'online_url' | 'online_upload' | 'media_recording' | 'basic_lti_launch';
        /**
         * Submit the assignment as a URL. The URL scheme must be "http" or "https",
         * no "ftp" or other URL schemes are allowed. If no scheme is given (e.g.
         * "www.example.com") then "http" will be assumed. Requires a submission_type
         * of "online_url" or "basic_lti_launch".
         */
        'submission[url]'?: string;
    };
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: never;
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/submissions';
};

export type SubmitAssignmentSectionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GradeOrCommentOnMultipleSubmissionsSectionsAssignmentsData = {
    body?: {
        /**
         * Specifies which assignment to grade.  This argument is not necessary when
         * using the assignment-specific endpoints.
         */
        'grade_data[student_id][assignment_id]'?: number;
        /**
         * See documentation for the excuse argument in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][excuse]'?: boolean;
        /**
         * See documentation for the comment[] arguments in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][file_ids]'?: Array<number>;
        /**
         * no description
         */
        'grade_data[student_id][group_comment]'?: boolean;
        /**
         * no description
         */
        'grade_data[student_id][media_comment_id]'?: string;
        /**
         * no description
         */
        'grade_data[student_id][media_comment_type]'?: 'audio' | 'video';
        /**
         * See documentation for the posted_grade argument in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][posted_grade]'?: string;
        /**
         * See documentation for the rubric_assessment argument in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][rubric_assessment]'?: unknown;
        /**
         * no description
         */
        'grade_data[student_id][text_comment]'?: string;
    };
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
    };
    query?: never;
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/update_grades';
};

export type GradeOrCommentOnMultipleSubmissionsSectionsAssignmentsResponses = {
    /**
     * No response was specified
     */
    200: Progress;
};

export type GradeOrCommentOnMultipleSubmissionsSectionsAssignmentsResponse = GradeOrCommentOnMultipleSubmissionsSectionsAssignmentsResponses[keyof GradeOrCommentOnMultipleSubmissionsSectionsAssignmentsResponses];

export type DeletePeerReviewSectionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        submission_id: string;
    };
    query: {
        /**
         * user_id to delete as reviewer on this assignment
         */
        user_id: number;
    };
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{submission_id}/peer_reviews';
};

export type DeletePeerReviewSectionsResponses = {
    /**
     * No response was specified
     */
    200: PeerReview;
};

export type DeletePeerReviewSectionsResponse = DeletePeerReviewSectionsResponses[keyof DeletePeerReviewSectionsResponses];

export type GetAllPeerReviewsSectionsSubmissionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        submission_id: string;
    };
    query?: {
        /**
         * Associations to include with the peer review.
         */
        include?: Array<'submission_comments' | 'user'>;
    };
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{submission_id}/peer_reviews';
};

export type GetAllPeerReviewsSectionsSubmissionsResponses = {
    /**
     * No response was specified
     */
    200: Array<PeerReview>;
};

export type GetAllPeerReviewsSectionsSubmissionsResponse = GetAllPeerReviewsSectionsSubmissionsResponses[keyof GetAllPeerReviewsSectionsSubmissionsResponses];

export type CreatePeerReviewSectionsData = {
    body: {
        /**
         * user_id to assign as reviewer on this assignment
         */
        user_id: number;
    };
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        submission_id: string;
    };
    query?: never;
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{submission_id}/peer_reviews';
};

export type CreatePeerReviewSectionsResponses = {
    /**
     * No response was specified
     */
    200: PeerReview;
};

export type CreatePeerReviewSectionsResponse = CreatePeerReviewSectionsResponses[keyof CreatePeerReviewSectionsResponses];

export type GetSingleSubmissionSectionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * Associations to include with the group.
         */
        include?: Array<'submission_history' | 'submission_comments' | 'rubric_assessment' | 'visibility' | 'course' | 'user'>;
    };
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}';
};

export type GetSingleSubmissionSectionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GradeOrCommentOnSubmissionSectionsData = {
    body?: {
        /**
         * Attach files to this comment that were previously uploaded using the
         * Submission Comment API's files action
         */
        'comment[file_ids]'?: Array<number>;
        /**
         * Whether or not this comment should be sent to the entire group (defaults
         * to false). Ignored if this is not a group assignment or if no text_comment
         * is provided.
         */
        'comment[group_comment]'?: boolean;
        /**
         * Add an audio/video comment to the submission. Media comments can be added
         * via this API, however, note that there is not yet an API to generate or
         * list existing media comments, so this functionality is currently of
         * limited use.
         */
        'comment[media_comment_id]'?: string;
        /**
         * The type of media comment being added.
         */
        'comment[media_comment_type]'?: 'audio' | 'video';
        /**
         * Add a textual comment to the submission.
         */
        'comment[text_comment]'?: string;
        /**
         * Whether this assignment is visible to the owner of the submission
         */
        'include[visibility]'?: string;
        /**
         * Assign a rubric assessment to this assignment submission. The
         * sub-parameters here depend on the rubric for the assignment. The general
         * format is, for each row in the rubric:
         *
         * The points awarded for this row.
         * rubric_assessment[criterion_id][points]
         *
         * Comments to add for this row.
         * rubric_assessment[criterion_id][comments]
         *
         * For example, if the assignment rubric is (in JSON format):
         * !!!javascript
         * [
         * {
         * 'id': 'crit1',
         * 'points': 10,
         * 'description': 'Criterion 1',
         * 'ratings':
         * [
         * { 'description': 'Good', 'points': 10 },
         * { 'description': 'Poor', 'points': 3 }
         * ]
         * },
         * {
         * 'id': 'crit2',
         * 'points': 5,
         * 'description': 'Criterion 2',
         * 'ratings':
         * [
         * { 'description': 'Complete', 'points': 5 },
         * { 'description': 'Incomplete', 'points': 0 }
         * ]
         * }
         * ]
         *
         * Then a possible set of values for rubric_assessment would be:
         * rubric_assessment[crit1][points]=3&rubric_assessment[crit2][points]=5&rubric_assessment[crit2][comments]=Well%20Done.
         */
        rubric_assessment?: unknown;
        /**
         * Sets the "excused" status of an assignment.
         */
        'submission[excuse]'?: boolean;
        /**
         * Sets the late policy status to either "late", "missing", "none", or null.
         */
        'submission[late_policy_status]'?: string;
        /**
         * Assign a score to the submission, updating both the "score" and "grade"
         * fields on the submission record. This parameter can be passed in a few
         * different formats:
         *
         * points:: A floating point or integral value, such as "13.5". The grade
         * will be interpreted directly as the score of the assignment.
         * Values above assignment.points_possible are allowed, for awarding
         * extra credit.
         * percentage:: A floating point value appended with a percent sign, such as
         * "40%". The grade will be interpreted as a percentage score on the
         * assignment, where 100% == assignment.points_possible. Values above 100%
         * are allowed, for awarding extra credit.
         * letter grade:: A letter grade, following the assignment's defined letter
         * grading scheme. For example, "A-". The resulting score will be the high
         * end of the defined range for the letter grade. For instance, if "B" is
         * defined as 86% to 84%, a letter grade of "B" will be worth 86%. The
         * letter grade will be rejected if the assignment does not have a defined
         * letter grading scheme. For more fine-grained control of scores, pass in
         * points or percentage rather than the letter grade.
         * "pass/complete/fail/incomplete":: A string value of "pass" or "complete"
         * will give a score of 100%. "fail" or "incomplete" will give a score of
         * 0.
         *
         * Note that assignments with grading_type of "pass_fail" can only be
         * assigned a score of 0 or assignment.points_possible, nothing inbetween. If
         * a posted_grade in the "points" or "percentage" format is sent, the grade
         * will only be accepted if the grade equals one of those two values.
         */
        'submission[posted_grade]'?: string;
        /**
         * Sets the seconds late if late policy status is "late"
         */
        'submission[seconds_late_override]'?: number;
    };
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}';
};

export type GradeOrCommentOnSubmissionSectionsResponses = {
    /**
     * No response was specified
     */
    200: Submission;
};

export type GradeOrCommentOnSubmissionSectionsResponse = GradeOrCommentOnSubmissionSectionsResponses[keyof GradeOrCommentOnSubmissionSectionsResponses];

export type UploadFileSectionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/files';
};

export type UploadFileSectionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkSubmissionAsUnreadSectionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/read';
};

export type MarkSubmissionAsUnreadSectionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MarkSubmissionAsReadSectionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        section_id: string;
        /**
         * ID
         */
        assignment_id: string;
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/read';
};

export type MarkSubmissionAsReadSectionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListEnrollmentsSectionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        section_id: number;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
        /**
         * A list of enrollment types to return. Accepted values are 'StudentEnrollment', 'TeacherEnrollment', 'TaEnrollment', 'DesignerEnrollment', and 'ObserverEnrollment.' If omitted, all enrollment types are returned. This argument is ignored if `role` is given.
         */
        type?: Array<string>;
        /**
         * A list of enrollment roles to return. Accepted values include course-level roles created by the {api:RoleOverridesController#add_role Add Role API} as well as the base enrollment types accepted by the `type` argument above.
         */
        role?: Array<string>;
        /**
         * Filter by enrollment state. If omitted, 'active' and 'invited' enrollments are returned. When querying a user's enrollments (either via user_id argument or via user enrollments endpoint), the following additional synthetic states are supported: "current_and_invited"|"current_and_future"|"current_and_concluded"
         */
        state?: Array<'active' | 'invited' | 'creation_pending' | 'deleted' | 'rejected' | 'completed' | 'inactive'>;
        /**
         * Array of additional information to include on the enrollment or user records. "avatar_url" and "group_ids" will be returned on the user record.
         */
        include?: Array<'avatar_url' | 'group_ids' | 'locked' | 'observed_users' | 'can_be_removed'>;
        /**
         * Filter by user_id (only valid for course or section enrollment queries). If set to the current user's id, this is a way to determine if the user has any enrollments in the course or section, independent of whether the user has permission to view other people on the roster.
         */
        user_id?: number;
        /**
         * Return grades for the given grading_period.  If this parameter is not specified, the returned grades will be for the whole course.
         */
        grading_period_id?: number;
        /**
         * Returns only enrollments for the specified enrollment term. This parameter only applies to the user enrollments path. May pass the ID from the enrollment terms api or the SIS id prepended with 'sis_term_id:'.
         */
        enrollment_term_id?: number;
        /**
         * Returns only enrollments for the specified SIS account ID(s). Does not look into sub_accounts. May pass in array or string.
         */
        sis_account_id?: Array<string>;
        /**
         * Returns only enrollments matching the specified SIS course ID(s). May pass in array or string.
         */
        sis_course_id?: Array<string>;
        /**
         * Returns only section enrollments matching the specified SIS section ID(s). May pass in array or string.
         */
        sis_section_id?: Array<string>;
        /**
         * Returns only enrollments for the specified SIS user ID(s). May pass in array or string.
         */
        sis_user_id?: Array<string>;
    };
    url: '/v1/sections/{section_id}/enrollments';
};

export type ListEnrollmentsSectionsResponses = {
    /**
     * No response was specified
     */
    200: Array<Enrollment>;
};

export type ListEnrollmentsSectionsResponse = ListEnrollmentsSectionsResponses[keyof ListEnrollmentsSectionsResponses];

export type EnrollUserSectionsData = {
    body: {
        /**
         * For an observer enrollment, the ID of a student to observe. The
         * caller must have +manage_students+ permission in the course.
         * This is a one-off operation; to automatically observe all a
         * student's enrollments (for example, as a parent), please use
         * the {api:UserObserveesController#create User Observees API}.
         */
        'enrollment[associated_user_id]'?: number;
        /**
         * The ID of the course section to enroll the student in. If the
         * section-specific URL is used, this argument is redundant and will be
         * ignored.
         */
        'enrollment[course_section_id]'?: number;
        /**
         * If set to 'active,' student will be immediately enrolled in the course.
         * Otherwise they will be required to accept a course invitation. Default is
         * 'invited.'.
         *
         * If set to 'inactive', student will be listed in the course roster for
         * teachers, but will not be able to participate in the course until
         * their enrollment is activated.
         */
        'enrollment[enrollment_state]'?: 'active' | 'invited' | 'inactive';
        /**
         * If set, the enrollment will only allow the user to see and interact with
         * users enrolled in the section given by course_section_id.
         * * For teachers and TAs, this includes grading privileges.
         * * Section-limited students will not see any users (including teachers
         * and TAs) not enrolled in their sections.
         * * Users may have other enrollments that grant privileges to
         * multiple sections in the same course.
         */
        'enrollment[limit_privileges_to_course_section]'?: boolean;
        /**
         * If true, a notification will be sent to the enrolled user.
         * Notifications are not sent by default.
         */
        'enrollment[notify]'?: boolean;
        /**
         * Assigns a custom course-level role to the user.
         */
        'enrollment[role]'?: unknown;
        /**
         * Assigns a custom course-level role to the user.
         */
        'enrollment[role_id]'?: number;
        /**
         * If true, marks the enrollment as a self-enrollment, which gives
         * students the ability to drop the course if desired. Defaults to false.
         */
        'enrollment[self_enrolled]'?: boolean;
        /**
         * If the current user is not allowed to manage enrollments in this
         * course, but the course allows self-enrollment, the user can self-
         * enroll as a student in the default section by passing in a valid
         * code. When self-enrolling, the user_id must be 'self'. The
         * enrollment_state will be set to 'active' and all other arguments
         * will be ignored.
         */
        'enrollment[self_enrollment_code]'?: string;
        /**
         * Enroll the user as a student, teacher, TA, observer, or designer. If no
         * value is given, the type will be inferred by enrollment[role] if supplied,
         * otherwise 'StudentEnrollment' will be used.
         */
        'enrollment[type]': 'StudentEnrollment' | 'TeacherEnrollment' | 'TaEnrollment' | 'ObserverEnrollment' | 'DesignerEnrollment';
        /**
         * The ID of the user to be enrolled in the course.
         */
        'enrollment[user_id]': string;
    };
    path: {
        /**
         * ID
         */
        section_id: string;
    };
    query?: never;
    url: '/v1/sections/{section_id}/enrollments';
};

export type EnrollUserSectionsResponses = {
    /**
     * No response was specified
     */
    200: Enrollment;
};

export type EnrollUserSectionsResponse = EnrollUserSectionsResponses[keyof EnrollUserSectionsResponses];

export type ListSubmissionsForMultipleAssignmentsSectionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        section_id: string;
    };
    query?: {
        /**
         * List of student ids to return submissions for. If this argument is
         * omitted, return submissions for the calling user. Students may only list
         * their own submissions. Observers may only list those of associated
         * students. The special id "all" will return submissions for all students
         * in the course/section as appropriate.
         */
        student_ids?: Array<string>;
        /**
         * List of assignments to return submissions for. If none are given,
         * submissions for all assignments are returned.
         */
        assignment_ids?: Array<string>;
        /**
         * If this argument is present, the response will be grouped by student,
         * rather than a flat array of submissions.
         */
        grouped?: boolean;
        /**
         * If this argument is set to true, the response will only include
         * submissions for assignments that have the post_to_sis flag set to true and
         * user enrollments that were added through sis.
         */
        post_to_sis?: boolean;
        /**
         * If this argument is set, the response will only include submissions that
         * were submitted after the specified date_time. This will exclude
         * submissions that do not have a submitted_at which will exclude unsubmitted
         * submissions.
         * The value must be formatted as ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         */
        submitted_since?: string;
        /**
         * If this argument is set, the response will only include submissions that
         * were graded after the specified date_time. This will exclude
         * submissions that have not been graded.
         * The value must be formatted as ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         */
        graded_since?: string;
        /**
         * The id of the grading period in which submissions are being requested
         * (Requires grading periods to exist on the account)
         */
        grading_period_id?: number;
        /**
         * The current status of the submission
         */
        workflow_state?: 'submitted' | 'unsubmitted' | 'graded' | 'pending_review';
        /**
         * The current state of the enrollments. If omitted will include all
         * enrollments that are not deleted.
         */
        enrollment_state?: 'active' | 'concluded';
        /**
         * If omitted it is set to true. When set to false it will ignore the effective
         * state of the student enrollments and use the workflow_state for the
         * enrollments. The argument is ignored unless enrollment_state argument is
         * also passed.
         */
        state_based_on_date?: boolean;
        /**
         * The order submissions will be returned in.  Defaults to "id".  Doesn't
         * affect results for "grouped" mode.
         */
        order?: 'id' | 'graded_at';
        /**
         * Determines whether ordered results are returned in ascending or descending
         * order.  Defaults to "ascending".  Doesn't affect results for "grouped" mode.
         */
        order_direction?: 'ascending' | 'descending';
        /**
         * Associations to include with the group. `total_scores` requires the
         * `grouped` argument.
         */
        include?: Array<'submission_history' | 'submission_comments' | 'rubric_assessment' | 'assignment' | 'total_scores' | 'visibility' | 'course' | 'user'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/sections/{section_id}/students/submissions';
};

export type ListSubmissionsForMultipleAssignmentsSectionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GradeOrCommentOnMultipleSubmissionsSectionsSubmissionsData = {
    body?: {
        /**
         * Specifies which assignment to grade.  This argument is not necessary when
         * using the assignment-specific endpoints.
         */
        'grade_data[student_id][assignment_id]'?: number;
        /**
         * See documentation for the excuse argument in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][excuse]'?: boolean;
        /**
         * See documentation for the comment[] arguments in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][file_ids]'?: Array<number>;
        /**
         * no description
         */
        'grade_data[student_id][group_comment]'?: boolean;
        /**
         * no description
         */
        'grade_data[student_id][media_comment_id]'?: string;
        /**
         * no description
         */
        'grade_data[student_id][media_comment_type]'?: 'audio' | 'video';
        /**
         * See documentation for the posted_grade argument in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][posted_grade]'?: string;
        /**
         * See documentation for the rubric_assessment argument in the
         * {api:SubmissionsApiController#update Submissions Update} documentation
         */
        'grade_data[student_id][rubric_assessment]'?: unknown;
        /**
         * no description
         */
        'grade_data[student_id][text_comment]'?: string;
    };
    path: {
        /**
         * ID
         */
        section_id: string;
    };
    query?: never;
    url: '/v1/sections/{section_id}/submissions/update_grades';
};

export type GradeOrCommentOnMultipleSubmissionsSectionsSubmissionsResponses = {
    /**
     * No response was specified
     */
    200: Progress;
};

export type GradeOrCommentOnMultipleSubmissionsSectionsSubmissionsResponse = GradeOrCommentOnMultipleSubmissionsSectionsSubmissionsResponses[keyof GradeOrCommentOnMultipleSubmissionsSectionsSubmissionsResponses];

export type GetKalturaConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/services/kaltura';
};

export type GetKalturaConfigResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type StartKalturaSessionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/services/kaltura_session';
};

export type StartKalturaSessionResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UnShareBrandconfigThemeData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/shared_brand_configs/{id}';
};

export type UnShareBrandconfigThemeResponses = {
    /**
     * No response was specified
     */
    200: SharedBrandConfig;
};

export type UnShareBrandconfigThemeResponse = UnShareBrandconfigThemeResponses[keyof UnShareBrandconfigThemeResponses];

export type ListActivityStreamActivityStreamData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * If true, will only return objects for courses the user is actively participating in
         */
        only_active_courses?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/activity_stream';
};

export type ListActivityStreamActivityStreamResponses = {
    /**
     * Returns the current user's global activity stream, paginated.
     */
    200: Array<ActivityStream>;
};

export type ListActivityStreamActivityStreamResponse = ListActivityStreamActivityStreamResponses[keyof ListActivityStreamActivityStreamResponses];

export type HideAllStreamItemsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/self/activity_stream';
};

export type HideAllStreamItemsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListActivityStreamSelfData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/self/activity_stream';
};

export type ListActivityStreamSelfResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ActivityStreamSummaryData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/self/activity_stream/summary';
};

export type ActivityStreamSummaryResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type HideStreamItemData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/self/activity_stream/{id}';
};

export type HideStreamItemResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListBookmarksData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/self/bookmarks';
};

export type ListBookmarksResponses = {
    /**
     * No response was specified
     */
    200: Array<Bookmark>;
};

export type ListBookmarksResponse = ListBookmarksResponses[keyof ListBookmarksResponses];

export type CreateBookmarkData = {
    body?: {
        /**
         * The data associated with the bookmark
         */
        data?: string;
        /**
         * The name of the bookmark
         */
        name?: string;
        /**
         * The position of the bookmark. Defaults to the bottom.
         */
        position?: number;
        /**
         * The url of the bookmark
         */
        url?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/users/self/bookmarks';
};

export type CreateBookmarkResponses = {
    /**
     * No response was specified
     */
    200: Bookmark;
};

export type CreateBookmarkResponse = CreateBookmarkResponses[keyof CreateBookmarkResponses];

export type DeleteBookmarkData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/self/bookmarks/{id}';
};

export type DeleteBookmarkResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetBookmarkData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/self/bookmarks/{id}';
};

export type GetBookmarkResponses = {
    /**
     * No response was specified
     */
    200: Bookmark;
};

export type GetBookmarkResponse = GetBookmarkResponses[keyof GetBookmarkResponses];

export type UpdateBookmarkData = {
    body?: {
        /**
         * The data associated with the bookmark
         */
        data?: string;
        /**
         * The name of the bookmark
         */
        name?: string;
        /**
         * The position of the bookmark. Defaults to the bottom.
         */
        position?: number;
        /**
         * The url of the bookmark
         */
        url?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/self/bookmarks/{id}';
};

export type UpdateBookmarkResponses = {
    /**
     * No response was specified
     */
    200: Folder;
};

export type UpdateBookmarkResponse = UpdateBookmarkResponses[keyof UpdateBookmarkResponses];

export type DeletePushNotificationEndpointData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/self/communication_channels/push';
};

export type DeletePushNotificationEndpointResponses = {
    /**
     * No response was specified
     */
    200: SuccessTrue;
};

export type DeletePushNotificationEndpointResponse = DeletePushNotificationEndpointResponses[keyof DeletePushNotificationEndpointResponses];

export type UpdatePreferencesByCategoryData = {
    body: {
        /**
         * The desired frequency for each notification in the category
         */
        'notification_preferences[frequency]': string;
    };
    path: {
        /**
         * ID
         */
        communication_channel_id: string;
        /**
         * The name of the category. Must be parameterized (e.g. The category "Course Content" should be "course_content")
         */
        category: string;
    };
    query?: never;
    url: '/v1/users/self/communication_channels/{communication_channel_id}/notification_preference_categories/{category}';
};

export type UpdatePreferencesByCategoryResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateMultiplePreferencesCommunicationChannelIdData = {
    body: {
        /**
         * The desired frequency for <X> notification
         */
        'notification_preferences[X][frequency]': string;
    };
    path: {
        /**
         * ID
         */
        communication_channel_id: string;
    };
    query?: never;
    url: '/v1/users/self/communication_channels/{communication_channel_id}/notification_preferences';
};

export type UpdateMultiplePreferencesCommunicationChannelIdResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdatePreferenceCommunicationChannelIdData = {
    body: {
        /**
         * The desired frequency for this notification
         */
        'notification_preferences[frequency]': string;
    };
    path: {
        /**
         * ID
         */
        communication_channel_id: string;
        /**
         * ID
         */
        notification: string;
    };
    query?: never;
    url: '/v1/users/self/communication_channels/{communication_channel_id}/notification_preferences/{notification}';
};

export type UpdatePreferenceCommunicationChannelIdResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateMultiplePreferencesTypeData = {
    body: {
        /**
         * The desired frequency for <X> notification
         */
        'notification_preferences[X][frequency]': string;
    };
    path: {
        /**
         * ID
         */
        type: string;
        /**
         * ID
         */
        address: string;
    };
    query?: never;
    url: '/v1/users/self/communication_channels/{type}/{address}/notification_preferences';
};

export type UpdateMultiplePreferencesTypeResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdatePreferenceTypeData = {
    body: {
        /**
         * The desired frequency for this notification
         */
        'notification_preferences[frequency]': string;
    };
    path: {
        /**
         * ID
         */
        type: string;
        /**
         * ID
         */
        address: string;
        /**
         * ID
         */
        notification: string;
    };
    query?: never;
    url: '/v1/users/self/communication_channels/{type}/{address}/notification_preferences/{notification}';
};

export type UpdatePreferenceTypeResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ClearCourseNicknamesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/self/course_nicknames';
};

export type ClearCourseNicknamesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListCourseNicknamesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/self/course_nicknames';
};

export type ListCourseNicknamesResponses = {
    /**
     * No response was specified
     */
    200: Array<CourseNickname>;
};

export type ListCourseNicknamesResponse = ListCourseNicknamesResponses[keyof ListCourseNicknamesResponses];

export type RemoveCourseNicknameData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/users/self/course_nicknames/{course_id}';
};

export type RemoveCourseNicknameResponses = {
    /**
     * No response was specified
     */
    200: CourseNickname;
};

export type RemoveCourseNicknameResponse = RemoveCourseNicknameResponses[keyof RemoveCourseNicknameResponses];

export type GetCourseNicknameData = {
    body?: never;
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/users/self/course_nicknames/{course_id}';
};

export type GetCourseNicknameResponses = {
    /**
     * No response was specified
     */
    200: CourseNickname;
};

export type GetCourseNicknameResponse = GetCourseNicknameResponses[keyof GetCourseNicknameResponses];

export type SetCourseNicknameData = {
    body: {
        /**
         * The nickname to set.  It must be non-empty and shorter than 60 characters.
         */
        nickname: string;
    };
    path: {
        /**
         * ID
         */
        course_id: string;
    };
    query?: never;
    url: '/v1/users/self/course_nicknames/{course_id}';
};

export type SetCourseNicknameResponses = {
    /**
     * No response was specified
     */
    200: CourseNickname;
};

export type SetCourseNicknameResponse = SetCourseNicknameResponses[keyof SetCourseNicknameResponses];

export type ResetCourseFavoritesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/self/favorites/courses';
};

export type ResetCourseFavoritesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListFavoriteCoursesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * When set, only return courses that are not configured as blueprint courses.
         */
        exclude_blueprint_courses?: boolean;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/self/favorites/courses';
};

export type ListFavoriteCoursesResponses = {
    /**
     * No response was specified
     */
    200: Array<Course>;
};

export type ListFavoriteCoursesResponse = ListFavoriteCoursesResponses[keyof ListFavoriteCoursesResponses];

export type RemoveCourseFromFavoritesData = {
    body?: never;
    path: {
        /**
         * the ID or SIS ID of the course to remove
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/self/favorites/courses/{id}';
};

export type RemoveCourseFromFavoritesResponses = {
    /**
     * No response was specified
     */
    200: Favorite;
};

export type RemoveCourseFromFavoritesResponse = RemoveCourseFromFavoritesResponses[keyof RemoveCourseFromFavoritesResponses];

export type AddCourseToFavoritesData = {
    body?: never;
    path: {
        /**
         * The ID or SIS ID of the course to add.  The current user must be
         * registered in the course.
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/self/favorites/courses/{id}';
};

export type AddCourseToFavoritesResponses = {
    /**
     * No response was specified
     */
    200: Favorite;
};

export type AddCourseToFavoritesResponse = AddCourseToFavoritesResponses[keyof AddCourseToFavoritesResponses];

export type ResetGroupFavoritesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/self/favorites/groups';
};

export type ResetGroupFavoritesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListFavoriteGroupsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/self/favorites/groups';
};

export type ListFavoriteGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<Group>;
};

export type ListFavoriteGroupsResponse = ListFavoriteGroupsResponses[keyof ListFavoriteGroupsResponses];

export type RemoveGroupFromFavoritesData = {
    body?: never;
    path: {
        /**
         * the ID or SIS ID of the group to remove
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/self/favorites/groups/{id}';
};

export type RemoveGroupFromFavoritesResponses = {
    /**
     * No response was specified
     */
    200: Favorite;
};

export type RemoveGroupFromFavoritesResponse = RemoveGroupFromFavoritesResponses[keyof RemoveGroupFromFavoritesResponses];

export type AddGroupToFavoritesData = {
    body?: never;
    path: {
        /**
         * The ID or SIS ID of the group to add.  The current user must be
         * a member of the group.
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/self/favorites/groups/{id}';
};

export type AddGroupToFavoritesResponses = {
    /**
     * No response was specified
     */
    200: Favorite;
};

export type AddGroupToFavoritesResponse = AddGroupToFavoritesResponses[keyof AddGroupToFavoritesResponses];

export type ListYourGroupsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Only include groups that are in this type of context.
         */
        context_type?: 'Account' | 'Course';
        /**
         * - "tabs": Include the list of tabs configured for each group.  See the
         * {api:TabsController#index List available tabs API} for more information.
         */
        include?: Array<'tabs'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/self/groups';
};

export type ListYourGroupsResponses = {
    /**
     * No response was specified
     */
    200: Array<Group>;
};

export type ListYourGroupsResponse = ListYourGroupsResponses[keyof ListYourGroupsResponses];

export type GetPandataEventsJwtTokenAndItsExpirationDateData = {
    body?: {
        /**
         * The pandata events appKey for this mobile app
         */
        app_key?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/users/self/pandata_events_token';
};

export type GetPandataEventsJwtTokenAndItsExpirationDateResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListTodoItemsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * "ungraded_quizzes":: Optionally include ungraded quizzes (such as practice quizzes and surveys) in the list.
         * These will be returned under a +quiz+ key instead of an +assignment+ key in response elements.
         */
        include?: Array<'ungraded_quizzes'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/self/todo';
};

export type ListTodoItemsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListCountsForTodoItemsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * "ungraded_quizzes":: Optionally include ungraded quizzes (such as practice quizzes and surveys) in the list.
         * These will be returned under a +quiz+ key instead of an +assignment+ key in response elements.
         */
        include?: Array<'ungraded_quizzes'>;
    };
    url: '/v1/users/self/todo_item_count';
};

export type ListCountsForTodoItemsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListUpcomingAssignmentsCalendarEventsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/self/upcoming_events';
};

export type ListUpcomingAssignmentsCalendarEventsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ShowUserDetailsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{id}';
};

export type ShowUserDetailsResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type ShowUserDetailsResponse = ShowUserDetailsResponses[keyof ShowUserDetailsResponses];

export type EditUserData = {
    body?: {
        /**
         * A unique representation of the avatar record to assign as the user's
         * current avatar. This token can be obtained from the user avatars endpoint.
         * This supersedes the user [avatar] [url] argument, and if both are included
         * the url will be ignored. Note: this is an internal representation and is
         * subject to change without notice. It should be consumed with this api
         * endpoint and used in the user update endpoint, and should not be
         * constructed by the client.
         */
        'user[avatar][token]'?: string;
        /**
         * To set the user's avatar to point to an external url, do not include a
         * token and instead pass the url here. Warning: For maximum compatibility,
         * please use 128 px square images.
         */
        'user[avatar][url]'?: string;
        /**
         * The default email address of the user.
         */
        'user[email]'?: string;
        /**
         * The user's preferred language, from the list of languages Canvas supports.
         * This is in RFC-5646 format.
         */
        'user[locale]'?: string;
        /**
         * The full name of the user. This name will be used by teacher for grading.
         */
        'user[name]'?: string;
        /**
         * User's name as it will be displayed in discussions, messages, and comments.
         */
        'user[short_name]'?: string;
        /**
         * User's name as used to sort alphabetically in lists.
         */
        'user[sortable_name]'?: string;
        /**
         * The time zone for the user. Allowed time zones are
         * {http://www.iana.org/time-zones IANA time zones} or friendlier
         * {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
         */
        'user[time_zone]'?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{id}';
};

export type EditUserResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type EditUserResponse = EditUserResponses[keyof EditUserResponses];

export type GetCustomColorsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{id}/colors';
};

export type GetCustomColorsResponses = {
    /**
     * No response was specified
     */
    200: CustomColors;
};

export type GetCustomColorsResponse = GetCustomColorsResponses[keyof GetCustomColorsResponses];

export type GetCustomColorData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
        /**
         * ID
         */
        asset_string: string;
    };
    query?: never;
    url: '/v1/users/{id}/colors/{asset_string}';
};

export type GetCustomColorResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateCustomColorData = {
    body?: {
        /**
         * The hexcode of the color to set for the context, if you choose to pass the
         * hexcode as a query parameter rather than in the request body you should
         * NOT include the '#' unless you escape it first.
         */
        hexcode?: string;
    };
    path: {
        /**
         * ID
         */
        id: string;
        /**
         * ID
         */
        asset_string: string;
    };
    query?: never;
    url: '/v1/users/{id}/colors/{asset_string}';
};

export type UpdateCustomColorResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetDashboardPositionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{id}/dashboard_positions';
};

export type GetDashboardPositionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type UpdateDashboardPositionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{id}/dashboard_positions';
};

export type UpdateDashboardPositionsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type MergeUserIntoAnotherUserAccountsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
        /**
         * ID
         */
        destination_account_id: string;
        /**
         * ID
         */
        destination_user_id: string;
    };
    query?: never;
    url: '/v1/users/{id}/merge_into/accounts/{destination_account_id}/users/{destination_user_id}';
};

export type MergeUserIntoAnotherUserAccountsResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type MergeUserIntoAnotherUserAccountsResponse = MergeUserIntoAnotherUserAccountsResponses[keyof MergeUserIntoAnotherUserAccountsResponses];

export type MergeUserIntoAnotherUserDestinationUserIdData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
        /**
         * ID
         */
        destination_user_id: string;
    };
    query?: never;
    url: '/v1/users/{id}/merge_into/{destination_user_id}';
};

export type MergeUserIntoAnotherUserDestinationUserIdResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type MergeUserIntoAnotherUserDestinationUserIdResponse = MergeUserIntoAnotherUserDestinationUserIdResponses[keyof MergeUserIntoAnotherUserDestinationUserIdResponses];

export type UpdateUserSettingsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * If true, require user to manually mark discussion posts as read (don't
         * auto-mark as read).
         */
        manual_mark_as_read?: boolean;
        /**
         * If true, the user's page loads with the global navigation collapsed
         */
        collapse_global_nav?: boolean;
    };
    url: '/v1/users/{id}/settings';
};

export type UpdateUserSettingsResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type SplitMergedUsersIntoSeparateUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{id}/split';
};

export type SplitMergedUsersIntoSeparateUsersResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type SplitMergedUsersIntoSeparateUsersResponse = SplitMergedUsersIntoSeparateUsersResponses[keyof SplitMergedUsersIntoSeparateUsersResponses];

export type ListAvatarOptionsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/avatars';
};

export type ListAvatarOptionsResponses = {
    /**
     * No response was specified
     */
    200: Array<Avatar>;
};

export type ListAvatarOptionsResponse = ListAvatarOptionsResponses[keyof ListAvatarOptionsResponses];

export type ListCalendarEventsForUserData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * Defaults to "event"
         */
        type?: 'event' | 'assignment';
        /**
         * Only return events since the start_date (inclusive).
         * Defaults to today. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         */
        start_date?: string;
        /**
         * Only return events before the end_date (inclusive).
         * Defaults to start_date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
         * If end_date is the same as start_date, then only events on that day are
         * returned.
         */
        end_date?: string;
        /**
         * Defaults to false (dated events only).
         * If true, only return undated events and ignore start_date and end_date.
         */
        undated?: boolean;
        /**
         * Defaults to false (uses start_date, end_date, and undated criteria).
         * If true, all events are returned, ignoring start_date, end_date, and undated criteria.
         */
        all_events?: boolean;
        /**
         * List of context codes of courses/groups/users whose events you want to see.
         * If not specified, defaults to the current user (i.e personal calendar,
         * no course/group events). Limited to 10 context codes, additional ones are
         * ignored. The format of this field is the context type, followed by an
         * underscore, followed by the context id. For example: course_42
         */
        context_codes?: Array<string>;
        /**
         * Array of attributes to exclude. Possible values are "description", "child_events" and "assignment"
         */
        excludes?: Array<Array<{
            [key: string]: unknown;
        }>>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/calendar_events';
};

export type ListCalendarEventsForUserResponses = {
    /**
     * No response was specified
     */
    200: Array<CalendarEvent>;
};

export type ListCalendarEventsForUserResponse = ListCalendarEventsForUserResponses[keyof ListCalendarEventsForUserResponses];

export type ListUserCommunicationChannelsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/communication_channels';
};

export type ListUserCommunicationChannelsResponses = {
    /**
     * No response was specified
     */
    200: Array<CommunicationChannel>;
};

export type ListUserCommunicationChannelsResponse = ListUserCommunicationChannelsResponses[keyof ListUserCommunicationChannelsResponses];

export type CreateCommunicationChannelData = {
    body: {
        /**
         * An email address or SMS number. Not required for "push" type channels.
         */
        'communication_channel[address]': string;
        /**
         * A registration id, device token, or equivalent token given to an app when
         * registering with a push notification provider. Only valid for "push" type channels.
         */
        'communication_channel[token]'?: string;
        /**
         * The type of communication channel.
         *
         * In order to enable push notification support, the server must be
         * properly configured (via sns.yml) to communicate with Amazon
         * Simple Notification Services, and the developer key used to create
         * the access token from this request must have an SNS ARN configured on
         * it.
         */
        'communication_channel[type]': 'email' | 'sms' | 'push';
        /**
         * Only valid for site admins and account admins making requests; If true, the channel is
         * automatically validated and no confirmation email or SMS is sent.
         * Otherwise, the user must respond to a confirmation message to confirm the
         * channel.
         */
        skip_confirmation?: boolean;
    };
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/communication_channels';
};

export type CreateCommunicationChannelResponses = {
    /**
     * No response was specified
     */
    200: CommunicationChannel;
};

export type CreateCommunicationChannelResponse = CreateCommunicationChannelResponses[keyof CreateCommunicationChannelResponses];

export type ListOfPreferenceCategoriesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        communication_channel_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/communication_channels/{communication_channel_id}/notification_preference_categories';
};

export type ListOfPreferenceCategoriesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListPreferencesCommunicationChannelIdData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        communication_channel_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/communication_channels/{communication_channel_id}/notification_preferences';
};

export type ListPreferencesCommunicationChannelIdResponses = {
    /**
     * No response was specified
     */
    200: Array<NotificationPreference>;
};

export type ListPreferencesCommunicationChannelIdResponse = ListPreferencesCommunicationChannelIdResponses[keyof ListPreferencesCommunicationChannelIdResponses];

export type GetPreferenceCommunicationChannelIdData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        communication_channel_id: string;
        /**
         * ID
         */
        notification: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/communication_channels/{communication_channel_id}/notification_preferences/{notification}';
};

export type GetPreferenceCommunicationChannelIdResponses = {
    /**
     * No response was specified
     */
    200: NotificationPreference;
};

export type GetPreferenceCommunicationChannelIdResponse = GetPreferenceCommunicationChannelIdResponses[keyof GetPreferenceCommunicationChannelIdResponses];

export type DeleteCommunicationChannelIdData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/communication_channels/{id}';
};

export type DeleteCommunicationChannelIdResponses = {
    /**
     * No response was specified
     */
    200: CommunicationChannel;
};

export type DeleteCommunicationChannelIdResponse = DeleteCommunicationChannelIdResponses[keyof DeleteCommunicationChannelIdResponses];

export type DeleteCommunicationChannelTypeData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        type: string;
        /**
         * ID
         */
        address: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/communication_channels/{type}/{address}';
};

export type DeleteCommunicationChannelTypeResponses = {
    /**
     * No response was specified
     */
    200: CommunicationChannel;
};

export type DeleteCommunicationChannelTypeResponse = DeleteCommunicationChannelTypeResponses[keyof DeleteCommunicationChannelTypeResponses];

export type ListPreferencesTypeData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        type: string;
        /**
         * ID
         */
        address: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/communication_channels/{type}/{address}/notification_preferences';
};

export type ListPreferencesTypeResponses = {
    /**
     * No response was specified
     */
    200: Array<NotificationPreference>;
};

export type ListPreferencesTypeResponse = ListPreferencesTypeResponses[keyof ListPreferencesTypeResponses];

export type GetPreferenceTypeData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        type: string;
        /**
         * ID
         */
        address: string;
        /**
         * ID
         */
        notification: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/communication_channels/{type}/{address}/notification_preferences/{notification}';
};

export type GetPreferenceTypeResponses = {
    /**
     * No response was specified
     */
    200: NotificationPreference;
};

export type GetPreferenceTypeResponse = GetPreferenceTypeResponses[keyof GetPreferenceTypeResponses];

export type ListContentExportsUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/content_exports';
};

export type ListContentExportsUsersResponses = {
    /**
     * No response was specified
     */
    200: Array<ContentExport>;
};

export type ListContentExportsUsersResponse = ListContentExportsUsersResponses[keyof ListContentExportsUsersResponses];

export type ExportContentUsersData = {
    body: {
        /**
         * "common_cartridge":: Export the contents of the course in the Common Cartridge (.imscc) format
         * "qti":: Export quizzes from a course in the QTI format
         * "zip":: Export files from a course, group, or user in a zip file
         */
        export_type: 'common_cartridge' | 'qti' | 'zip';
        /**
         * The select parameter allows exporting specific data. The keys are object types like 'files',
         * 'folders', 'pages', etc. The value for each key is a list of object ids. An id can be an
         * integer or a string.
         *
         * Multiple object types can be selected in the same call. However, not all object types are
         * valid for every export_type. Common Cartridge supports all object types. Zip and QTI only
         * support the object types as described below.
         *
         * "folders":: Also supported for zip export_type.
         * "files":: Also supported for zip export_type.
         * "quizzes":: Also supported for qti export_type.
         */
        select?: 'folders' | 'files' | 'attachments' | 'quizzes' | 'assignments' | 'announcements' | 'calendar_events' | 'discussion_topics' | 'modules' | 'module_items' | 'pages' | 'rubrics';
        /**
         * Don't send the notifications about the export to the user. Default: false
         */
        skip_notifications?: boolean;
    };
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/content_exports';
};

export type ExportContentUsersResponses = {
    /**
     * No response was specified
     */
    200: ContentExport;
};

export type ExportContentUsersResponse = ExportContentUsersResponses[keyof ExportContentUsersResponses];

export type ShowContentExportUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/content_exports/{id}';
};

export type ShowContentExportUsersResponses = {
    /**
     * No response was specified
     */
    200: ContentExport;
};

export type ShowContentExportUsersResponse = ShowContentExportUsersResponses[keyof ShowContentExportUsersResponses];

export type ListLicensesUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/content_licenses';
};

export type ListLicensesUsersResponses = {
    /**
     * No response was specified
     */
    200: Array<License>;
};

export type ListLicensesUsersResponse = ListLicensesUsersResponses[keyof ListLicensesUsersResponses];

export type ListContentMigrationsUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/content_migrations';
};

export type ListContentMigrationsUsersResponses = {
    /**
     * No response was specified
     */
    200: Array<ContentMigration>;
};

export type ListContentMigrationsUsersResponse = ListContentMigrationsUsersResponses[keyof ListContentMigrationsUsersResponses];

export type CreateContentMigrationUsersData = {
    body: {
        /**
         * Move anything scheduled for day 'X' to the specified day. (0-Sunday,
         * 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
         */
        'date_shift_options[day_substitutions][X]'?: number;
        /**
         * The new end date for the source content/course
         */
        'date_shift_options[new_end_date]'?: string;
        /**
         * The new start date for the content/course
         */
        'date_shift_options[new_start_date]'?: string;
        /**
         * The original end date of the source content/course
         */
        'date_shift_options[old_end_date]'?: string;
        /**
         * The original start date of the source content/course
         */
        'date_shift_options[old_start_date]'?: string;
        /**
         * Whether to remove dates in the copied course. Cannot be used
         * in conjunction with *shift_dates*.
         */
        'date_shift_options[remove_dates]'?: boolean;
        /**
         * Whether to shift dates in the copied course
         */
        'date_shift_options[shift_dates]'?: boolean;
        /**
         * The type of the migration. Use the
         * {api:ContentMigrationsController#available_migrators Migrator} endpoint to
         * see all available migrators. Default allowed values:
         * canvas_cartridge_importer, common_cartridge_importer,
         * course_copy_importer, zip_file_importer, qti_converter, moodle_converter
         */
        migration_type: string;
        /**
         * Required if uploading a file. This is the first step in uploading a file
         * to the content migration. See the {file:file_uploads.html File Upload
         * Documentation} for details on the file upload workflow.
         */
        'pre_attachment[name]'?: string;
        /**
         * Other file upload properties, See {file:file_uploads.html File Upload
         * Documentation}
         */
        'pre_attachment[todo]'?: string;
        /**
         * A URL to download the file from. Must not require authentication.
         */
        'settings[file_url]'?: string;
        /**
         * The folder to unzip the .zip file into for a zip_file_import.
         */
        'settings[folder_id]'?: string;
        /**
         * Whether to overwrite quizzes with the same identifiers between content
         * packages.
         */
        'settings[overwrite_quizzes]'?: boolean;
        /**
         * The existing question bank ID to import questions into if not specified in
         * the content package.
         */
        'settings[question_bank_id]'?: number;
        /**
         * The question bank to import questions into if not specified in the content
         * package, if both bank id and name are set, id will take precedence.
         */
        'settings[question_bank_name]'?: string;
        /**
         * The course to copy from for a course copy migration. (required if doing
         * course copy)
         */
        'settings[source_course_id]'?: string;
    };
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/content_migrations';
};

export type CreateContentMigrationUsersResponses = {
    /**
     * No response was specified
     */
    200: ContentMigration;
};

export type CreateContentMigrationUsersResponse = CreateContentMigrationUsersResponses[keyof CreateContentMigrationUsersResponses];

export type ListMigrationSystemsUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/content_migrations/migrators';
};

export type ListMigrationSystemsUsersResponses = {
    /**
     * No response was specified
     */
    200: Array<Migrator>;
};

export type ListMigrationSystemsUsersResponse = ListMigrationSystemsUsersResponses[keyof ListMigrationSystemsUsersResponses];

export type ListMigrationIssuesUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        content_migration_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/content_migrations/{content_migration_id}/migration_issues';
};

export type ListMigrationIssuesUsersResponses = {
    /**
     * No response was specified
     */
    200: Array<MigrationIssue>;
};

export type ListMigrationIssuesUsersResponse = ListMigrationIssuesUsersResponses[keyof ListMigrationIssuesUsersResponses];

export type GetMigrationIssueUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        content_migration_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/content_migrations/{content_migration_id}/migration_issues/{id}';
};

export type GetMigrationIssueUsersResponses = {
    /**
     * No response was specified
     */
    200: MigrationIssue;
};

export type GetMigrationIssueUsersResponse = GetMigrationIssueUsersResponses[keyof GetMigrationIssueUsersResponses];

export type UpdateMigrationIssueUsersData = {
    body: {
        /**
         * Set the workflow_state of the issue.
         */
        workflow_state: 'active' | 'resolved';
    };
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        content_migration_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/content_migrations/{content_migration_id}/migration_issues/{id}';
};

export type UpdateMigrationIssueUsersResponses = {
    /**
     * No response was specified
     */
    200: MigrationIssue;
};

export type UpdateMigrationIssueUsersResponse = UpdateMigrationIssueUsersResponses[keyof UpdateMigrationIssueUsersResponses];

export type GetContentMigrationUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/content_migrations/{id}';
};

export type GetContentMigrationUsersResponses = {
    /**
     * No response was specified
     */
    200: ContentMigration;
};

export type GetContentMigrationUsersResponse = GetContentMigrationUsersResponses[keyof GetContentMigrationUsersResponses];

export type UpdateContentMigrationUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/content_migrations/{id}';
};

export type UpdateContentMigrationUsersResponses = {
    /**
     * No response was specified
     */
    200: ContentMigration;
};

export type UpdateContentMigrationUsersResponse = UpdateContentMigrationUsersResponses[keyof UpdateContentMigrationUsersResponses];

export type ListCoursesForUserData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
        /**
         * - "needs_grading_count": Optional information to include with each Course.
         * When needs_grading_count is given, and the current user has grading
         * rights, the total number of submissions needing grading for all
         * assignments is returned.
         * - "syllabus_body": Optional information to include with each Course.
         * When syllabus_body is given the user-generated html for the course
         * syllabus is returned.
         * - "public_description": Optional information to include with each Course.
         * When public_description is given the user-generated text for the course
         * public description is returned.
         * - "total_scores": Optional information to include with each Course.
         * When total_scores is given, any student enrollments will also
         * include the fields 'computed_current_score', 'computed_final_score',
         * 'computed_current_grade', and 'computed_final_grade' (see Enrollment
         * documentation for more information on these fields). This argument
         * is ignored if the course is configured to hide final grades.
         * - "current_grading_period_scores": Optional information to include with
         * each Course. When current_grading_period_scores is given and total_scores
         * is given, any student enrollments will also include the fields
         * 'has_grading_periods',
         * 'totals_for_all_grading_periods_option', 'current_grading_period_title',
         * 'current_grading_period_id', current_period_computed_current_score',
         * 'current_period_computed_final_score',
         * 'current_period_computed_current_grade', and
         * 'current_period_computed_final_grade', as well as (if the user has permission)
         * 'current_period_unposted_current_score',
         * 'current_period_unposted_final_score',
         * 'current_period_unposted_current_grade', and
         * 'current_period_unposted_final_grade' (see Enrollment documentation for
         * more information on these fields). In addition, when this argument is
         * passed, the course will have a 'has_grading_periods' attribute
         * on it. This argument is ignored if the course is configured to hide final
         * grades or if the total_scores argument is not included.
         * - "term": Optional information to include with each Course. When
         * term is given, the information for the enrollment term for each course
         * is returned.
         * - "account": Optional information to include with each Course. When
         * account is given, the account json for each course is returned.
         * - "course_progress": Optional information to include with each Course.
         * When course_progress is given, each course will include a
         * 'course_progress' object with the fields: 'requirement_count', an integer
         * specifying the total number of requirements in the course,
         * 'requirement_completed_count', an integer specifying the total number of
         * requirements in this course that have been completed, and
         * 'next_requirement_url', a string url to the next requirement item, and
         * 'completed_at', the date the course was completed (null if incomplete).
         * 'next_requirement_url' will be null if all requirements have been
         * completed or the current module does not require sequential progress.
         * "course_progress" will return an error message if the course is not
         * module based or the user is not enrolled as a student in the course.
         * - "sections": Section enrollment information to include with each Course.
         * Returns an array of hashes containing the section ID (id), section name
         * (name), start and end dates (start_at, end_at), as well as the enrollment
         * type (enrollment_role, e.g. 'StudentEnrollment').
         * - "storage_quota_used_mb": The amount of storage space used by the files in this course
         * - "total_students": Optional information to include with each Course.
         * Returns an integer for the total amount of active and invited students.
         * - "passback_status": Include the grade passback_status
         * - "favorites": Optional information to include with each Course.
         * Indicates if the user has marked the course as a favorite course.
         * - "teachers": Teacher information to include with each Course.
         * Returns an array of hashes containing the {api:Users:UserDisplay UserDisplay} information
         * for each teacher in the course.
         * - "observed_users": Optional information to include with each Course.
         * Will include data for observed users if the current user has an
         * observer enrollment.
         * - "tabs": Optional information to include with each Course.
         * Will include the list of tabs configured for each course.  See the
         * {api:TabsController#index List available tabs API} for more information.
         * - "course_image": Optional course image data for when there is a course image
         * and the course image feature flag has been enabled
         */
        include?: Array<'needs_grading_count' | 'syllabus_body' | 'public_description' | 'total_scores' | 'current_grading_period_scores' | 'term' | 'account' | 'course_progress' | 'sections' | 'storage_quota_used_mb' | 'total_students' | 'passback_status' | 'favorites' | 'teachers' | 'observed_users' | 'course_image'>;
        /**
         * If set, only return courses that are in the given state(s).
         * By default, "available" is returned for students and observers, and
         * anything except "deleted", for all other enrollment types
         */
        state?: Array<'unpublished' | 'available' | 'completed' | 'deleted'>;
        /**
         * When set, only return courses where the user has an enrollment with the given state.
         * This will respect section/course/term date overrides.
         */
        enrollment_state?: 'active' | 'invited_or_pending' | 'completed';
    };
    url: '/v1/users/{user_id}/courses';
};

export type ListCoursesForUserResponses = {
    /**
     * No response was specified
     */
    200: Array<CourseWithIncludes>;
};

export type ListCoursesForUserResponse = ListCoursesForUserResponses[keyof ListCoursesForUserResponses];

export type ListAssignmentsForUserData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        course_id: string;
    };
    query?: {
        /**
         * Associations to include with the assignment. The "assignment_visibility" option
         * requires that the Differentiated Assignments course feature be turned on. If
         * "observed_users" is passed, submissions for observed users will also be included as an array.
         */
        include?: Array<'submission' | 'assignment_visibility' | 'all_dates' | 'overrides' | 'observed_users'>;
        /**
         * The partial title of the assignments to match and return.
         */
        search_term?: string;
        /**
         * Apply assignment overrides for each assignment, defaults to true.
         */
        override_assignment_dates?: boolean;
        /**
         * Split up "needs_grading_count" by sections into the "needs_grading_count_by_section" key, defaults to false
         */
        needs_grading_count_by_section?: boolean;
        /**
         * If included, only return certain assignments depending on due date and submission status.
         */
        bucket?: 'past' | 'overdue' | 'undated' | 'ungraded' | 'unsubmitted' | 'upcoming' | 'future';
        /**
         * if set, return only assignments specified
         */
        assignment_ids?: Array<string>;
        /**
         * Determines the order of the assignments. Defaults to "position".
         */
        order_by?: 'position' | 'name';
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/courses/{course_id}/assignments';
};

export type ListAssignmentsForUserResponses = {
    /**
     * The assignments of a user.
     */
    200: Array<Assignment>;
};

export type ListAssignmentsForUserResponse = ListAssignmentsForUserResponses[keyof ListAssignmentsForUserResponses];

export type DeleteCustomDataData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query: {
        /**
         * The namespace from which to delete the data.  This should be something other
         * Canvas API apps aren't likely to use, such as a reverse DNS for your organization.
         */
        ns: string;
    };
    url: '/v1/users/{user_id}/custom_data';
};

export type DeleteCustomDataResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type LoadCustomDataData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query: {
        /**
         * The namespace from which to retrieve the data.  This should be something other
         * Canvas API apps aren't likely to use, such as a reverse DNS for your organization.
         */
        ns: string;
    };
    url: '/v1/users/{user_id}/custom_data';
};

export type LoadCustomDataResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type StoreCustomDataData = {
    body: {
        /**
         * The data you want to store for the user, at the specified scope.  If the data is
         * composed of (possibly nested) JSON objects, scopes will be generated for the (nested)
         * keys (see examples).
         */
        data: unknown;
        /**
         * The namespace under which to store the data.  This should be something other
         * Canvas API apps aren't likely to use, such as a reverse DNS for your organization.
         */
        ns: string;
    };
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/custom_data';
};

export type StoreCustomDataResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListEnrollmentsUsersData = {
    body?: never;
    path: {
        /**
         * Filter by user_id (only valid for course or section enrollment queries). If set to the current user's id, this is a way to determine if the user has any enrollments in the course or section, independent of whether the user has permission to view other people on the roster.
         */
        user_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
        /**
         * A list of enrollment types to return. Accepted values are 'StudentEnrollment', 'TeacherEnrollment', 'TaEnrollment', 'DesignerEnrollment', and 'ObserverEnrollment.' If omitted, all enrollment types are returned. This argument is ignored if `role` is given.
         */
        type?: Array<string>;
        /**
         * A list of enrollment roles to return. Accepted values include course-level roles created by the {api:RoleOverridesController#add_role Add Role API} as well as the base enrollment types accepted by the `type` argument above.
         */
        role?: Array<string>;
        /**
         * Filter by enrollment state. If omitted, 'active' and 'invited' enrollments are returned. When querying a user's enrollments (either via user_id argument or via user enrollments endpoint), the following additional synthetic states are supported: "current_and_invited"|"current_and_future"|"current_and_concluded"
         */
        state?: Array<'active' | 'invited' | 'creation_pending' | 'deleted' | 'rejected' | 'completed' | 'inactive'>;
        /**
         * Array of additional information to include on the enrollment or user records. "avatar_url" and "group_ids" will be returned on the user record.
         */
        include?: Array<'avatar_url' | 'group_ids' | 'locked' | 'observed_users' | 'can_be_removed'>;
        /**
         * Return grades for the given grading_period.  If this parameter is not specified, the returned grades will be for the whole course.
         */
        grading_period_id?: number;
        /**
         * Returns only enrollments for the specified enrollment term. This parameter only applies to the user enrollments path. May pass the ID from the enrollment terms api or the SIS id prepended with 'sis_term_id:'.
         */
        enrollment_term_id?: number;
        /**
         * Returns only enrollments for the specified SIS account ID(s). Does not look into sub_accounts. May pass in array or string.
         */
        sis_account_id?: Array<string>;
        /**
         * Returns only enrollments matching the specified SIS course ID(s).
         * May pass in array or string.
         */
        sis_course_id?: Array<string>;
        /**
         * Returns only section enrollments matching the specified SIS section ID(s).
         * May pass in array or string.
         */
        sis_section_id?: Array<string>;
        /**
         * Returns only enrollments for the specified SIS user ID(s). May pass in
         * array or string.
         */
        sis_user_id?: Array<string>;
    };
    url: '/v1/users/{user_id}/enrollments';
};

export type ListEnrollmentsUsersResponses = {
    /**
     * No response was specified
     */
    200: Array<Enrollment>;
};

export type ListEnrollmentsUsersResponse = ListEnrollmentsUsersResponses[keyof ListEnrollmentsUsersResponses];

export type ListFeaturesUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/features';
};

export type ListFeaturesUsersResponses = {
    /**
     * No response was specified
     */
    200: Array<Feature>;
};

export type ListFeaturesUsersResponse = ListFeaturesUsersResponses[keyof ListFeaturesUsersResponses];

export type ListEnabledFeaturesUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/features/enabled';
};

export type ListEnabledFeaturesUsersResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type RemoveFeatureFlagUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        feature: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/features/flags/{feature}';
};

export type RemoveFeatureFlagUsersResponses = {
    /**
     * No response was specified
     */
    200: FeatureFlag;
};

export type RemoveFeatureFlagUsersResponse = RemoveFeatureFlagUsersResponses[keyof RemoveFeatureFlagUsersResponses];

export type GetFeatureFlagUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        feature: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/features/flags/{feature}';
};

export type GetFeatureFlagUsersResponses = {
    /**
     * No response was specified
     */
    200: FeatureFlag;
};

export type GetFeatureFlagUsersResponse = GetFeatureFlagUsersResponses[keyof GetFeatureFlagUsersResponses];

export type SetFeatureFlagUsersData = {
    body?: {
        /**
         * "off":: The feature is not available for the course, user, or account and sub-accounts.
         * "allowed":: (valid only on accounts) The feature is off in the account, but may be enabled in
         * sub-accounts and courses by setting a feature flag on the sub-account or course.
         * "on":: The feature is turned on unconditionally for the user, course, or account and sub-accounts.
         */
        state?: false | 'allowed' | true;
    };
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        feature: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/features/flags/{feature}';
};

export type SetFeatureFlagUsersResponses = {
    /**
     * No response was specified
     */
    200: FeatureFlag;
};

export type SetFeatureFlagUsersResponse = SetFeatureFlagUsersResponses[keyof SetFeatureFlagUsersResponses];

export type UploadFileToUsersFilesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/files';
};

export type UploadFileToUsersFilesResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetQuotaInformationUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/files/quota';
};

export type GetQuotaInformationUsersResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type GetFileUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: {
        /**
         * Array of additional information to include.
         *
         * "user":: the user who uploaded the file or last edited its content
         * "usage_rights":: copyright and license information for the file (see UsageRights)
         */
        include?: Array<'user'>;
    };
    url: '/v1/users/{user_id}/files/{id}';
};

export type GetFileUsersResponses = {
    /**
     * No response was specified
     */
    200: File;
};

export type GetFileUsersResponse = GetFileUsersResponses[keyof GetFileUsersResponses];

export type ListAllFoldersUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/folders';
};

export type ListAllFoldersUsersResponses = {
    /**
     * No response was specified
     */
    200: Array<Folder>;
};

export type ListAllFoldersUsersResponse = ListAllFoldersUsersResponses[keyof ListAllFoldersUsersResponses];

export type CreateFolderUsersData = {
    body: {
        /**
         * Flag the folder as hidden
         */
        hidden?: boolean;
        /**
         * The datetime to lock the folder at
         */
        lock_at?: string;
        /**
         * Flag the folder as locked
         */
        locked?: boolean;
        /**
         * The name of the folder
         */
        name: string;
        /**
         * The id of the folder to store the file in. If this and parent_folder_path are sent an error will be returned. If neither is given, a default folder will be used.
         */
        parent_folder_id?: string;
        /**
         * The path of the folder to store the new folder in. The path separator is the forward slash `/`, never a back slash. The parent folder will be created if it does not already exist. This parameter only applies to new folders in a context that has folders, such as a user, a course, or a group. If this and parent_folder_id are sent an error will be returned. If neither is given, a default folder will be used.
         */
        parent_folder_path?: string;
        /**
         * Set an explicit sort position for the folder
         */
        position?: number;
        /**
         * The datetime to unlock the folder at
         */
        unlock_at?: string;
    };
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/folders';
};

export type CreateFolderUsersResponses = {
    /**
     * No response was specified
     */
    200: Folder;
};

export type CreateFolderUsersResponse = CreateFolderUsersResponses[keyof CreateFolderUsersResponses];

export type ResolvePathUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/folders/by_path';
};

export type ResolvePathUsersResponses = {
    /**
     * No response was specified
     */
    200: Array<Folder>;
};

export type ResolvePathUsersResponse = ResolvePathUsersResponses[keyof ResolvePathUsersResponses];

export type ResolvePathUsersFullPathData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/folders/by_path/*full_path';
};

export type ResolvePathUsersFullPathResponses = {
    /**
     * No response was specified
     */
    200: Array<Folder>;
};

export type ResolvePathUsersFullPathResponse = ResolvePathUsersFullPathResponses[keyof ResolvePathUsersFullPathResponses];

export type GetFolderUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/folders/{id}';
};

export type GetFolderUsersResponses = {
    /**
     * No response was specified
     */
    200: Folder;
};

export type GetFolderUsersResponse = GetFolderUsersResponses[keyof GetFolderUsersResponses];

export type ListUserLoginsUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/logins';
};

export type ListUserLoginsUsersResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type DeleteUserLoginData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/logins/{id}';
};

export type DeleteUserLoginResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type ListMissingSubmissionsData = {
    body?: never;
    path: {
        /**
         * the student's ID
         */
        user_id: string;
    };
    query?: {
        /**
         * "planner_overrides":: Optionally include the assignment's associated planner override, if it exists, for the current user.
         * These will be returned under a +planner_override+ key
         * "course":: Optionally include the assignments' courses
         */
        include?: Array<'planner_overrides' | 'course'>;
        /**
         * "submittable":: Only return assignments that the current user can submit (i.e. filter out locked assignments)
         */
        filter?: Array<'submittable'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/missing_submissions';
};

export type ListMissingSubmissionsResponses = {
    /**
     * No response was specified
     */
    200: Array<Assignment>;
};

export type ListMissingSubmissionsResponse = ListMissingSubmissionsResponses[keyof ListMissingSubmissionsResponses];

export type ListObserveesData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * - "avatar_url": Optionally include avatar_url.
         */
        include?: Array<'avatar_url'>;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/observees';
};

export type ListObserveesResponses = {
    /**
     * No response was specified
     */
    200: Array<User>;
};

export type ListObserveesResponse = ListObserveesResponses[keyof ListObserveesResponses];

export type AddObserveeWithCredentialsData = {
    body?: {
        /**
         * The access token for the user to observe.  Required if <tt>observee[unique_id]</tt> or <tt>observee[password]</tt> are omitted.
         */
        access_token?: string;
        /**
         * The password for the user to observe. Required if access_token is omitted.
         */
        'observee[password]'?: string;
        /**
         * The login id for the user to observe.  Required if access_token is omitted.
         */
        'observee[unique_id]'?: string;
        /**
         * A generated pairing code for the user to observe. Required if the Observer pairing code feature flag is enabled
         */
        pairing_code?: string;
        /**
         * The ID for the root account to associate with the observation link.
         * Defaults to the current domain account.
         * If 'all' is specified, a link will be created for each root account associated
         * to both the observer and observee.
         */
        root_account_id?: number;
    };
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/observees';
};

export type AddObserveeWithCredentialsResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type AddObserveeWithCredentialsResponse = AddObserveeWithCredentialsResponses[keyof AddObserveeWithCredentialsResponses];

export type RemoveObserveeData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        observee_id: string;
    };
    query?: {
        /**
         * If specified, only removes the link for the given root account
         */
        root_account_id?: number;
    };
    url: '/v1/users/{user_id}/observees/{observee_id}';
};

export type RemoveObserveeResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type RemoveObserveeResponse = RemoveObserveeResponses[keyof RemoveObserveeResponses];

export type ShowObserveeData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        observee_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/observees/{observee_id}';
};

export type ShowObserveeResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type ShowObserveeResponse = ShowObserveeResponses[keyof ShowObserveeResponses];

export type AddObserveeData = {
    body?: {
        /**
         * The ID for the root account to associate with the observation link.
         * If not specified, a link will be created for each root account associated
         * to both the observer and observee.
         */
        root_account_id?: number;
    };
    path: {
        /**
         * ID
         */
        user_id: string;
        /**
         * ID
         */
        observee_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/observees/{observee_id}';
};

export type AddObserveeResponses = {
    /**
     * No response was specified
     */
    200: User;
};

export type AddObserveeResponse = AddObserveeResponses[keyof AddObserveeResponses];

export type ListUserPageViewsData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: {
        /**
         * The beginning of the time range from which you want page views.
         */
        start_time?: string;
        /**
         * The end of the time range from which you want page views.
         */
        end_time?: string;
        /**
         * The bookmark leading to the next paginated page. This needs to be parsed from the response header ('Link' field).
         */
        page?: string;
        /**
         * The numbers of items to return.
         */
        per_page?: number;
    };
    url: '/v1/users/{user_id}/page_views';
};

export type ListUserPageViewsResponses = {
    /**
     * No response was specified
     */
    200: Array<PageView>;
};

export type ListUserPageViewsResponse = ListUserPageViewsResponses[keyof ListUserPageViewsResponses];

export type GetUserProfileData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/profile';
};

export type GetUserProfileResponses = {
    /**
     * No response was specified
     */
    200: Profile;
};

export type GetUserProfileResponse = GetUserProfileResponses[keyof GetUserProfileResponses];

export type RemoveUsageRightsUsersData = {
    body?: never;
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query: {
        /**
         * List of ids of files to remove associated usage rights from.
         */
        file_ids: Array<string>;
        /**
         * List of ids of folders. Usage rights will be removed from all files in these folders.
         */
        folder_ids?: Array<string>;
    };
    url: '/v1/users/{user_id}/usage_rights';
};

export type RemoveUsageRightsUsersResponses = {
    /**
     * No response was specified
     */
    200: unknown;
};

export type SetUsageRightsUsersData = {
    body: {
        /**
         * List of ids of files to set usage rights for.
         */
        file_ids: Array<string>;
        /**
         * List of ids of folders to search for files to set usage rights for.
         * Note that new files uploaded to these folders do not automatically inherit these rights.
         */
        folder_ids?: Array<string>;
        /**
         * Whether the file(s) or folder(s) should be published on save, provided that usage rights have been specified (set to `true` to publish on save).
         */
        publish?: boolean;
        /**
         * The legal copyright line for the files
         */
        'usage_rights[legal_copyright]'?: string;
        /**
         * The license that applies to the files. See the {api:UsageRightsController#licenses List licenses endpoint} for the supported license types.
         */
        'usage_rights[license]'?: string;
        /**
         * The intellectual property justification for using the files in Canvas
         */
        'usage_rights[use_justification]': 'own_copyright' | 'used_by_permission' | 'fair_use' | 'public_domain' | 'creative_commons';
    };
    path: {
        /**
         * ID
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/users/{user_id}/usage_rights';
};

export type SetUsageRightsUsersResponses = {
    /**
     * No response was specified
     */
    200: UsageRights;
};

export type SetUsageRightsUsersResponse = SetUsageRightsUsersResponses[keyof SetUsageRightsUsersResponses];

export type ClientOptions = {
    baseURL: `${string}://${string}` | (string & {});
};